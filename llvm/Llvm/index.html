<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml"><head><title>Llvm (llvm.Llvm)</title><link rel="stylesheet" href="../../odoc.css"/><meta charset="utf-8"/><meta name="generator" content="odoc 2.1.0"/><meta name="viewport" content="width=device-width,initial-scale=1.0"/><script src="../../highlight.pack.js"></script><script>hljs.initHighlightingOnLoad();</script></head><body class="odoc"><nav class="odoc-nav"><a href="../index.html">Up</a> â€“ <a href="../index.html">llvm</a> &#x00BB; Llvm</nav><header class="odoc-preamble"><h1>Module <code><span>Llvm</span></code></h1><p>Core API.</p><p>This interface provides an OCaml API for the LLVM intermediate representation, the classes in the VMCore library.</p></header><nav class="odoc-toc"><ul><li><a href="#abstract-types">Abstract types</a></li><li><a href="#iteration">Iteration</a></li><li><a href="#exceptions">Exceptions</a></li><li><a href="#global-configuration">Global configuration</a></li><li><a href="#context-error-handling">Context error handling</a></li><li><a href="#contexts">Contexts</a></li><li><a href="#attributes">Attributes</a></li><li><a href="#modules">Modules</a></li><li><a href="#operations-on-integer-types">Operations on integer types</a></li><li><a href="#operations-on-real-types">Operations on real types</a></li><li><a href="#operations-on-function-types">Operations on function types</a></li><li><a href="#operations-on-struct-types">Operations on struct types</a></li><li><a href="#operations-on-pointer,-vector,-and-array-types">Operations on pointer, vector, and array types</a></li><li><a href="#operations-on-other-types">Operations on other types</a></li><li><a href="#values">Values</a></li><li><a href="#uses">Uses</a></li><li><a href="#users">Users</a></li><li><a href="#operations-on-constants-of-(mostly)-any-type">Operations on constants of (mostly) any type</a></li><li><a href="#operations-on-instructions">Operations on instructions</a></li><li><a href="#operations-on-metadata">Operations on metadata</a></li><li><a href="#operations-on-scalar-constants">Operations on scalar constants</a></li><li><a href="#operations-on-composite-constants">Operations on composite constants</a></li><li><a href="#constant-expressions">Constant expressions</a></li><li><a href="#operations-on-global-variables,-functions,-and-aliases-(globals)">Operations on global variables, functions, and aliases (globals)</a></li><li><a href="#operations-on-global-variables">Operations on global variables</a></li><li><a href="#operations-on-aliases">Operations on aliases</a></li><li><a href="#operations-on-functions">Operations on functions</a></li><li><a href="#operations-on-params">Operations on params</a></li><li><a href="#operations-on-basic-blocks">Operations on basic blocks</a></li><li><a href="#operations-on-instructions_2">Operations on instructions</a></li><li><a href="#operations-on-call-sites">Operations on call sites</a></li><li><a href="#operations-on-call-and-invoke-instructions-(only)">Operations on call and invoke instructions (only)</a></li><li><a href="#operations-on-load/store-instructions-(only)">Operations on load/store instructions (only)</a></li><li><a href="#operations-on-terminators">Operations on terminators</a></li><li><a href="#operations-on-branches">Operations on branches</a></li><li><a href="#operations-on-phi-nodes">Operations on phi nodes</a></li><li><a href="#instruction-builders">Instruction builders</a></li><li><a href="#metadata">Metadata</a></li><li><a href="#terminators">Terminators</a></li><li><a href="#arithmetic">Arithmetic</a></li><li><a href="#memory">Memory</a></li><li><a href="#casts">Casts</a></li><li><a href="#comparisons">Comparisons</a></li><li><a href="#miscellaneous-instructions">Miscellaneous instructions</a></li><li><a href="#memory-buffers">Memory buffers</a></li><li><a href="#pass-managers">Pass Managers</a></li></ul></nav><div class="odoc-content"><h6 id="abstract-types"><a href="#abstract-types" class="anchor"></a>Abstract types</h6><p>These abstract types correlate directly to the LLVMCore classes.</p><div class="odoc-spec"><div class="spec type" id="type-llcontext" class="anchored"><a href="#type-llcontext" class="anchor"></a><code><span><span class="keyword">type</span> llcontext</span></code></div><div class="spec-doc"><p>The top-level container for all LLVM global data. See the <code>llvm::LLVMContext</code> class.</p></div></div><div class="odoc-spec"><div class="spec type" id="type-llmodule" class="anchored"><a href="#type-llmodule" class="anchor"></a><code><span><span class="keyword">type</span> llmodule</span></code></div><div class="spec-doc"><p>The top-level container for all other LLVM Intermediate Representation (IR) objects. See the <code>llvm::Module</code> class.</p></div></div><div class="odoc-spec"><div class="spec type" id="type-llmetadata" class="anchored"><a href="#type-llmetadata" class="anchor"></a><code><span><span class="keyword">type</span> llmetadata</span></code></div><div class="spec-doc"><p>Opaque representation of Metadata nodes. See the <code>llvm::Metadata</code> class.</p></div></div><div class="odoc-spec"><div class="spec type" id="type-lltype" class="anchored"><a href="#type-lltype" class="anchor"></a><code><span><span class="keyword">type</span> lltype</span></code></div><div class="spec-doc"><p>Each value in the LLVM IR has a type, an instance of <code>lltype</code>. See the <code>llvm::Type</code> class.</p></div></div><div class="odoc-spec"><div class="spec type" id="type-llvalue" class="anchored"><a href="#type-llvalue" class="anchor"></a><code><span><span class="keyword">type</span> llvalue</span></code></div><div class="spec-doc"><p>Any value in the LLVM IR. Functions, instructions, global variables, constants, and much more are all <code>llvalues</code>. See the <code>llvm::Value</code> class. This type covers a wide range of subclasses.</p></div></div><div class="odoc-spec"><div class="spec type" id="type-lluse" class="anchored"><a href="#type-lluse" class="anchor"></a><code><span><span class="keyword">type</span> lluse</span></code></div><div class="spec-doc"><p>Used to store users and usees of values. See the <code>llvm::Use</code> class.</p></div></div><div class="odoc-spec"><div class="spec type" id="type-llbasicblock" class="anchored"><a href="#type-llbasicblock" class="anchor"></a><code><span><span class="keyword">type</span> llbasicblock</span></code></div><div class="spec-doc"><p>A basic block in LLVM IR. See the <code>llvm::BasicBlock</code> class.</p></div></div><div class="odoc-spec"><div class="spec type" id="type-llbuilder" class="anchored"><a href="#type-llbuilder" class="anchor"></a><code><span><span class="keyword">type</span> llbuilder</span></code></div><div class="spec-doc"><p>Used to generate instructions in the LLVM IR. See the <code>llvm::LLVMBuilder</code> class.</p></div></div><div class="odoc-spec"><div class="spec type" id="type-llattrkind" class="anchored"><a href="#type-llattrkind" class="anchor"></a><code><span><span class="keyword">type</span> llattrkind</span></code></div><div class="spec-doc"><p>Used to represent attribute kinds.</p></div></div><div class="odoc-spec"><div class="spec type" id="type-llattribute" class="anchored"><a href="#type-llattribute" class="anchor"></a><code><span><span class="keyword">type</span> llattribute</span></code></div><div class="spec-doc"><p>An attribute in LLVM IR. See the <code>llvm::Attribute</code> class.</p></div></div><div class="odoc-spec"><div class="spec type" id="type-llmemorybuffer" class="anchored"><a href="#type-llmemorybuffer" class="anchor"></a><code><span><span class="keyword">type</span> llmemorybuffer</span></code></div><div class="spec-doc"><p>Used to efficiently handle large buffers of read-only binary data. See the <code>llvm::MemoryBuffer</code> class.</p></div></div><div class="odoc-spec"><div class="spec type" id="type-llmdkind" class="anchored"><a href="#type-llmdkind" class="anchor"></a><code><span><span class="keyword">type</span> llmdkind</span></code></div><div class="spec-doc"><p>The kind id of metadata attached to an instruction.</p></div></div><div class="odoc-spec"><div class="spec module" id="module-TypeKind" class="anchored"><a href="#module-TypeKind" class="anchor"></a><code><span><span class="keyword">module</span> <a href="TypeKind/index.html">TypeKind</a></span><span> : <span class="keyword">sig</span> ... <span class="keyword">end</span></span></code></div><div class="spec-doc"><p>The kind of an <code>lltype</code>, the result of <code>classify_type ty</code>. See the <code>llvm::Type::TypeID</code> enumeration.</p></div></div><div class="odoc-spec"><div class="spec module" id="module-Linkage" class="anchored"><a href="#module-Linkage" class="anchor"></a><code><span><span class="keyword">module</span> <a href="Linkage/index.html">Linkage</a></span><span> : <span class="keyword">sig</span> ... <span class="keyword">end</span></span></code></div><div class="spec-doc"><p>The linkage of a global value, accessed with <a href="#val-linkage"><code>linkage</code></a> and <a href="#val-set_linkage"><code>set_linkage</code></a>. See <code>llvm::GlobalValue::LinkageTypes</code>.</p></div></div><div class="odoc-spec"><div class="spec module" id="module-Visibility" class="anchored"><a href="#module-Visibility" class="anchor"></a><code><span><span class="keyword">module</span> <a href="Visibility/index.html">Visibility</a></span><span> : <span class="keyword">sig</span> ... <span class="keyword">end</span></span></code></div><div class="spec-doc"><p>The linker visibility of a global value, accessed with <a href="#val-visibility"><code>visibility</code></a> and <a href="#val-set_visibility"><code>set_visibility</code></a>. See <code>llvm::GlobalValue::VisibilityTypes</code>.</p></div></div><div class="odoc-spec"><div class="spec module" id="module-DLLStorageClass" class="anchored"><a href="#module-DLLStorageClass" class="anchor"></a><code><span><span class="keyword">module</span> <a href="DLLStorageClass/index.html">DLLStorageClass</a></span><span> : <span class="keyword">sig</span> ... <span class="keyword">end</span></span></code></div><div class="spec-doc"><p>The DLL storage class of a global value, accessed with <a href="#val-dll_storage_class"><code>dll_storage_class</code></a> and <a href="#val-set_dll_storage_class"><code>set_dll_storage_class</code></a>. See <code>llvm::GlobalValue::DLLStorageClassTypes</code>.</p></div></div><div class="odoc-spec"><div class="spec module" id="module-CallConv" class="anchored"><a href="#module-CallConv" class="anchor"></a><code><span><span class="keyword">module</span> <a href="CallConv/index.html">CallConv</a></span><span> : <span class="keyword">sig</span> ... <span class="keyword">end</span></span></code></div><div class="spec-doc"><p>The following calling convention values may be accessed with <a href="#val-function_call_conv"><code>function_call_conv</code></a> and <a href="#val-set_function_call_conv"><code>set_function_call_conv</code></a>. Calling conventions are open-ended.</p></div></div><div class="odoc-spec"><div class="spec module" id="module-AttrRepr" class="anchored"><a href="#module-AttrRepr" class="anchor"></a><code><span><span class="keyword">module</span> <a href="AttrRepr/index.html">AttrRepr</a></span><span> : <span class="keyword">sig</span> ... <span class="keyword">end</span></span></code></div><div class="spec-doc"><p>The logical representation of an attribute.</p></div></div><div class="odoc-spec"><div class="spec module" id="module-AttrIndex" class="anchored"><a href="#module-AttrIndex" class="anchor"></a><code><span><span class="keyword">module</span> <a href="AttrIndex/index.html">AttrIndex</a></span><span> : <span class="keyword">sig</span> ... <span class="keyword">end</span></span></code></div><div class="spec-doc"><p>The position of an attribute. See <code>LLVMAttributeIndex</code>.</p></div></div><div class="odoc-spec"><div class="spec module" id="module-Icmp" class="anchored"><a href="#module-Icmp" class="anchor"></a><code><span><span class="keyword">module</span> <a href="Icmp/index.html">Icmp</a></span><span> : <span class="keyword">sig</span> ... <span class="keyword">end</span></span></code></div><div class="spec-doc"><p>The predicate for an integer comparison (<code>icmp</code>) instruction. See the <code>llvm::ICmpInst::Predicate</code> enumeration.</p></div></div><div class="odoc-spec"><div class="spec module" id="module-Fcmp" class="anchored"><a href="#module-Fcmp" class="anchor"></a><code><span><span class="keyword">module</span> <a href="Fcmp/index.html">Fcmp</a></span><span> : <span class="keyword">sig</span> ... <span class="keyword">end</span></span></code></div><div class="spec-doc"><p>The predicate for a floating-point comparison (<code>fcmp</code>) instruction. Ordered means that neither operand is a QNAN while unordered means that either operand may be a QNAN. See the <code>llvm::FCmpInst::Predicate</code> enumeration.</p></div></div><div class="odoc-spec"><div class="spec module" id="module-Opcode" class="anchored"><a href="#module-Opcode" class="anchor"></a><code><span><span class="keyword">module</span> <a href="Opcode/index.html">Opcode</a></span><span> : <span class="keyword">sig</span> ... <span class="keyword">end</span></span></code></div><div class="spec-doc"><p>The opcodes for LLVM instructions and constant expressions.</p></div></div><div class="odoc-spec"><div class="spec module" id="module-LandingPadClauseTy" class="anchored"><a href="#module-LandingPadClauseTy" class="anchor"></a><code><span><span class="keyword">module</span> <a href="LandingPadClauseTy/index.html">LandingPadClauseTy</a></span><span> : <span class="keyword">sig</span> ... <span class="keyword">end</span></span></code></div><div class="spec-doc"><p>The type of a clause of a <code>landingpad</code> instruction. See <code>llvm::LandingPadInst::ClauseType</code>.</p></div></div><div class="odoc-spec"><div class="spec module" id="module-ThreadLocalMode" class="anchored"><a href="#module-ThreadLocalMode" class="anchor"></a><code><span><span class="keyword">module</span> <a href="ThreadLocalMode/index.html">ThreadLocalMode</a></span><span> : <span class="keyword">sig</span> ... <span class="keyword">end</span></span></code></div><div class="spec-doc"><p>The thread local mode of a global value, accessed with <a href="#val-thread_local_mode"><code>thread_local_mode</code></a> and <a href="#val-set_thread_local_mode"><code>set_thread_local_mode</code></a>. See <code>llvm::GlobalVariable::ThreadLocalMode</code>.</p></div></div><div class="odoc-spec"><div class="spec module" id="module-AtomicOrdering" class="anchored"><a href="#module-AtomicOrdering" class="anchor"></a><code><span><span class="keyword">module</span> <a href="AtomicOrdering/index.html">AtomicOrdering</a></span><span> : <span class="keyword">sig</span> ... <span class="keyword">end</span></span></code></div><div class="spec-doc"><p>The ordering of an atomic <code>load</code>, <code>store</code>, <code>cmpxchg</code>, <code>atomicrmw</code> or <code>fence</code> instruction. See <code>llvm::AtomicOrdering</code>.</p></div></div><div class="odoc-spec"><div class="spec module" id="module-AtomicRMWBinOp" class="anchored"><a href="#module-AtomicRMWBinOp" class="anchor"></a><code><span><span class="keyword">module</span> <a href="AtomicRMWBinOp/index.html">AtomicRMWBinOp</a></span><span> : <span class="keyword">sig</span> ... <span class="keyword">end</span></span></code></div><div class="spec-doc"><p>The opcode of an <code>atomicrmw</code> instruction. See <code>llvm::AtomicRMWInst::BinOp</code>.</p></div></div><div class="odoc-spec"><div class="spec module" id="module-ValueKind" class="anchored"><a href="#module-ValueKind" class="anchor"></a><code><span><span class="keyword">module</span> <a href="ValueKind/index.html">ValueKind</a></span><span> : <span class="keyword">sig</span> ... <span class="keyword">end</span></span></code></div><div class="spec-doc"><p>The kind of an <code>llvalue</code>, the result of <code>classify_value v</code>. See the various <code>LLVMIsA*</code> functions.</p></div></div><div class="odoc-spec"><div class="spec module" id="module-DiagnosticSeverity" class="anchored"><a href="#module-DiagnosticSeverity" class="anchor"></a><code><span><span class="keyword">module</span> <a href="DiagnosticSeverity/index.html">DiagnosticSeverity</a></span><span> : <span class="keyword">sig</span> ... <span class="keyword">end</span></span></code></div><div class="spec-doc"><p>The kind of <code>Diagnostic</code>, the result of <code>Diagnostic.severity d</code>. See <code>llvm::DiagnosticSeverity</code>.</p></div></div><div class="odoc-spec"><div class="spec module" id="module-ModuleFlagBehavior" class="anchored"><a href="#module-ModuleFlagBehavior" class="anchor"></a><code><span><span class="keyword">module</span> <a href="ModuleFlagBehavior/index.html">ModuleFlagBehavior</a></span><span> : <span class="keyword">sig</span> ... <span class="keyword">end</span></span></code></div></div><h6 id="iteration"><a href="#iteration" class="anchor"></a>Iteration</h6><div class="odoc-spec"><div class="spec type" id="type-llpos" class="anchored"><a href="#type-llpos" class="anchor"></a><code><span><span class="keyword">type</span> <span>('a, 'b) llpos</span></span><span> = </span></code><table><tr id="type-llpos.At_end" class="anchored"><td class="def variant constructor"><a href="#type-llpos.At_end" class="anchor"></a><code><span>| </span><span><span class="constructor">At_end</span> <span class="keyword">of</span> <span class="type-var">'a</span></span></code></td></tr><tr id="type-llpos.Before" class="anchored"><td class="def variant constructor"><a href="#type-llpos.Before" class="anchor"></a><code><span>| </span><span><span class="constructor">Before</span> <span class="keyword">of</span> <span class="type-var">'b</span></span></code></td></tr></table></div><div class="spec-doc"><p><code>Before b</code> and <code>At_end a</code> specify positions from the start of the <code>'b</code> list of <code>a</code>. <code>llpos</code> is used to specify positions in and for forward iteration through the various value lists maintained by the LLVM IR.</p></div></div><div class="odoc-spec"><div class="spec type" id="type-llrev_pos" class="anchored"><a href="#type-llrev_pos" class="anchor"></a><code><span><span class="keyword">type</span> <span>('a, 'b) llrev_pos</span></span><span> = </span></code><table><tr id="type-llrev_pos.At_start" class="anchored"><td class="def variant constructor"><a href="#type-llrev_pos.At_start" class="anchor"></a><code><span>| </span><span><span class="constructor">At_start</span> <span class="keyword">of</span> <span class="type-var">'a</span></span></code></td></tr><tr id="type-llrev_pos.After" class="anchored"><td class="def variant constructor"><a href="#type-llrev_pos.After" class="anchor"></a><code><span>| </span><span><span class="constructor">After</span> <span class="keyword">of</span> <span class="type-var">'b</span></span></code></td></tr></table></div><div class="spec-doc"><p><code>After b</code> and <code>At_start a</code> specify positions from the end of the <code>'b</code> list of <code>a</code>. <code>llrev_pos</code> is used for reverse iteration through the various value lists maintained by the LLVM IR.</p></div></div><h6 id="exceptions"><a href="#exceptions" class="anchor"></a>Exceptions</h6><div class="odoc-spec"><div class="spec exception" id="exception-FeatureDisabled" class="anchored"><a href="#exception-FeatureDisabled" class="anchor"></a><code><span><span class="keyword">exception</span> </span><span><span class="exception">FeatureDisabled</span> <span class="keyword">of</span> string</span></code></div></div><div class="odoc-spec"><div class="spec exception" id="exception-IoError" class="anchored"><a href="#exception-IoError" class="anchor"></a><code><span><span class="keyword">exception</span> </span><span><span class="exception">IoError</span> <span class="keyword">of</span> string</span></code></div></div><h6 id="global-configuration"><a href="#global-configuration" class="anchor"></a>Global configuration</h6><div class="odoc-spec"><div class="spec value" id="val-enable_pretty_stacktrace" class="anchored"><a href="#val-enable_pretty_stacktrace" class="anchor"></a><code><span><span class="keyword">val</span> enable_pretty_stacktrace : <span>unit <span class="arrow">&#45;&gt;</span></span> unit</span></code></div><div class="spec-doc"><p><code>enable_pretty_stacktraces ()</code> enables LLVM's built-in stack trace code. This intercepts the OS's crash signals and prints which component of LLVM you were in at the time of the crash.</p></div></div><div class="odoc-spec"><div class="spec value" id="val-install_fatal_error_handler" class="anchored"><a href="#val-install_fatal_error_handler" class="anchor"></a><code><span><span class="keyword">val</span> install_fatal_error_handler : <span><span>( <span>string <span class="arrow">&#45;&gt;</span></span> unit )</span> <span class="arrow">&#45;&gt;</span></span> unit</span></code></div><div class="spec-doc"><p><code>install_fatal_error_handler f</code> installs <code>f</code> as LLVM's fatal error handler. The handler will receive the reason for termination as a string. After the handler has been executed, LLVM calls <code>exit(1)</code>.</p></div></div><div class="odoc-spec"><div class="spec value" id="val-reset_fatal_error_handler" class="anchored"><a href="#val-reset_fatal_error_handler" class="anchor"></a><code><span><span class="keyword">val</span> reset_fatal_error_handler : <span>unit <span class="arrow">&#45;&gt;</span></span> unit</span></code></div><div class="spec-doc"><p><code>reset_fatal_error_handler ()</code> resets LLVM's fatal error handler.</p></div></div><div class="odoc-spec"><div class="spec value" id="val-parse_command_line_options" class="anchored"><a href="#val-parse_command_line_options" class="anchor"></a><code><span><span class="keyword">val</span> parse_command_line_options : <span>?overview:string <span class="arrow">&#45;&gt;</span></span> <span><span>string array</span> <span class="arrow">&#45;&gt;</span></span> unit</span></code></div><div class="spec-doc"><p><code>parse_command_line_options ?overview args</code> parses <code>args</code> using the LLVM command line parser. Note that the only stable thing about this function is its signature; you cannot rely on any particular set of command line arguments being interpreted the same way across LLVM versions.</p><p>See the function <code>llvm::cl::ParseCommandLineOptions()</code>.</p></div></div><h6 id="context-error-handling"><a href="#context-error-handling" class="anchor"></a>Context error handling</h6><div class="odoc-spec"><div class="spec module" id="module-Diagnostic" class="anchored"><a href="#module-Diagnostic" class="anchor"></a><code><span><span class="keyword">module</span> <a href="Diagnostic/index.html">Diagnostic</a></span><span> : <span class="keyword">sig</span> ... <span class="keyword">end</span></span></code></div></div><div class="odoc-spec"><div class="spec value" id="val-set_diagnostic_handler" class="anchored"><a href="#val-set_diagnostic_handler" class="anchor"></a><code><span><span class="keyword">val</span> set_diagnostic_handler : 
  <span><a href="#type-llcontext">llcontext</a> <span class="arrow">&#45;&gt;</span></span>
  <span><span><span>( <span><a href="Diagnostic/index.html#type-t">Diagnostic.t</a> <span class="arrow">&#45;&gt;</span></span> unit )</span> option</span> <span class="arrow">&#45;&gt;</span></span>
  unit</span></code></div><div class="spec-doc"><p><code>set_diagnostic_handler c h</code> set the diagnostic handler of <code>c</code> to <code>h</code>. See the method <code>llvm::LLVMContext::setDiagnosticHandler</code>.</p></div></div><h6 id="contexts"><a href="#contexts" class="anchor"></a>Contexts</h6><div class="odoc-spec"><div class="spec value" id="val-create_context" class="anchored"><a href="#val-create_context" class="anchor"></a><code><span><span class="keyword">val</span> create_context : <span>unit <span class="arrow">&#45;&gt;</span></span> <a href="#type-llcontext">llcontext</a></span></code></div><div class="spec-doc"><p><code>create_context ()</code> creates a context for storing the &quot;global&quot; state in LLVM. See the constructor <code>llvm::LLVMContext</code>.</p></div></div><div class="odoc-spec"><div class="spec value" id="val-dispose_context" class="anchored"><a href="#val-dispose_context" class="anchor"></a><code><span><span class="keyword">val</span> dispose_context : <span><a href="#type-llcontext">llcontext</a> <span class="arrow">&#45;&gt;</span></span> unit</span></code></div><div class="spec-doc"><p><code>destroy_context ()</code> destroys a context. See the destructor <code>llvm::LLVMContext::~LLVMContext</code>.</p></div></div><div class="odoc-spec"><div class="spec value" id="val-global_context" class="anchored"><a href="#val-global_context" class="anchor"></a><code><span><span class="keyword">val</span> global_context : <span>unit <span class="arrow">&#45;&gt;</span></span> <a href="#type-llcontext">llcontext</a></span></code></div><div class="spec-doc"><p>See the function <code>LLVMGetGlobalContext</code>.</p></div></div><div class="odoc-spec"><div class="spec value" id="val-mdkind_id" class="anchored"><a href="#val-mdkind_id" class="anchor"></a><code><span><span class="keyword">val</span> mdkind_id : <span><a href="#type-llcontext">llcontext</a> <span class="arrow">&#45;&gt;</span></span> <span>string <span class="arrow">&#45;&gt;</span></span> <a href="#type-llmdkind">llmdkind</a></span></code></div><div class="spec-doc"><p><code>mdkind_id context name</code> returns the MDKind ID that corresponds to the name <code>name</code> in the context <code>context</code>. See the function <code>llvm::LLVMContext::getMDKindID</code>.</p></div></div><h6 id="attributes"><a href="#attributes" class="anchor"></a>Attributes</h6><div class="odoc-spec"><div class="spec exception" id="exception-UnknownAttribute" class="anchored"><a href="#exception-UnknownAttribute" class="anchor"></a><code><span><span class="keyword">exception</span> </span><span><span class="exception">UnknownAttribute</span> <span class="keyword">of</span> string</span></code></div><div class="spec-doc"><p><code>UnknownAttribute attr</code> is raised when a enum attribute name <code>name</code> is not recognized by LLVM.</p></div></div><div class="odoc-spec"><div class="spec value" id="val-enum_attr_kind" class="anchored"><a href="#val-enum_attr_kind" class="anchor"></a><code><span><span class="keyword">val</span> enum_attr_kind : <span>string <span class="arrow">&#45;&gt;</span></span> <a href="#type-llattrkind">llattrkind</a></span></code></div><div class="spec-doc"><p><code>enum_attr_kind name</code> returns the kind of enum attributes named <code>name</code>. May raise <code>UnknownAttribute</code>.</p></div></div><div class="odoc-spec"><div class="spec value" id="val-create_enum_attr" class="anchored"><a href="#val-create_enum_attr" class="anchor"></a><code><span><span class="keyword">val</span> create_enum_attr : <span><a href="#type-llcontext">llcontext</a> <span class="arrow">&#45;&gt;</span></span> <span>string <span class="arrow">&#45;&gt;</span></span> <span>int64 <span class="arrow">&#45;&gt;</span></span> <a href="#type-llattribute">llattribute</a></span></code></div><div class="spec-doc"><p><code>create_enum_attr context value kind</code> creates an enum attribute with the supplied <code>kind</code> and <code>value</code> in <code>context</code>; if the value is not required (as for the majority of attributes), use <code>0L</code>. May raise <code>UnknownAttribute</code>. See the constructor <code>llvm::Attribute::get</code>.</p></div></div><div class="odoc-spec"><div class="spec value" id="val-create_string_attr" class="anchored"><a href="#val-create_string_attr" class="anchor"></a><code><span><span class="keyword">val</span> create_string_attr : <span><a href="#type-llcontext">llcontext</a> <span class="arrow">&#45;&gt;</span></span> <span>string <span class="arrow">&#45;&gt;</span></span> <span>string <span class="arrow">&#45;&gt;</span></span> <a href="#type-llattribute">llattribute</a></span></code></div><div class="spec-doc"><p><code>create_string_attr context kind value</code> creates a string attribute with the supplied <code>kind</code> and <code>value</code> in <code>context</code>. See the constructor <code>llvm::Attribute::get</code>.</p></div></div><div class="odoc-spec"><div class="spec value" id="val-attr_of_repr" class="anchored"><a href="#val-attr_of_repr" class="anchor"></a><code><span><span class="keyword">val</span> attr_of_repr : <span><a href="#type-llcontext">llcontext</a> <span class="arrow">&#45;&gt;</span></span> <span><a href="AttrRepr/index.html#type-t">AttrRepr.t</a> <span class="arrow">&#45;&gt;</span></span> <a href="#type-llattribute">llattribute</a></span></code></div><div class="spec-doc"><p><code>attr_of_repr context repr</code> creates an attribute with the supplied representation <code>repr</code> in <code>context</code>.</p></div></div><div class="odoc-spec"><div class="spec value" id="val-repr_of_attr" class="anchored"><a href="#val-repr_of_attr" class="anchor"></a><code><span><span class="keyword">val</span> repr_of_attr : <span><a href="#type-llattribute">llattribute</a> <span class="arrow">&#45;&gt;</span></span> <a href="AttrRepr/index.html#type-t">AttrRepr.t</a></span></code></div><div class="spec-doc"><p><code>repr_of_attr attr</code> describes the representation of attribute <code>attr</code>.</p></div></div><h6 id="modules"><a href="#modules" class="anchor"></a>Modules</h6><div class="odoc-spec"><div class="spec value" id="val-create_module" class="anchored"><a href="#val-create_module" class="anchor"></a><code><span><span class="keyword">val</span> create_module : <span><a href="#type-llcontext">llcontext</a> <span class="arrow">&#45;&gt;</span></span> <span>string <span class="arrow">&#45;&gt;</span></span> <a href="#type-llmodule">llmodule</a></span></code></div><div class="spec-doc"><p><code>create_module context id</code> creates a module with the supplied module ID in the context <code>context</code>. Modules are not garbage collected; it is mandatory to call <a href="#val-dispose_module"><code>dispose_module</code></a> to free memory. See the constructor <code>llvm::Module::Module</code>.</p></div></div><div class="odoc-spec"><div class="spec value" id="val-dispose_module" class="anchored"><a href="#val-dispose_module" class="anchor"></a><code><span><span class="keyword">val</span> dispose_module : <span><a href="#type-llmodule">llmodule</a> <span class="arrow">&#45;&gt;</span></span> unit</span></code></div><div class="spec-doc"><p><code>dispose_module m</code> destroys a module <code>m</code> and all of the IR objects it contained. All references to subordinate objects are invalidated; referencing them will invoke undefined behavior. See the destructor <code>llvm::Module::~Module</code>.</p></div></div><div class="odoc-spec"><div class="spec value" id="val-target_triple" class="anchored"><a href="#val-target_triple" class="anchor"></a><code><span><span class="keyword">val</span> target_triple : <span><a href="#type-llmodule">llmodule</a> <span class="arrow">&#45;&gt;</span></span> string</span></code></div><div class="spec-doc"><p><code>target_triple m</code> is the target specifier for the module <code>m</code>, something like <code>i686-apple-darwin8</code>. See the method <code>llvm::Module::getTargetTriple</code>.</p></div></div><div class="odoc-spec"><div class="spec value" id="val-set_target_triple" class="anchored"><a href="#val-set_target_triple" class="anchor"></a><code><span><span class="keyword">val</span> set_target_triple : <span>string <span class="arrow">&#45;&gt;</span></span> <span><a href="#type-llmodule">llmodule</a> <span class="arrow">&#45;&gt;</span></span> unit</span></code></div><div class="spec-doc"><p><code>target_triple triple m</code> changes the target specifier for the module <code>m</code> to the string <code>triple</code>. See the method <code>llvm::Module::setTargetTriple</code>.</p></div></div><div class="odoc-spec"><div class="spec value" id="val-data_layout" class="anchored"><a href="#val-data_layout" class="anchor"></a><code><span><span class="keyword">val</span> data_layout : <span><a href="#type-llmodule">llmodule</a> <span class="arrow">&#45;&gt;</span></span> string</span></code></div><div class="spec-doc"><p><code>data_layout m</code> is the data layout specifier for the module <code>m</code>, something like <code>e-p:32:32:32-i1:8:8-i8:8:8-i16:16:16-...-a0:0:64-f80:128:128</code>. See the method <code>llvm::Module::getDataLayout</code>.</p></div></div><div class="odoc-spec"><div class="spec value" id="val-set_data_layout" class="anchored"><a href="#val-set_data_layout" class="anchor"></a><code><span><span class="keyword">val</span> set_data_layout : <span>string <span class="arrow">&#45;&gt;</span></span> <span><a href="#type-llmodule">llmodule</a> <span class="arrow">&#45;&gt;</span></span> unit</span></code></div><div class="spec-doc"><p><code>set_data_layout s m</code> changes the data layout specifier for the module <code>m</code> to the string <code>s</code>. See the method <code>llvm::Module::setDataLayout</code>.</p></div></div><div class="odoc-spec"><div class="spec value" id="val-dump_module" class="anchored"><a href="#val-dump_module" class="anchor"></a><code><span><span class="keyword">val</span> dump_module : <span><a href="#type-llmodule">llmodule</a> <span class="arrow">&#45;&gt;</span></span> unit</span></code></div><div class="spec-doc"><p><code>dump_module m</code> prints the .ll representation of the module <code>m</code> to standard error. See the method <code>llvm::Module::dump</code>.</p></div></div><div class="odoc-spec"><div class="spec value" id="val-print_module" class="anchored"><a href="#val-print_module" class="anchor"></a><code><span><span class="keyword">val</span> print_module : <span>string <span class="arrow">&#45;&gt;</span></span> <span><a href="#type-llmodule">llmodule</a> <span class="arrow">&#45;&gt;</span></span> unit</span></code></div><div class="spec-doc"><p><code>print_module f m</code> prints the .ll representation of the module <code>m</code> to file <code>f</code>. See the method <code>llvm::Module::print</code>.</p></div></div><div class="odoc-spec"><div class="spec value" id="val-string_of_llmodule" class="anchored"><a href="#val-string_of_llmodule" class="anchor"></a><code><span><span class="keyword">val</span> string_of_llmodule : <span><a href="#type-llmodule">llmodule</a> <span class="arrow">&#45;&gt;</span></span> string</span></code></div><div class="spec-doc"><p><code>string_of_llmodule m</code> returns the .ll representation of the module <code>m</code> as a string. See the method <code>llvm::Module::print</code>.</p></div></div><div class="odoc-spec"><div class="spec value" id="val-set_module_inline_asm" class="anchored"><a href="#val-set_module_inline_asm" class="anchor"></a><code><span><span class="keyword">val</span> set_module_inline_asm : <span><a href="#type-llmodule">llmodule</a> <span class="arrow">&#45;&gt;</span></span> <span>string <span class="arrow">&#45;&gt;</span></span> unit</span></code></div><div class="spec-doc"><p><code>set_module_inline_asm m asm</code> sets the inline assembler for the module. See the method <code>llvm::Module::setModuleInlineAsm</code>.</p></div></div><div class="odoc-spec"><div class="spec value" id="val-module_context" class="anchored"><a href="#val-module_context" class="anchor"></a><code><span><span class="keyword">val</span> module_context : <span><a href="#type-llmodule">llmodule</a> <span class="arrow">&#45;&gt;</span></span> <a href="#type-llcontext">llcontext</a></span></code></div><div class="spec-doc"><p><code>module_context m</code> returns the context of the specified module. See the method <code>llvm::Module::getContext</code></p></div></div><div class="odoc-spec"><div class="spec value" id="val-get_module_identifier" class="anchored"><a href="#val-get_module_identifier" class="anchor"></a><code><span><span class="keyword">val</span> get_module_identifier : <span><a href="#type-llmodule">llmodule</a> <span class="arrow">&#45;&gt;</span></span> string</span></code></div><div class="spec-doc"><p><code>get_module_identifier m</code> returns the module identifier of the specified module. See the method <code>llvm::Module::getModuleIdentifier</code></p></div></div><div class="odoc-spec"><div class="spec value" id="val-set_module_identifer" class="anchored"><a href="#val-set_module_identifer" class="anchor"></a><code><span><span class="keyword">val</span> set_module_identifer : <span><a href="#type-llmodule">llmodule</a> <span class="arrow">&#45;&gt;</span></span> <span>string <span class="arrow">&#45;&gt;</span></span> unit</span></code></div><div class="spec-doc"><p><code>set_module_identifier m id</code> sets the module identifier of <code>m</code> to <code>id</code>. See the method <code>llvm::Module::setModuleIdentifier</code></p></div></div><div class="odoc-spec"><div class="spec value" id="val-get_module_flag" class="anchored"><a href="#val-get_module_flag" class="anchor"></a><code><span><span class="keyword">val</span> get_module_flag : <span><a href="#type-llmodule">llmodule</a> <span class="arrow">&#45;&gt;</span></span> <span>string <span class="arrow">&#45;&gt;</span></span> <span><a href="#type-llmetadata">llmetadata</a> option</span></span></code></div><div class="spec-doc"><p><code>get_module_flag m k</code> Return the corresponding value if key <code>k</code> appears in the module flags of <code>m</code>, otherwise return None See the method <code>llvm::Module::getModuleFlag</code></p></div></div><div class="odoc-spec"><div class="spec value" id="val-add_module_flag" class="anchored"><a href="#val-add_module_flag" class="anchor"></a><code><span><span class="keyword">val</span> add_module_flag : 
  <span><a href="#type-llmodule">llmodule</a> <span class="arrow">&#45;&gt;</span></span>
  <span><a href="ModuleFlagBehavior/index.html#type-t">ModuleFlagBehavior.t</a> <span class="arrow">&#45;&gt;</span></span>
  <span>string <span class="arrow">&#45;&gt;</span></span>
  <span><a href="#type-llmetadata">llmetadata</a> <span class="arrow">&#45;&gt;</span></span>
  unit</span></code></div><div class="spec-doc"><p><code>add_module_flag m b k v</code> Add a module-level flag b, with key <code>k</code> and value <code>v</code> to the flags metadata of module <code>m</code>. It will create the module-level flags named metadata if it doesn't already exist.</p><p>Types</p></div></div><div class="odoc-spec"><div class="spec value" id="val-classify_type" class="anchored"><a href="#val-classify_type" class="anchor"></a><code><span><span class="keyword">val</span> classify_type : <span><a href="#type-lltype">lltype</a> <span class="arrow">&#45;&gt;</span></span> <a href="TypeKind/index.html#type-t">TypeKind.t</a></span></code></div><div class="spec-doc"><p><code>classify_type ty</code> returns the <a href="TypeKind/index.html#type-t"><code>TypeKind.t</code></a> corresponding to the type <code>ty</code>. See the method <code>llvm::Type::getTypeID</code>.</p></div></div><div class="odoc-spec"><div class="spec value" id="val-type_is_sized" class="anchored"><a href="#val-type_is_sized" class="anchor"></a><code><span><span class="keyword">val</span> type_is_sized : <span><a href="#type-lltype">lltype</a> <span class="arrow">&#45;&gt;</span></span> bool</span></code></div><div class="spec-doc"><p><code>type_is_sized ty</code> returns whether the type has a size or not. If it doesn't then it is not safe to call the <code>DataLayout::</code> methods on it.</p></div></div><div class="odoc-spec"><div class="spec value" id="val-type_context" class="anchored"><a href="#val-type_context" class="anchor"></a><code><span><span class="keyword">val</span> type_context : <span><a href="#type-lltype">lltype</a> <span class="arrow">&#45;&gt;</span></span> <a href="#type-llcontext">llcontext</a></span></code></div><div class="spec-doc"><p><code>type_context ty</code> returns the <a href="#type-llcontext"><code>llcontext</code></a> corresponding to the type <code>ty</code>. See the method <code>llvm::Type::getContext</code>.</p></div></div><div class="odoc-spec"><div class="spec value" id="val-dump_type" class="anchored"><a href="#val-dump_type" class="anchor"></a><code><span><span class="keyword">val</span> dump_type : <span><a href="#type-lltype">lltype</a> <span class="arrow">&#45;&gt;</span></span> unit</span></code></div><div class="spec-doc"><p><code>dump_type ty</code> prints the .ll representation of the type <code>ty</code> to standard error. See the method <code>llvm::Type::dump</code>.</p></div></div><div class="odoc-spec"><div class="spec value" id="val-string_of_lltype" class="anchored"><a href="#val-string_of_lltype" class="anchor"></a><code><span><span class="keyword">val</span> string_of_lltype : <span><a href="#type-lltype">lltype</a> <span class="arrow">&#45;&gt;</span></span> string</span></code></div><div class="spec-doc"><p><code>string_of_lltype ty</code> returns a string describing the type <code>ty</code>.</p></div></div><h6 id="operations-on-integer-types"><a href="#operations-on-integer-types" class="anchor"></a>Operations on integer types</h6><div class="odoc-spec"><div class="spec value" id="val-i1_type" class="anchored"><a href="#val-i1_type" class="anchor"></a><code><span><span class="keyword">val</span> i1_type : <span><a href="#type-llcontext">llcontext</a> <span class="arrow">&#45;&gt;</span></span> <a href="#type-lltype">lltype</a></span></code></div><div class="spec-doc"><p><code>i1_type c</code> returns an integer type of bitwidth 1 in the context <code>c</code>. See <code>llvm::Type::Int1Ty</code>.</p></div></div><div class="odoc-spec"><div class="spec value" id="val-i8_type" class="anchored"><a href="#val-i8_type" class="anchor"></a><code><span><span class="keyword">val</span> i8_type : <span><a href="#type-llcontext">llcontext</a> <span class="arrow">&#45;&gt;</span></span> <a href="#type-lltype">lltype</a></span></code></div><div class="spec-doc"><p><code>i8_type c</code> returns an integer type of bitwidth 8 in the context <code>c</code>. See <code>llvm::Type::Int8Ty</code>.</p></div></div><div class="odoc-spec"><div class="spec value" id="val-i16_type" class="anchored"><a href="#val-i16_type" class="anchor"></a><code><span><span class="keyword">val</span> i16_type : <span><a href="#type-llcontext">llcontext</a> <span class="arrow">&#45;&gt;</span></span> <a href="#type-lltype">lltype</a></span></code></div><div class="spec-doc"><p><code>i16_type c</code> returns an integer type of bitwidth 16 in the context <code>c</code>. See <code>llvm::Type::Int16Ty</code>.</p></div></div><div class="odoc-spec"><div class="spec value" id="val-i32_type" class="anchored"><a href="#val-i32_type" class="anchor"></a><code><span><span class="keyword">val</span> i32_type : <span><a href="#type-llcontext">llcontext</a> <span class="arrow">&#45;&gt;</span></span> <a href="#type-lltype">lltype</a></span></code></div><div class="spec-doc"><p><code>i32_type c</code> returns an integer type of bitwidth 32 in the context <code>c</code>. See <code>llvm::Type::Int32Ty</code>.</p></div></div><div class="odoc-spec"><div class="spec value" id="val-i64_type" class="anchored"><a href="#val-i64_type" class="anchor"></a><code><span><span class="keyword">val</span> i64_type : <span><a href="#type-llcontext">llcontext</a> <span class="arrow">&#45;&gt;</span></span> <a href="#type-lltype">lltype</a></span></code></div><div class="spec-doc"><p><code>i64_type c</code> returns an integer type of bitwidth 64 in the context <code>c</code>. See <code>llvm::Type::Int64Ty</code>.</p></div></div><div class="odoc-spec"><div class="spec value" id="val-integer_type" class="anchored"><a href="#val-integer_type" class="anchor"></a><code><span><span class="keyword">val</span> integer_type : <span><a href="#type-llcontext">llcontext</a> <span class="arrow">&#45;&gt;</span></span> <span>int <span class="arrow">&#45;&gt;</span></span> <a href="#type-lltype">lltype</a></span></code></div><div class="spec-doc"><p><code>integer_type c n</code> returns an integer type of bitwidth <code>n</code> in the context <code>c</code>. See the method <code>llvm::IntegerType::get</code>.</p></div></div><div class="odoc-spec"><div class="spec value" id="val-integer_bitwidth" class="anchored"><a href="#val-integer_bitwidth" class="anchor"></a><code><span><span class="keyword">val</span> integer_bitwidth : <span><a href="#type-lltype">lltype</a> <span class="arrow">&#45;&gt;</span></span> int</span></code></div><div class="spec-doc"><p><code>integer_bitwidth c ty</code> returns the number of bits in the integer type <code>ty</code> in the context <code>c</code>. See the method <code>llvm::IntegerType::getBitWidth</code>.</p></div></div><h6 id="operations-on-real-types"><a href="#operations-on-real-types" class="anchor"></a>Operations on real types</h6><div class="odoc-spec"><div class="spec value" id="val-float_type" class="anchored"><a href="#val-float_type" class="anchor"></a><code><span><span class="keyword">val</span> float_type : <span><a href="#type-llcontext">llcontext</a> <span class="arrow">&#45;&gt;</span></span> <a href="#type-lltype">lltype</a></span></code></div><div class="spec-doc"><p><code>float_type c</code> returns the IEEE 32-bit floating point type in the context <code>c</code>. See <code>llvm::Type::FloatTy</code>.</p></div></div><div class="odoc-spec"><div class="spec value" id="val-double_type" class="anchored"><a href="#val-double_type" class="anchor"></a><code><span><span class="keyword">val</span> double_type : <span><a href="#type-llcontext">llcontext</a> <span class="arrow">&#45;&gt;</span></span> <a href="#type-lltype">lltype</a></span></code></div><div class="spec-doc"><p><code>double_type c</code> returns the IEEE 64-bit floating point type in the context <code>c</code>. See <code>llvm::Type::DoubleTy</code>.</p></div></div><div class="odoc-spec"><div class="spec value" id="val-x86fp80_type" class="anchored"><a href="#val-x86fp80_type" class="anchor"></a><code><span><span class="keyword">val</span> x86fp80_type : <span><a href="#type-llcontext">llcontext</a> <span class="arrow">&#45;&gt;</span></span> <a href="#type-lltype">lltype</a></span></code></div><div class="spec-doc"><p><code>x86fp80_type c</code> returns the x87 80-bit floating point type in the context <code>c</code>. See <code>llvm::Type::X86_FP80Ty</code>.</p></div></div><div class="odoc-spec"><div class="spec value" id="val-fp128_type" class="anchored"><a href="#val-fp128_type" class="anchor"></a><code><span><span class="keyword">val</span> fp128_type : <span><a href="#type-llcontext">llcontext</a> <span class="arrow">&#45;&gt;</span></span> <a href="#type-lltype">lltype</a></span></code></div><div class="spec-doc"><p><code>fp128_type c</code> returns the IEEE 128-bit floating point type in the context <code>c</code>. See <code>llvm::Type::FP128Ty</code>.</p></div></div><div class="odoc-spec"><div class="spec value" id="val-ppc_fp128_type" class="anchored"><a href="#val-ppc_fp128_type" class="anchor"></a><code><span><span class="keyword">val</span> ppc_fp128_type : <span><a href="#type-llcontext">llcontext</a> <span class="arrow">&#45;&gt;</span></span> <a href="#type-lltype">lltype</a></span></code></div><div class="spec-doc"><p><code>ppc_fp128_type c</code> returns the PowerPC 128-bit floating point type in the context <code>c</code>. See <code>llvm::Type::PPC_FP128Ty</code>.</p></div></div><h6 id="operations-on-function-types"><a href="#operations-on-function-types" class="anchor"></a>Operations on function types</h6><div class="odoc-spec"><div class="spec value" id="val-function_type" class="anchored"><a href="#val-function_type" class="anchor"></a><code><span><span class="keyword">val</span> function_type : <span><a href="#type-lltype">lltype</a> <span class="arrow">&#45;&gt;</span></span> <span><span><a href="#type-lltype">lltype</a> array</span> <span class="arrow">&#45;&gt;</span></span> <a href="#type-lltype">lltype</a></span></code></div><div class="spec-doc"><p><code>function_type ret_ty param_tys</code> returns the function type returning <code>ret_ty</code> and taking <code>param_tys</code> as parameters. See the method <code>llvm::FunctionType::get</code>.</p></div></div><div class="odoc-spec"><div class="spec value" id="val-var_arg_function_type" class="anchored"><a href="#val-var_arg_function_type" class="anchor"></a><code><span><span class="keyword">val</span> var_arg_function_type : <span><a href="#type-lltype">lltype</a> <span class="arrow">&#45;&gt;</span></span> <span><span><a href="#type-lltype">lltype</a> array</span> <span class="arrow">&#45;&gt;</span></span> <a href="#type-lltype">lltype</a></span></code></div><div class="spec-doc"><p><code>var_arg_function_type ret_ty param_tys</code> is just like <code>function_type ret_ty param_tys</code> except that it returns the function type which also takes a variable number of arguments. See the method <code>llvm::FunctionType::get</code>.</p></div></div><div class="odoc-spec"><div class="spec value" id="val-is_var_arg" class="anchored"><a href="#val-is_var_arg" class="anchor"></a><code><span><span class="keyword">val</span> is_var_arg : <span><a href="#type-lltype">lltype</a> <span class="arrow">&#45;&gt;</span></span> bool</span></code></div><div class="spec-doc"><p><code>is_var_arg fty</code> returns <code>true</code> if <code>fty</code> is a varargs function type, <code>false</code> otherwise. See the method <code>llvm::FunctionType::isVarArg</code>.</p></div></div><div class="odoc-spec"><div class="spec value" id="val-return_type" class="anchored"><a href="#val-return_type" class="anchor"></a><code><span><span class="keyword">val</span> return_type : <span><a href="#type-lltype">lltype</a> <span class="arrow">&#45;&gt;</span></span> <a href="#type-lltype">lltype</a></span></code></div><div class="spec-doc"><p><code>return_type fty</code> gets the return type of the function type <code>fty</code>. See the method <code>llvm::FunctionType::getReturnType</code>.</p></div></div><div class="odoc-spec"><div class="spec value" id="val-param_types" class="anchored"><a href="#val-param_types" class="anchor"></a><code><span><span class="keyword">val</span> param_types : <span><a href="#type-lltype">lltype</a> <span class="arrow">&#45;&gt;</span></span> <span><a href="#type-lltype">lltype</a> array</span></span></code></div><div class="spec-doc"><p><code>param_types fty</code> gets the parameter types of the function type <code>fty</code>. See the method <code>llvm::FunctionType::getParamType</code>.</p></div></div><h6 id="operations-on-struct-types"><a href="#operations-on-struct-types" class="anchor"></a>Operations on struct types</h6><div class="odoc-spec"><div class="spec value" id="val-struct_type" class="anchored"><a href="#val-struct_type" class="anchor"></a><code><span><span class="keyword">val</span> struct_type : <span><a href="#type-llcontext">llcontext</a> <span class="arrow">&#45;&gt;</span></span> <span><span><a href="#type-lltype">lltype</a> array</span> <span class="arrow">&#45;&gt;</span></span> <a href="#type-lltype">lltype</a></span></code></div><div class="spec-doc"><p><code>struct_type context tys</code> returns the structure type in the context <code>context</code> containing in the types in the array <code>tys</code>. See the method <code>llvm::StructType::get</code>.</p></div></div><div class="odoc-spec"><div class="spec value" id="val-packed_struct_type" class="anchored"><a href="#val-packed_struct_type" class="anchor"></a><code><span><span class="keyword">val</span> packed_struct_type : <span><a href="#type-llcontext">llcontext</a> <span class="arrow">&#45;&gt;</span></span> <span><span><a href="#type-lltype">lltype</a> array</span> <span class="arrow">&#45;&gt;</span></span> <a href="#type-lltype">lltype</a></span></code></div><div class="spec-doc"><p><code>packed_struct_type context ys</code> returns the packed structure type in the context <code>context</code> containing in the types in the array <code>tys</code>. See the method <code>llvm::StructType::get</code>.</p></div></div><div class="odoc-spec"><div class="spec value" id="val-struct_name" class="anchored"><a href="#val-struct_name" class="anchor"></a><code><span><span class="keyword">val</span> struct_name : <span><a href="#type-lltype">lltype</a> <span class="arrow">&#45;&gt;</span></span> <span>string option</span></span></code></div><div class="spec-doc"><p><code>struct_name ty</code> returns the name of the named structure type <code>ty</code>, or None if the structure type is not named</p></div></div><div class="odoc-spec"><div class="spec value" id="val-named_struct_type" class="anchored"><a href="#val-named_struct_type" class="anchor"></a><code><span><span class="keyword">val</span> named_struct_type : <span><a href="#type-llcontext">llcontext</a> <span class="arrow">&#45;&gt;</span></span> <span>string <span class="arrow">&#45;&gt;</span></span> <a href="#type-lltype">lltype</a></span></code></div><div class="spec-doc"><p><code>named_struct_type context name</code> returns the named structure type <code>name</code> in the context <code>context</code>. See the method <code>llvm::StructType::get</code>.</p></div></div><div class="odoc-spec"><div class="spec value" id="val-struct_set_body" class="anchored"><a href="#val-struct_set_body" class="anchor"></a><code><span><span class="keyword">val</span> struct_set_body : <span><a href="#type-lltype">lltype</a> <span class="arrow">&#45;&gt;</span></span> <span><span><a href="#type-lltype">lltype</a> array</span> <span class="arrow">&#45;&gt;</span></span> <span>bool <span class="arrow">&#45;&gt;</span></span> unit</span></code></div><div class="spec-doc"><p><code>struct_set_body ty elts ispacked</code> sets the body of the named struct <code>ty</code> to the <code>elts</code> elements. See the moethd <code>llvm::StructType::setBody</code>.</p></div></div><div class="odoc-spec"><div class="spec value" id="val-struct_element_types" class="anchored"><a href="#val-struct_element_types" class="anchor"></a><code><span><span class="keyword">val</span> struct_element_types : <span><a href="#type-lltype">lltype</a> <span class="arrow">&#45;&gt;</span></span> <span><a href="#type-lltype">lltype</a> array</span></span></code></div><div class="spec-doc"><p><code>struct_element_types sty</code> returns the constituent types of the struct type <code>sty</code>. See the method <code>llvm::StructType::getElementType</code>.</p></div></div><div class="odoc-spec"><div class="spec value" id="val-is_packed" class="anchored"><a href="#val-is_packed" class="anchor"></a><code><span><span class="keyword">val</span> is_packed : <span><a href="#type-lltype">lltype</a> <span class="arrow">&#45;&gt;</span></span> bool</span></code></div><div class="spec-doc"><p><code>is_packed sty</code> returns <code>true</code> if the structure type <code>sty</code> is packed, <code>false</code> otherwise. See the method <code>llvm::StructType::isPacked</code>.</p></div></div><div class="odoc-spec"><div class="spec value" id="val-is_opaque" class="anchored"><a href="#val-is_opaque" class="anchor"></a><code><span><span class="keyword">val</span> is_opaque : <span><a href="#type-lltype">lltype</a> <span class="arrow">&#45;&gt;</span></span> bool</span></code></div><div class="spec-doc"><p><code>is_opaque sty</code> returns <code>true</code> if the structure type <code>sty</code> is opaque. <code>false</code> otherwise. See the method <code>llvm::StructType::isOpaque</code>.</p></div></div><div class="odoc-spec"><div class="spec value" id="val-is_literal" class="anchored"><a href="#val-is_literal" class="anchor"></a><code><span><span class="keyword">val</span> is_literal : <span><a href="#type-lltype">lltype</a> <span class="arrow">&#45;&gt;</span></span> bool</span></code></div><div class="spec-doc"><p><code>is_literal sty</code> returns <code>true</code> if the structure type <code>sty</code> is literal. <code>false</code> otherwise. See the method <code>llvm::StructType::isLiteral</code>.</p></div></div><h6 id="operations-on-pointer,-vector,-and-array-types"><a href="#operations-on-pointer,-vector,-and-array-types" class="anchor"></a>Operations on pointer, vector, and array types</h6><div class="odoc-spec"><div class="spec value" id="val-subtypes" class="anchored"><a href="#val-subtypes" class="anchor"></a><code><span><span class="keyword">val</span> subtypes : <span><a href="#type-lltype">lltype</a> <span class="arrow">&#45;&gt;</span></span> <span><a href="#type-lltype">lltype</a> array</span></span></code></div><div class="spec-doc"><p><code>subtypes ty</code> returns <code>ty</code>'s subtypes</p></div></div><div class="odoc-spec"><div class="spec value" id="val-array_type" class="anchored"><a href="#val-array_type" class="anchor"></a><code><span><span class="keyword">val</span> array_type : <span><a href="#type-lltype">lltype</a> <span class="arrow">&#45;&gt;</span></span> <span>int <span class="arrow">&#45;&gt;</span></span> <a href="#type-lltype">lltype</a></span></code></div><div class="spec-doc"><p><code>array_type ty n</code> returns the array type containing <code>n</code> elements of type <code>ty</code>. See the method <code>llvm::ArrayType::get</code>.</p></div></div><div class="odoc-spec"><div class="spec value" id="val-pointer_type" class="anchored"><a href="#val-pointer_type" class="anchor"></a><code><span><span class="keyword">val</span> pointer_type : <span><a href="#type-lltype">lltype</a> <span class="arrow">&#45;&gt;</span></span> <a href="#type-lltype">lltype</a></span></code></div><div class="spec-doc"><p><code>pointer_type ty</code> returns the pointer type referencing objects of type <code>ty</code> in the default address space (0). See the method <code>llvm::PointerType::getUnqual</code>.</p></div></div><div class="odoc-spec"><div class="spec value" id="val-qualified_pointer_type" class="anchored"><a href="#val-qualified_pointer_type" class="anchor"></a><code><span><span class="keyword">val</span> qualified_pointer_type : <span><a href="#type-lltype">lltype</a> <span class="arrow">&#45;&gt;</span></span> <span>int <span class="arrow">&#45;&gt;</span></span> <a href="#type-lltype">lltype</a></span></code></div><div class="spec-doc"><p><code>qualified_pointer_type ty as</code> returns the pointer type referencing objects of type <code>ty</code> in address space <code>as</code>. See the method <code>llvm::PointerType::get</code>.</p></div></div><div class="odoc-spec"><div class="spec value" id="val-vector_type" class="anchored"><a href="#val-vector_type" class="anchor"></a><code><span><span class="keyword">val</span> vector_type : <span><a href="#type-lltype">lltype</a> <span class="arrow">&#45;&gt;</span></span> <span>int <span class="arrow">&#45;&gt;</span></span> <a href="#type-lltype">lltype</a></span></code></div><div class="spec-doc"><p><code>vector_type ty n</code> returns the array type containing <code>n</code> elements of the primitive type <code>ty</code>. See the method <code>llvm::ArrayType::get</code>.</p></div></div><div class="odoc-spec"><div class="spec value" id="val-element_type" class="anchored"><a href="#val-element_type" class="anchor"></a><code><span><span class="keyword">val</span> element_type : <span><a href="#type-lltype">lltype</a> <span class="arrow">&#45;&gt;</span></span> <a href="#type-lltype">lltype</a></span></code></div><div class="spec-doc"><p><code>element_type ty</code> returns the element type of the pointer, vector, or array type <code>ty</code>. See the method <code>llvm::SequentialType::get</code>.</p></div></div><div class="odoc-spec"><div class="spec value" id="val-array_length" class="anchored"><a href="#val-array_length" class="anchor"></a><code><span><span class="keyword">val</span> array_length : <span><a href="#type-lltype">lltype</a> <span class="arrow">&#45;&gt;</span></span> int</span></code></div><div class="spec-doc"><p><code>element_type aty</code> returns the element count of the array type <code>aty</code>. See the method <code>llvm::ArrayType::getNumElements</code>.</p></div></div><div class="odoc-spec"><div class="spec value" id="val-address_space" class="anchored"><a href="#val-address_space" class="anchor"></a><code><span><span class="keyword">val</span> address_space : <span><a href="#type-lltype">lltype</a> <span class="arrow">&#45;&gt;</span></span> int</span></code></div><div class="spec-doc"><p><code>address_space pty</code> returns the address space qualifier of the pointer type <code>pty</code>. See the method <code>llvm::PointerType::getAddressSpace</code>.</p></div></div><div class="odoc-spec"><div class="spec value" id="val-vector_size" class="anchored"><a href="#val-vector_size" class="anchor"></a><code><span><span class="keyword">val</span> vector_size : <span><a href="#type-lltype">lltype</a> <span class="arrow">&#45;&gt;</span></span> int</span></code></div><div class="spec-doc"><p><code>element_type ty</code> returns the element count of the vector type <code>ty</code>. See the method <code>llvm::VectorType::getNumElements</code>.</p></div></div><h6 id="operations-on-other-types"><a href="#operations-on-other-types" class="anchor"></a>Operations on other types</h6><div class="odoc-spec"><div class="spec value" id="val-void_type" class="anchored"><a href="#val-void_type" class="anchor"></a><code><span><span class="keyword">val</span> void_type : <span><a href="#type-llcontext">llcontext</a> <span class="arrow">&#45;&gt;</span></span> <a href="#type-lltype">lltype</a></span></code></div><div class="spec-doc"><p><code>void_type c</code> creates a type of a function which does not return any value in the context <code>c</code>. See <code>llvm::Type::VoidTy</code>.</p></div></div><div class="odoc-spec"><div class="spec value" id="val-label_type" class="anchored"><a href="#val-label_type" class="anchor"></a><code><span><span class="keyword">val</span> label_type : <span><a href="#type-llcontext">llcontext</a> <span class="arrow">&#45;&gt;</span></span> <a href="#type-lltype">lltype</a></span></code></div><div class="spec-doc"><p><code>label_type c</code> creates a type of a basic block in the context <code>c</code>. See <code>llvm::Type::LabelTy</code>.</p></div></div><div class="odoc-spec"><div class="spec value" id="val-x86_mmx_type" class="anchored"><a href="#val-x86_mmx_type" class="anchor"></a><code><span><span class="keyword">val</span> x86_mmx_type : <span><a href="#type-llcontext">llcontext</a> <span class="arrow">&#45;&gt;</span></span> <a href="#type-lltype">lltype</a></span></code></div><div class="spec-doc"><p><code>x86_mmx_type c</code> returns the x86 64-bit MMX register type in the context <code>c</code>. See <code>llvm::Type::X86_MMXTy</code>.</p></div></div><div class="odoc-spec"><div class="spec value" id="val-type_by_name" class="anchored"><a href="#val-type_by_name" class="anchor"></a><code><span><span class="keyword">val</span> type_by_name : <span><a href="#type-llmodule">llmodule</a> <span class="arrow">&#45;&gt;</span></span> <span>string <span class="arrow">&#45;&gt;</span></span> <span><a href="#type-lltype">lltype</a> option</span></span></code></div><div class="spec-doc"><p><code>type_by_name m name</code> returns the specified type from the current module if it exists. See the method <code>llvm::Module::getTypeByName</code></p></div></div><h6 id="values"><a href="#values" class="anchor"></a>Values</h6><div class="odoc-spec"><div class="spec value" id="val-type_of" class="anchored"><a href="#val-type_of" class="anchor"></a><code><span><span class="keyword">val</span> type_of : <span><a href="#type-llvalue">llvalue</a> <span class="arrow">&#45;&gt;</span></span> <a href="#type-lltype">lltype</a></span></code></div><div class="spec-doc"><p><code>type_of v</code> returns the type of the value <code>v</code>. See the method <code>llvm::Value::getType</code>.</p></div></div><div class="odoc-spec"><div class="spec value" id="val-classify_value" class="anchored"><a href="#val-classify_value" class="anchor"></a><code><span><span class="keyword">val</span> classify_value : <span><a href="#type-llvalue">llvalue</a> <span class="arrow">&#45;&gt;</span></span> <a href="ValueKind/index.html#type-t">ValueKind.t</a></span></code></div><div class="spec-doc"><p><code>classify_value v</code> returns the kind of the value <code>v</code>.</p></div></div><div class="odoc-spec"><div class="spec value" id="val-value_name" class="anchored"><a href="#val-value_name" class="anchor"></a><code><span><span class="keyword">val</span> value_name : <span><a href="#type-llvalue">llvalue</a> <span class="arrow">&#45;&gt;</span></span> string</span></code></div><div class="spec-doc"><p><code>value_name v</code> returns the name of the value <code>v</code>. For global values, this is the symbol name. For instructions and basic blocks, it is the SSA register name. It is meaningless for constants. See the method <code>llvm::Value::getName</code>.</p></div></div><div class="odoc-spec"><div class="spec value" id="val-set_value_name" class="anchored"><a href="#val-set_value_name" class="anchor"></a><code><span><span class="keyword">val</span> set_value_name : <span>string <span class="arrow">&#45;&gt;</span></span> <span><a href="#type-llvalue">llvalue</a> <span class="arrow">&#45;&gt;</span></span> unit</span></code></div><div class="spec-doc"><p><code>set_value_name n v</code> sets the name of the value <code>v</code> to <code>n</code>. See the method <code>llvm::Value::setName</code>.</p></div></div><div class="odoc-spec"><div class="spec value" id="val-dump_value" class="anchored"><a href="#val-dump_value" class="anchor"></a><code><span><span class="keyword">val</span> dump_value : <span><a href="#type-llvalue">llvalue</a> <span class="arrow">&#45;&gt;</span></span> unit</span></code></div><div class="spec-doc"><p><code>dump_value v</code> prints the .ll representation of the value <code>v</code> to standard error. See the method <code>llvm::Value::dump</code>.</p></div></div><div class="odoc-spec"><div class="spec value" id="val-string_of_llvalue" class="anchored"><a href="#val-string_of_llvalue" class="anchor"></a><code><span><span class="keyword">val</span> string_of_llvalue : <span><a href="#type-llvalue">llvalue</a> <span class="arrow">&#45;&gt;</span></span> string</span></code></div><div class="spec-doc"><p><code>string_of_llvalue v</code> returns a string describing the value <code>v</code>.</p></div></div><div class="odoc-spec"><div class="spec value" id="val-replace_all_uses_with" class="anchored"><a href="#val-replace_all_uses_with" class="anchor"></a><code><span><span class="keyword">val</span> replace_all_uses_with : <span><a href="#type-llvalue">llvalue</a> <span class="arrow">&#45;&gt;</span></span> <span><a href="#type-llvalue">llvalue</a> <span class="arrow">&#45;&gt;</span></span> unit</span></code></div><div class="spec-doc"><p><code>replace_all_uses_with old new</code> replaces all uses of the value <code>old</code> with the value <code>new</code>. See the method <code>llvm::Value::replaceAllUsesWith</code>.</p></div></div><h6 id="uses"><a href="#uses" class="anchor"></a>Uses</h6><div class="odoc-spec"><div class="spec value" id="val-use_begin" class="anchored"><a href="#val-use_begin" class="anchor"></a><code><span><span class="keyword">val</span> use_begin : <span><a href="#type-llvalue">llvalue</a> <span class="arrow">&#45;&gt;</span></span> <span><a href="#type-lluse">lluse</a> option</span></span></code></div><div class="spec-doc"><p><code>use_begin v</code> returns the first position in the use list for the value <code>v</code>. <code>use_begin</code> and <code>use_succ</code> can e used to iterate over the use list in order. See the method <code>llvm::Value::use_begin</code>.</p></div></div><div class="odoc-spec"><div class="spec value" id="val-use_succ" class="anchored"><a href="#val-use_succ" class="anchor"></a><code><span><span class="keyword">val</span> use_succ : <span><a href="#type-lluse">lluse</a> <span class="arrow">&#45;&gt;</span></span> <span><a href="#type-lluse">lluse</a> option</span></span></code></div><div class="spec-doc"><p><code>use_succ u</code> returns the use list position succeeding <code>u</code>. See the method <code>llvm::use_value_iterator::operator++</code>.</p></div></div><div class="odoc-spec"><div class="spec value" id="val-user" class="anchored"><a href="#val-user" class="anchor"></a><code><span><span class="keyword">val</span> user : <span><a href="#type-lluse">lluse</a> <span class="arrow">&#45;&gt;</span></span> <a href="#type-llvalue">llvalue</a></span></code></div><div class="spec-doc"><p><code>user u</code> returns the user of the use <code>u</code>. See the method <code>llvm::Use::getUser</code>.</p></div></div><div class="odoc-spec"><div class="spec value" id="val-used_value" class="anchored"><a href="#val-used_value" class="anchor"></a><code><span><span class="keyword">val</span> used_value : <span><a href="#type-lluse">lluse</a> <span class="arrow">&#45;&gt;</span></span> <a href="#type-llvalue">llvalue</a></span></code></div><div class="spec-doc"><p><code>used_value u</code> returns the usee of the use <code>u</code>. See the method <code>llvm::Use::getUsedValue</code>.</p></div></div><div class="odoc-spec"><div class="spec value" id="val-iter_uses" class="anchored"><a href="#val-iter_uses" class="anchor"></a><code><span><span class="keyword">val</span> iter_uses : <span><span>( <span><a href="#type-lluse">lluse</a> <span class="arrow">&#45;&gt;</span></span> unit )</span> <span class="arrow">&#45;&gt;</span></span> <span><a href="#type-llvalue">llvalue</a> <span class="arrow">&#45;&gt;</span></span> unit</span></code></div><div class="spec-doc"><p><code>iter_uses f v</code> applies function <code>f</code> to each of the users of the value <code>v</code> in order. Tail recursive.</p></div></div><div class="odoc-spec"><div class="spec value" id="val-fold_left_uses" class="anchored"><a href="#val-fold_left_uses" class="anchor"></a><code><span><span class="keyword">val</span> fold_left_uses : <span><span>( <span><span class="type-var">'a</span> <span class="arrow">&#45;&gt;</span></span> <span><a href="#type-lluse">lluse</a> <span class="arrow">&#45;&gt;</span></span> <span class="type-var">'a</span> )</span> <span class="arrow">&#45;&gt;</span></span> <span><span class="type-var">'a</span> <span class="arrow">&#45;&gt;</span></span> <span><a href="#type-llvalue">llvalue</a> <span class="arrow">&#45;&gt;</span></span> <span class="type-var">'a</span></span></code></div><div class="spec-doc"><p><code>fold_left_uses f init v</code> is <code>f (... (f init u1) ...) uN</code> where <code>u1,...,uN</code> are the users of the value <code>v</code>. Tail recursive.</p></div></div><div class="odoc-spec"><div class="spec value" id="val-fold_right_uses" class="anchored"><a href="#val-fold_right_uses" class="anchor"></a><code><span><span class="keyword">val</span> fold_right_uses : <span><span>( <span><a href="#type-lluse">lluse</a> <span class="arrow">&#45;&gt;</span></span> <span><span class="type-var">'a</span> <span class="arrow">&#45;&gt;</span></span> <span class="type-var">'a</span> )</span> <span class="arrow">&#45;&gt;</span></span> <span><a href="#type-llvalue">llvalue</a> <span class="arrow">&#45;&gt;</span></span> <span><span class="type-var">'a</span> <span class="arrow">&#45;&gt;</span></span> <span class="type-var">'a</span></span></code></div><div class="spec-doc"><p><code>fold_right_uses f v init</code> is <code>f u1 (... (f uN init) ...)</code> where <code>u1,...,uN</code> are the users of the value <code>v</code>. Not tail recursive.</p></div></div><h6 id="users"><a href="#users" class="anchor"></a>Users</h6><div class="odoc-spec"><div class="spec value" id="val-operand" class="anchored"><a href="#val-operand" class="anchor"></a><code><span><span class="keyword">val</span> operand : <span><a href="#type-llvalue">llvalue</a> <span class="arrow">&#45;&gt;</span></span> <span>int <span class="arrow">&#45;&gt;</span></span> <a href="#type-llvalue">llvalue</a></span></code></div><div class="spec-doc"><p><code>operand v i</code> returns the operand at index <code>i</code> for the value <code>v</code>. See the method <code>llvm::User::getOperand</code>.</p></div></div><div class="odoc-spec"><div class="spec value" id="val-operand_use" class="anchored"><a href="#val-operand_use" class="anchor"></a><code><span><span class="keyword">val</span> operand_use : <span><a href="#type-llvalue">llvalue</a> <span class="arrow">&#45;&gt;</span></span> <span>int <span class="arrow">&#45;&gt;</span></span> <a href="#type-lluse">lluse</a></span></code></div><div class="spec-doc"><p><code>operand_use v i</code> returns the use of the operand at index <code>i</code> for the value <code>v</code>. See the method <code>llvm::User::getOperandUse</code>.</p></div></div><div class="odoc-spec"><div class="spec value" id="val-set_operand" class="anchored"><a href="#val-set_operand" class="anchor"></a><code><span><span class="keyword">val</span> set_operand : <span><a href="#type-llvalue">llvalue</a> <span class="arrow">&#45;&gt;</span></span> <span>int <span class="arrow">&#45;&gt;</span></span> <span><a href="#type-llvalue">llvalue</a> <span class="arrow">&#45;&gt;</span></span> unit</span></code></div><div class="spec-doc"><p><code>set_operand v i o</code> sets the operand of the value <code>v</code> at the index <code>i</code> to the value <code>o</code>. See the method <code>llvm::User::setOperand</code>.</p></div></div><div class="odoc-spec"><div class="spec value" id="val-num_operands" class="anchored"><a href="#val-num_operands" class="anchor"></a><code><span><span class="keyword">val</span> num_operands : <span><a href="#type-llvalue">llvalue</a> <span class="arrow">&#45;&gt;</span></span> int</span></code></div><div class="spec-doc"><p><code>num_operands v</code> returns the number of operands for the value <code>v</code>. See the method <code>llvm::User::getNumOperands</code>.</p></div></div><div class="odoc-spec"><div class="spec value" id="val-indices" class="anchored"><a href="#val-indices" class="anchor"></a><code><span><span class="keyword">val</span> indices : <span><a href="#type-llvalue">llvalue</a> <span class="arrow">&#45;&gt;</span></span> <span>int array</span></span></code></div><div class="spec-doc"><p><code>indices i</code> returns the indices for the ExtractValue or InsertValue instruction <code>i</code>. See the <code>llvm::getIndices</code> methods.</p></div></div><h6 id="operations-on-constants-of-(mostly)-any-type"><a href="#operations-on-constants-of-(mostly)-any-type" class="anchor"></a>Operations on constants of (mostly) any type</h6><div class="odoc-spec"><div class="spec value" id="val-is_constant" class="anchored"><a href="#val-is_constant" class="anchor"></a><code><span><span class="keyword">val</span> is_constant : <span><a href="#type-llvalue">llvalue</a> <span class="arrow">&#45;&gt;</span></span> bool</span></code></div><div class="spec-doc"><p><code>is_constant v</code> returns <code>true</code> if the value <code>v</code> is a constant, <code>false</code> otherwise. Similar to <code>llvm::isa&lt;Constant&gt;</code>.</p></div></div><div class="odoc-spec"><div class="spec value" id="val-const_null" class="anchored"><a href="#val-const_null" class="anchor"></a><code><span><span class="keyword">val</span> const_null : <span><a href="#type-lltype">lltype</a> <span class="arrow">&#45;&gt;</span></span> <a href="#type-llvalue">llvalue</a></span></code></div><div class="spec-doc"><p><code>const_null ty</code> returns the constant null (zero) of the type <code>ty</code>. See the method <code>llvm::Constant::getNullValue</code>.</p></div></div><div class="odoc-spec"><div class="spec value" id="val-const_all_ones" class="anchored"><a href="#val-const_all_ones" class="anchor"></a><code><span><span class="keyword">val</span> const_all_ones : <span><a href="#type-lltype">lltype</a> <span class="arrow">&#45;&gt;</span></span> <a href="#type-llvalue">llvalue</a></span></code></div><div class="spec-doc"><p><code>const_all_ones ty</code> returns the constant '-1' of the integer or vector type <code>ty</code>. See the method <code>llvm::Constant::getAllOnesValue</code>.</p></div></div><div class="odoc-spec"><div class="spec value" id="val-const_pointer_null" class="anchored"><a href="#val-const_pointer_null" class="anchor"></a><code><span><span class="keyword">val</span> const_pointer_null : <span><a href="#type-lltype">lltype</a> <span class="arrow">&#45;&gt;</span></span> <a href="#type-llvalue">llvalue</a></span></code></div><div class="spec-doc"><p><code>const_pointer_null ty</code> returns the constant null (zero) pointer of the type <code>ty</code>. See the method <code>llvm::ConstantPointerNull::get</code>.</p></div></div><div class="odoc-spec"><div class="spec value" id="val-undef" class="anchored"><a href="#val-undef" class="anchor"></a><code><span><span class="keyword">val</span> undef : <span><a href="#type-lltype">lltype</a> <span class="arrow">&#45;&gt;</span></span> <a href="#type-llvalue">llvalue</a></span></code></div><div class="spec-doc"><p><code>undef ty</code> returns the undefined value of the type <code>ty</code>. See the method <code>llvm::UndefValue::get</code>.</p></div></div><div class="odoc-spec"><div class="spec value" id="val-poison" class="anchored"><a href="#val-poison" class="anchor"></a><code><span><span class="keyword">val</span> poison : <span><a href="#type-lltype">lltype</a> <span class="arrow">&#45;&gt;</span></span> <a href="#type-llvalue">llvalue</a></span></code></div><div class="spec-doc"><p><code>poison ty</code> returns the poison value of the type <code>ty</code>. See the method <code>llvm::PoisonValue::get</code>.</p></div></div><div class="odoc-spec"><div class="spec value" id="val-is_null" class="anchored"><a href="#val-is_null" class="anchor"></a><code><span><span class="keyword">val</span> is_null : <span><a href="#type-llvalue">llvalue</a> <span class="arrow">&#45;&gt;</span></span> bool</span></code></div><div class="spec-doc"><p><code>is_null v</code> returns <code>true</code> if the value <code>v</code> is the null (zero) value. See the method <code>llvm::Constant::isNullValue</code>.</p></div></div><div class="odoc-spec"><div class="spec value" id="val-is_undef" class="anchored"><a href="#val-is_undef" class="anchor"></a><code><span><span class="keyword">val</span> is_undef : <span><a href="#type-llvalue">llvalue</a> <span class="arrow">&#45;&gt;</span></span> bool</span></code></div><div class="spec-doc"><p><code>is_undef v</code> returns <code>true</code> if the value <code>v</code> is an undefined value, <code>false</code> otherwise. Similar to <code>llvm::isa&lt;UndefValue&gt;</code>.</p></div></div><div class="odoc-spec"><div class="spec value" id="val-is_poison" class="anchored"><a href="#val-is_poison" class="anchor"></a><code><span><span class="keyword">val</span> is_poison : <span><a href="#type-llvalue">llvalue</a> <span class="arrow">&#45;&gt;</span></span> bool</span></code></div><div class="spec-doc"><p><code>is_poison v</code> returns <code>true</code> if the value <code>v</code> is a poison value, <code>false</code> otherwise. Similar to <code>llvm::isa&lt;PoisonValue&gt;</code>.</p></div></div><div class="odoc-spec"><div class="spec value" id="val-constexpr_opcode" class="anchored"><a href="#val-constexpr_opcode" class="anchor"></a><code><span><span class="keyword">val</span> constexpr_opcode : <span><a href="#type-llvalue">llvalue</a> <span class="arrow">&#45;&gt;</span></span> <a href="Opcode/index.html#type-t">Opcode.t</a></span></code></div><div class="spec-doc"><p><code>constexpr_opcode v</code> returns an <code>Opcode.t</code> corresponding to constexpr value <code>v</code>, or <code>Opcode.Invalid</code> if <code>v</code> is not a constexpr.</p></div></div><h6 id="operations-on-instructions"><a href="#operations-on-instructions" class="anchor"></a>Operations on instructions</h6><div class="odoc-spec"><div class="spec value" id="val-has_metadata" class="anchored"><a href="#val-has_metadata" class="anchor"></a><code><span><span class="keyword">val</span> has_metadata : <span><a href="#type-llvalue">llvalue</a> <span class="arrow">&#45;&gt;</span></span> bool</span></code></div><div class="spec-doc"><p><code>has_metadata i</code> returns whether or not the instruction <code>i</code> has any metadata attached to it. See the function <code>llvm::Instruction::hasMetadata</code>.</p></div></div><div class="odoc-spec"><div class="spec value" id="val-metadata" class="anchored"><a href="#val-metadata" class="anchor"></a><code><span><span class="keyword">val</span> metadata : <span><a href="#type-llvalue">llvalue</a> <span class="arrow">&#45;&gt;</span></span> <span><a href="#type-llmdkind">llmdkind</a> <span class="arrow">&#45;&gt;</span></span> <span><a href="#type-llvalue">llvalue</a> option</span></span></code></div><div class="spec-doc"><p><code>metadata i kind</code> optionally returns the metadata associated with the kind <code>kind</code> in the instruction <code>i</code> See the function <code>llvm::Instruction::getMetadata</code>.</p></div></div><div class="odoc-spec"><div class="spec value" id="val-set_metadata" class="anchored"><a href="#val-set_metadata" class="anchor"></a><code><span><span class="keyword">val</span> set_metadata : <span><a href="#type-llvalue">llvalue</a> <span class="arrow">&#45;&gt;</span></span> <span><a href="#type-llmdkind">llmdkind</a> <span class="arrow">&#45;&gt;</span></span> <span><a href="#type-llvalue">llvalue</a> <span class="arrow">&#45;&gt;</span></span> unit</span></code></div><div class="spec-doc"><p><code>set_metadata i kind md</code> sets the metadata <code>md</code> of kind <code>kind</code> in the instruction <code>i</code>. See the function <code>llvm::Instruction::setMetadata</code>.</p></div></div><div class="odoc-spec"><div class="spec value" id="val-clear_metadata" class="anchored"><a href="#val-clear_metadata" class="anchor"></a><code><span><span class="keyword">val</span> clear_metadata : <span><a href="#type-llvalue">llvalue</a> <span class="arrow">&#45;&gt;</span></span> <span><a href="#type-llmdkind">llmdkind</a> <span class="arrow">&#45;&gt;</span></span> unit</span></code></div><div class="spec-doc"><p><code>clear_metadata i kind</code> clears the metadata of kind <code>kind</code> in the instruction <code>i</code>. See the function <code>llvm::Instruction::setMetadata</code>.</p></div></div><h6 id="operations-on-metadata"><a href="#operations-on-metadata" class="anchor"></a>Operations on metadata</h6><div class="odoc-spec"><div class="spec value" id="val-mdstring" class="anchored"><a href="#val-mdstring" class="anchor"></a><code><span><span class="keyword">val</span> mdstring : <span><a href="#type-llcontext">llcontext</a> <span class="arrow">&#45;&gt;</span></span> <span>string <span class="arrow">&#45;&gt;</span></span> <a href="#type-llvalue">llvalue</a></span></code></div><div class="spec-doc"><p><code>mdstring c s</code> returns the MDString of the string <code>s</code> in the context <code>c</code>. See the method <code>llvm::MDNode::get</code>.</p></div></div><div class="odoc-spec"><div class="spec value" id="val-mdnode" class="anchored"><a href="#val-mdnode" class="anchor"></a><code><span><span class="keyword">val</span> mdnode : <span><a href="#type-llcontext">llcontext</a> <span class="arrow">&#45;&gt;</span></span> <span><span><a href="#type-llvalue">llvalue</a> array</span> <span class="arrow">&#45;&gt;</span></span> <a href="#type-llvalue">llvalue</a></span></code></div><div class="spec-doc"><p><code>mdnode c elts</code> returns the MDNode containing the values <code>elts</code> in the context <code>c</code>. See the method <code>llvm::MDNode::get</code>.</p></div></div><div class="odoc-spec"><div class="spec value" id="val-mdnull" class="anchored"><a href="#val-mdnull" class="anchor"></a><code><span><span class="keyword">val</span> mdnull : <span><a href="#type-llcontext">llcontext</a> <span class="arrow">&#45;&gt;</span></span> <a href="#type-llvalue">llvalue</a></span></code></div><div class="spec-doc"><p><code>mdnull c </code> returns a null MDNode in context <code>c</code>.</p></div></div><div class="odoc-spec"><div class="spec value" id="val-get_mdstring" class="anchored"><a href="#val-get_mdstring" class="anchor"></a><code><span><span class="keyword">val</span> get_mdstring : <span><a href="#type-llvalue">llvalue</a> <span class="arrow">&#45;&gt;</span></span> <span>string option</span></span></code></div><div class="spec-doc"><p><code>get_mdstring v</code> returns the MDString. See the method <code>llvm::MDString::getString</code></p></div></div><div class="odoc-spec"><div class="spec value" id="val-get_mdnode_operands" class="anchored"><a href="#val-get_mdnode_operands" class="anchor"></a><code><span><span class="keyword">val</span> get_mdnode_operands : <span><a href="#type-llvalue">llvalue</a> <span class="arrow">&#45;&gt;</span></span> <span><a href="#type-llvalue">llvalue</a> array</span></span></code></div><div class="spec-doc"><p><code>get_mdnode_operands v</code> returns the operands in the MDNode.</p></div></div><div class="odoc-spec"><div class="spec value" id="val-get_named_metadata" class="anchored"><a href="#val-get_named_metadata" class="anchor"></a><code><span><span class="keyword">val</span> get_named_metadata : <span><a href="#type-llmodule">llmodule</a> <span class="arrow">&#45;&gt;</span></span> <span>string <span class="arrow">&#45;&gt;</span></span> <span><a href="#type-llvalue">llvalue</a> array</span></span></code></div><div class="spec-doc"><p><code>get_named_metadata m name</code> returns all the MDNodes belonging to the named metadata (if any). See the method <code>llvm::NamedMDNode::getOperand</code>.</p></div></div><div class="odoc-spec"><div class="spec value" id="val-add_named_metadata_operand" class="anchored"><a href="#val-add_named_metadata_operand" class="anchor"></a><code><span><span class="keyword">val</span> add_named_metadata_operand : <span><a href="#type-llmodule">llmodule</a> <span class="arrow">&#45;&gt;</span></span> <span>string <span class="arrow">&#45;&gt;</span></span> <span><a href="#type-llvalue">llvalue</a> <span class="arrow">&#45;&gt;</span></span> unit</span></code></div><div class="spec-doc"><p><code>add_named_metadata_operand m name v</code> adds <code>v</code> as the last operand of metadata named <code>name</code> in module <code>m</code>. If the metadata does not exist, it is created. See the methods <code>llvm::Module::getNamedMetadata()</code> and <code>llvm::MDNode::addOperand()</code>.</p></div></div><div class="odoc-spec"><div class="spec value" id="val-value_as_metadata" class="anchored"><a href="#val-value_as_metadata" class="anchor"></a><code><span><span class="keyword">val</span> value_as_metadata : <span><a href="#type-llvalue">llvalue</a> <span class="arrow">&#45;&gt;</span></span> <a href="#type-llmetadata">llmetadata</a></span></code></div><div class="spec-doc"><p>Obtain a Metadata as a Value. See the method <code>llvm::ValueAsMetadata::get()</code>.</p></div></div><div class="odoc-spec"><div class="spec value" id="val-metadata_as_value" class="anchored"><a href="#val-metadata_as_value" class="anchor"></a><code><span><span class="keyword">val</span> metadata_as_value : <span><a href="#type-llcontext">llcontext</a> <span class="arrow">&#45;&gt;</span></span> <span><a href="#type-llmetadata">llmetadata</a> <span class="arrow">&#45;&gt;</span></span> <a href="#type-llvalue">llvalue</a></span></code></div><div class="spec-doc"><p>Obtain a Value as a Metadata. See the method <code>llvm::MetadataAsValue::get()</code>.</p></div></div><h6 id="operations-on-scalar-constants"><a href="#operations-on-scalar-constants" class="anchor"></a>Operations on scalar constants</h6><div class="odoc-spec"><div class="spec value" id="val-const_int" class="anchored"><a href="#val-const_int" class="anchor"></a><code><span><span class="keyword">val</span> const_int : <span><a href="#type-lltype">lltype</a> <span class="arrow">&#45;&gt;</span></span> <span>int <span class="arrow">&#45;&gt;</span></span> <a href="#type-llvalue">llvalue</a></span></code></div><div class="spec-doc"><p><code>const_int ty i</code> returns the integer constant of type <code>ty</code> and value <code>i</code>. See the method <code>llvm::ConstantInt::get</code>.</p></div></div><div class="odoc-spec"><div class="spec value" id="val-const_of_int64" class="anchored"><a href="#val-const_of_int64" class="anchor"></a><code><span><span class="keyword">val</span> const_of_int64 : <span><a href="#type-lltype">lltype</a> <span class="arrow">&#45;&gt;</span></span> <span><span class="xref-unresolved">Stdlib</span>.Int64.t <span class="arrow">&#45;&gt;</span></span> <span>bool <span class="arrow">&#45;&gt;</span></span> <a href="#type-llvalue">llvalue</a></span></code></div><div class="spec-doc"><p><code>const_of_int64 ty i s</code> returns the integer constant of type <code>ty</code> and value <code>i</code>. <code>s</code> indicates whether the integer is signed or not. See the method <code>llvm::ConstantInt::get</code>.</p></div></div><div class="odoc-spec"><div class="spec value" id="val-int64_of_const" class="anchored"><a href="#val-int64_of_const" class="anchor"></a><code><span><span class="keyword">val</span> int64_of_const : <span><a href="#type-llvalue">llvalue</a> <span class="arrow">&#45;&gt;</span></span> <span><span class="xref-unresolved">Stdlib</span>.Int64.t option</span></span></code></div><div class="spec-doc"><p><code>int64_of_const c</code> returns the int64 value of the <code>c</code> constant integer. None is returned if this is not an integer constant, or bitwidth exceeds 64. See the method <code>llvm::ConstantInt::getSExtValue</code>.</p></div></div><div class="odoc-spec"><div class="spec value" id="val-const_int_of_string" class="anchored"><a href="#val-const_int_of_string" class="anchor"></a><code><span><span class="keyword">val</span> const_int_of_string : <span><a href="#type-lltype">lltype</a> <span class="arrow">&#45;&gt;</span></span> <span>string <span class="arrow">&#45;&gt;</span></span> <span>int <span class="arrow">&#45;&gt;</span></span> <a href="#type-llvalue">llvalue</a></span></code></div><div class="spec-doc"><p><code>const_int_of_string ty s r</code> returns the integer constant of type <code>ty</code> and value <code>s</code>, with the radix <code>r</code>. See the method <code>llvm::ConstantInt::get</code>.</p></div></div><div class="odoc-spec"><div class="spec value" id="val-const_float" class="anchored"><a href="#val-const_float" class="anchor"></a><code><span><span class="keyword">val</span> const_float : <span><a href="#type-lltype">lltype</a> <span class="arrow">&#45;&gt;</span></span> <span>float <span class="arrow">&#45;&gt;</span></span> <a href="#type-llvalue">llvalue</a></span></code></div><div class="spec-doc"><p><code>const_float ty n</code> returns the floating point constant of type <code>ty</code> and value <code>n</code>. See the method <code>llvm::ConstantFP::get</code>.</p></div></div><div class="odoc-spec"><div class="spec value" id="val-float_of_const" class="anchored"><a href="#val-float_of_const" class="anchor"></a><code><span><span class="keyword">val</span> float_of_const : <span><a href="#type-llvalue">llvalue</a> <span class="arrow">&#45;&gt;</span></span> <span>float option</span></span></code></div><div class="spec-doc"><p><code>float_of_const c</code> returns the float value of the <code>c</code> constant float. None is returned if this is not an float constant. See the method <code>llvm::ConstantFP::getDoubleValue</code>.</p></div></div><div class="odoc-spec"><div class="spec value" id="val-const_float_of_string" class="anchored"><a href="#val-const_float_of_string" class="anchor"></a><code><span><span class="keyword">val</span> const_float_of_string : <span><a href="#type-lltype">lltype</a> <span class="arrow">&#45;&gt;</span></span> <span>string <span class="arrow">&#45;&gt;</span></span> <a href="#type-llvalue">llvalue</a></span></code></div><div class="spec-doc"><p><code>const_float_of_string ty s</code> returns the floating point constant of type <code>ty</code> and value <code>n</code>. See the method <code>llvm::ConstantFP::get</code>.</p></div></div><h6 id="operations-on-composite-constants"><a href="#operations-on-composite-constants" class="anchor"></a>Operations on composite constants</h6><div class="odoc-spec"><div class="spec value" id="val-const_string" class="anchored"><a href="#val-const_string" class="anchor"></a><code><span><span class="keyword">val</span> const_string : <span><a href="#type-llcontext">llcontext</a> <span class="arrow">&#45;&gt;</span></span> <span>string <span class="arrow">&#45;&gt;</span></span> <a href="#type-llvalue">llvalue</a></span></code></div><div class="spec-doc"><p><code>const_string c s</code> returns the constant <code>i8</code> array with the values of the characters in the string <code>s</code> in the context <code>c</code>. The array is not null-terminated (but see <a href="#val-const_stringz"><code>const_stringz</code></a>). This value can in turn be used as the initializer for a global variable. See the method <code>llvm::ConstantArray::get</code>.</p></div></div><div class="odoc-spec"><div class="spec value" id="val-const_stringz" class="anchored"><a href="#val-const_stringz" class="anchor"></a><code><span><span class="keyword">val</span> const_stringz : <span><a href="#type-llcontext">llcontext</a> <span class="arrow">&#45;&gt;</span></span> <span>string <span class="arrow">&#45;&gt;</span></span> <a href="#type-llvalue">llvalue</a></span></code></div><div class="spec-doc"><p><code>const_stringz c s</code> returns the constant <code>i8</code> array with the values of the characters in the string <code>s</code> and a null terminator in the context <code>c</code>. This value can in turn be used as the initializer for a global variable. See the method <code>llvm::ConstantArray::get</code>.</p></div></div><div class="odoc-spec"><div class="spec value" id="val-const_array" class="anchored"><a href="#val-const_array" class="anchor"></a><code><span><span class="keyword">val</span> const_array : <span><a href="#type-lltype">lltype</a> <span class="arrow">&#45;&gt;</span></span> <span><span><a href="#type-llvalue">llvalue</a> array</span> <span class="arrow">&#45;&gt;</span></span> <a href="#type-llvalue">llvalue</a></span></code></div><div class="spec-doc"><p><code>const_array ty elts</code> returns the constant array of type <code>array_type ty (Array.length elts)</code> and containing the values <code>elts</code>. This value can in turn be used as the initializer for a global variable. See the method <code>llvm::ConstantArray::get</code>.</p></div></div><div class="odoc-spec"><div class="spec value" id="val-const_struct" class="anchored"><a href="#val-const_struct" class="anchor"></a><code><span><span class="keyword">val</span> const_struct : <span><a href="#type-llcontext">llcontext</a> <span class="arrow">&#45;&gt;</span></span> <span><span><a href="#type-llvalue">llvalue</a> array</span> <span class="arrow">&#45;&gt;</span></span> <a href="#type-llvalue">llvalue</a></span></code></div><div class="spec-doc"><p><code>const_struct context elts</code> returns the structured constant of type <code>struct_type (Array.map type_of elts)</code> and containing the values <code>elts</code> in the context <code>context</code>. This value can in turn be used as the initializer for a global variable. See the method <code>llvm::ConstantStruct::getAnon</code>.</p></div></div><div class="odoc-spec"><div class="spec value" id="val-const_named_struct" class="anchored"><a href="#val-const_named_struct" class="anchor"></a><code><span><span class="keyword">val</span> const_named_struct : <span><a href="#type-lltype">lltype</a> <span class="arrow">&#45;&gt;</span></span> <span><span><a href="#type-llvalue">llvalue</a> array</span> <span class="arrow">&#45;&gt;</span></span> <a href="#type-llvalue">llvalue</a></span></code></div><div class="spec-doc"><p><code>const_named_struct namedty elts</code> returns the structured constant of type <code>namedty</code> (which must be a named structure type) and containing the values <code>elts</code>. This value can in turn be used as the initializer for a global variable. See the method <code>llvm::ConstantStruct::get</code>.</p></div></div><div class="odoc-spec"><div class="spec value" id="val-const_packed_struct" class="anchored"><a href="#val-const_packed_struct" class="anchor"></a><code><span><span class="keyword">val</span> const_packed_struct : <span><a href="#type-llcontext">llcontext</a> <span class="arrow">&#45;&gt;</span></span> <span><span><a href="#type-llvalue">llvalue</a> array</span> <span class="arrow">&#45;&gt;</span></span> <a href="#type-llvalue">llvalue</a></span></code></div><div class="spec-doc"><p><code>const_packed_struct context elts</code> returns the structured constant of type <a href="#val-packed_struct_type"><code>packed_struct_type</code></a> <code>(Array.map type_of elts)</code> and containing the values <code>elts</code> in the context <code>context</code>. This value can in turn be used as the initializer for a global variable. See the method <code>llvm::ConstantStruct::get</code>.</p></div></div><div class="odoc-spec"><div class="spec value" id="val-const_vector" class="anchored"><a href="#val-const_vector" class="anchor"></a><code><span><span class="keyword">val</span> const_vector : <span><span><a href="#type-llvalue">llvalue</a> array</span> <span class="arrow">&#45;&gt;</span></span> <a href="#type-llvalue">llvalue</a></span></code></div><div class="spec-doc"><p><code>const_vector elts</code> returns the vector constant of type <code>vector_type (type_of elts.(0)) (Array.length elts)</code> and containing the values <code>elts</code>. See the method <code>llvm::ConstantVector::get</code>.</p></div></div><div class="odoc-spec"><div class="spec value" id="val-string_of_const" class="anchored"><a href="#val-string_of_const" class="anchor"></a><code><span><span class="keyword">val</span> string_of_const : <span><a href="#type-llvalue">llvalue</a> <span class="arrow">&#45;&gt;</span></span> <span>string option</span></span></code></div><div class="spec-doc"><p><code>string_of_const c</code> returns <code>Some str</code> if <code>c</code> is a string constant, or <code>None</code> if this is not a string constant.</p></div></div><div class="odoc-spec"><div class="spec value" id="val-const_element" class="anchored"><a href="#val-const_element" class="anchor"></a><code><span><span class="keyword">val</span> const_element : <span><a href="#type-llvalue">llvalue</a> <span class="arrow">&#45;&gt;</span></span> <span>int <span class="arrow">&#45;&gt;</span></span> <a href="#type-llvalue">llvalue</a></span></code></div><div class="spec-doc"><p><code>const_element c</code> returns a constant for a specified index's element. See the method ConstantDataSequential::getElementAsConstant.</p></div></div><h6 id="constant-expressions"><a href="#constant-expressions" class="anchor"></a>Constant expressions</h6><div class="odoc-spec"><div class="spec value" id="val-align_of" class="anchored"><a href="#val-align_of" class="anchor"></a><code><span><span class="keyword">val</span> align_of : <span><a href="#type-lltype">lltype</a> <span class="arrow">&#45;&gt;</span></span> <a href="#type-llvalue">llvalue</a></span></code></div><div class="spec-doc"><p><code>align_of ty</code> returns the alignof constant for the type <code>ty</code>. This is equivalent to <code>const_ptrtoint (const_gep (const_null (pointer_type {i8,ty}))
    (const_int i32_type 0) (const_int i32_type 1)) i32_type</code>, but considerably more readable. See the method <code>llvm::ConstantExpr::getAlignOf</code>.</p></div></div><div class="odoc-spec"><div class="spec value" id="val-size_of" class="anchored"><a href="#val-size_of" class="anchor"></a><code><span><span class="keyword">val</span> size_of : <span><a href="#type-lltype">lltype</a> <span class="arrow">&#45;&gt;</span></span> <a href="#type-llvalue">llvalue</a></span></code></div><div class="spec-doc"><p><code>size_of ty</code> returns the sizeof constant for the type <code>ty</code>. This is equivalent to <code>const_ptrtoint (const_gep (const_null (pointer_type ty))
    (const_int i32_type 1)) i64_type</code>, but considerably more readable. See the method <code>llvm::ConstantExpr::getSizeOf</code>.</p></div></div><div class="odoc-spec"><div class="spec value" id="val-const_neg" class="anchored"><a href="#val-const_neg" class="anchor"></a><code><span><span class="keyword">val</span> const_neg : <span><a href="#type-llvalue">llvalue</a> <span class="arrow">&#45;&gt;</span></span> <a href="#type-llvalue">llvalue</a></span></code></div><div class="spec-doc"><p><code>const_neg c</code> returns the arithmetic negation of the constant <code>c</code>. See the method <code>llvm::ConstantExpr::getNeg</code>.</p></div></div><div class="odoc-spec"><div class="spec value" id="val-const_nsw_neg" class="anchored"><a href="#val-const_nsw_neg" class="anchor"></a><code><span><span class="keyword">val</span> const_nsw_neg : <span><a href="#type-llvalue">llvalue</a> <span class="arrow">&#45;&gt;</span></span> <a href="#type-llvalue">llvalue</a></span></code></div><div class="spec-doc"><p><code>const_nsw_neg c</code> returns the arithmetic negation of the constant <code>c</code> with no signed wrapping. The result is undefined if the negation overflows. See the method <code>llvm::ConstantExpr::getNSWNeg</code>.</p></div></div><div class="odoc-spec"><div class="spec value" id="val-const_nuw_neg" class="anchored"><a href="#val-const_nuw_neg" class="anchor"></a><code><span><span class="keyword">val</span> const_nuw_neg : <span><a href="#type-llvalue">llvalue</a> <span class="arrow">&#45;&gt;</span></span> <a href="#type-llvalue">llvalue</a></span></code></div><div class="spec-doc"><p><code>const_nuw_neg c</code> returns the arithmetic negation of the constant <code>c</code> with no unsigned wrapping. The result is undefined if the negation overflows. See the method <code>llvm::ConstantExpr::getNUWNeg</code>.</p></div></div><div class="odoc-spec"><div class="spec value" id="val-const_fneg" class="anchored"><a href="#val-const_fneg" class="anchor"></a><code><span><span class="keyword">val</span> const_fneg : <span><a href="#type-llvalue">llvalue</a> <span class="arrow">&#45;&gt;</span></span> <a href="#type-llvalue">llvalue</a></span></code></div><div class="spec-doc"><p><code>const_fneg c</code> returns the arithmetic negation of the constant float <code>c</code>. See the method <code>llvm::ConstantExpr::getFNeg</code>.</p></div></div><div class="odoc-spec"><div class="spec value" id="val-const_not" class="anchored"><a href="#val-const_not" class="anchor"></a><code><span><span class="keyword">val</span> const_not : <span><a href="#type-llvalue">llvalue</a> <span class="arrow">&#45;&gt;</span></span> <a href="#type-llvalue">llvalue</a></span></code></div><div class="spec-doc"><p><code>const_not c</code> returns the bitwise inverse of the constant <code>c</code>. See the method <code>llvm::ConstantExpr::getNot</code>.</p></div></div><div class="odoc-spec"><div class="spec value" id="val-const_add" class="anchored"><a href="#val-const_add" class="anchor"></a><code><span><span class="keyword">val</span> const_add : <span><a href="#type-llvalue">llvalue</a> <span class="arrow">&#45;&gt;</span></span> <span><a href="#type-llvalue">llvalue</a> <span class="arrow">&#45;&gt;</span></span> <a href="#type-llvalue">llvalue</a></span></code></div><div class="spec-doc"><p><code>const_add c1 c2</code> returns the constant sum of two constants. See the method <code>llvm::ConstantExpr::getAdd</code>.</p></div></div><div class="odoc-spec"><div class="spec value" id="val-const_nsw_add" class="anchored"><a href="#val-const_nsw_add" class="anchor"></a><code><span><span class="keyword">val</span> const_nsw_add : <span><a href="#type-llvalue">llvalue</a> <span class="arrow">&#45;&gt;</span></span> <span><a href="#type-llvalue">llvalue</a> <span class="arrow">&#45;&gt;</span></span> <a href="#type-llvalue">llvalue</a></span></code></div><div class="spec-doc"><p><code>const_nsw_add c1 c2</code> returns the constant sum of two constants with no signed wrapping. The result is undefined if the sum overflows. See the method <code>llvm::ConstantExpr::getNSWAdd</code>.</p></div></div><div class="odoc-spec"><div class="spec value" id="val-const_nuw_add" class="anchored"><a href="#val-const_nuw_add" class="anchor"></a><code><span><span class="keyword">val</span> const_nuw_add : <span><a href="#type-llvalue">llvalue</a> <span class="arrow">&#45;&gt;</span></span> <span><a href="#type-llvalue">llvalue</a> <span class="arrow">&#45;&gt;</span></span> <a href="#type-llvalue">llvalue</a></span></code></div><div class="spec-doc"><p><code>const_nuw_add c1 c2</code> returns the constant sum of two constants with no unsigned wrapping. The result is undefined if the sum overflows. See the method <code>llvm::ConstantExpr::getNSWAdd</code>.</p></div></div><div class="odoc-spec"><div class="spec value" id="val-const_fadd" class="anchored"><a href="#val-const_fadd" class="anchor"></a><code><span><span class="keyword">val</span> const_fadd : <span><a href="#type-llvalue">llvalue</a> <span class="arrow">&#45;&gt;</span></span> <span><a href="#type-llvalue">llvalue</a> <span class="arrow">&#45;&gt;</span></span> <a href="#type-llvalue">llvalue</a></span></code></div><div class="spec-doc"><p><code>const_fadd c1 c2</code> returns the constant sum of two constant floats. See the method <code>llvm::ConstantExpr::getFAdd</code>.</p></div></div><div class="odoc-spec"><div class="spec value" id="val-const_sub" class="anchored"><a href="#val-const_sub" class="anchor"></a><code><span><span class="keyword">val</span> const_sub : <span><a href="#type-llvalue">llvalue</a> <span class="arrow">&#45;&gt;</span></span> <span><a href="#type-llvalue">llvalue</a> <span class="arrow">&#45;&gt;</span></span> <a href="#type-llvalue">llvalue</a></span></code></div><div class="spec-doc"><p><code>const_sub c1 c2</code> returns the constant difference, <code>c1 - c2</code>, of two constants. See the method <code>llvm::ConstantExpr::getSub</code>.</p></div></div><div class="odoc-spec"><div class="spec value" id="val-const_nsw_sub" class="anchored"><a href="#val-const_nsw_sub" class="anchor"></a><code><span><span class="keyword">val</span> const_nsw_sub : <span><a href="#type-llvalue">llvalue</a> <span class="arrow">&#45;&gt;</span></span> <span><a href="#type-llvalue">llvalue</a> <span class="arrow">&#45;&gt;</span></span> <a href="#type-llvalue">llvalue</a></span></code></div><div class="spec-doc"><p><code>const_nsw_sub c1 c2</code> returns the constant difference of two constants with no signed wrapping. The result is undefined if the sum overflows. See the method <code>llvm::ConstantExpr::getNSWSub</code>.</p></div></div><div class="odoc-spec"><div class="spec value" id="val-const_nuw_sub" class="anchored"><a href="#val-const_nuw_sub" class="anchor"></a><code><span><span class="keyword">val</span> const_nuw_sub : <span><a href="#type-llvalue">llvalue</a> <span class="arrow">&#45;&gt;</span></span> <span><a href="#type-llvalue">llvalue</a> <span class="arrow">&#45;&gt;</span></span> <a href="#type-llvalue">llvalue</a></span></code></div><div class="spec-doc"><p><code>const_nuw_sub c1 c2</code> returns the constant difference of two constants with no unsigned wrapping. The result is undefined if the sum overflows. See the method <code>llvm::ConstantExpr::getNSWSub</code>.</p></div></div><div class="odoc-spec"><div class="spec value" id="val-const_fsub" class="anchored"><a href="#val-const_fsub" class="anchor"></a><code><span><span class="keyword">val</span> const_fsub : <span><a href="#type-llvalue">llvalue</a> <span class="arrow">&#45;&gt;</span></span> <span><a href="#type-llvalue">llvalue</a> <span class="arrow">&#45;&gt;</span></span> <a href="#type-llvalue">llvalue</a></span></code></div><div class="spec-doc"><p><code>const_fsub c1 c2</code> returns the constant difference, <code>c1 - c2</code>, of two constant floats. See the method <code>llvm::ConstantExpr::getFSub</code>.</p></div></div><div class="odoc-spec"><div class="spec value" id="val-const_mul" class="anchored"><a href="#val-const_mul" class="anchor"></a><code><span><span class="keyword">val</span> const_mul : <span><a href="#type-llvalue">llvalue</a> <span class="arrow">&#45;&gt;</span></span> <span><a href="#type-llvalue">llvalue</a> <span class="arrow">&#45;&gt;</span></span> <a href="#type-llvalue">llvalue</a></span></code></div><div class="spec-doc"><p><code>const_mul c1 c2</code> returns the constant product of two constants. See the method <code>llvm::ConstantExpr::getMul</code>.</p></div></div><div class="odoc-spec"><div class="spec value" id="val-const_nsw_mul" class="anchored"><a href="#val-const_nsw_mul" class="anchor"></a><code><span><span class="keyword">val</span> const_nsw_mul : <span><a href="#type-llvalue">llvalue</a> <span class="arrow">&#45;&gt;</span></span> <span><a href="#type-llvalue">llvalue</a> <span class="arrow">&#45;&gt;</span></span> <a href="#type-llvalue">llvalue</a></span></code></div><div class="spec-doc"><p><code>const_nsw_mul c1 c2</code> returns the constant product of two constants with no signed wrapping. The result is undefined if the sum overflows. See the method <code>llvm::ConstantExpr::getNSWMul</code>.</p></div></div><div class="odoc-spec"><div class="spec value" id="val-const_nuw_mul" class="anchored"><a href="#val-const_nuw_mul" class="anchor"></a><code><span><span class="keyword">val</span> const_nuw_mul : <span><a href="#type-llvalue">llvalue</a> <span class="arrow">&#45;&gt;</span></span> <span><a href="#type-llvalue">llvalue</a> <span class="arrow">&#45;&gt;</span></span> <a href="#type-llvalue">llvalue</a></span></code></div><div class="spec-doc"><p><code>const_nuw_mul c1 c2</code> returns the constant product of two constants with no unsigned wrapping. The result is undefined if the sum overflows. See the method <code>llvm::ConstantExpr::getNSWMul</code>.</p></div></div><div class="odoc-spec"><div class="spec value" id="val-const_fmul" class="anchored"><a href="#val-const_fmul" class="anchor"></a><code><span><span class="keyword">val</span> const_fmul : <span><a href="#type-llvalue">llvalue</a> <span class="arrow">&#45;&gt;</span></span> <span><a href="#type-llvalue">llvalue</a> <span class="arrow">&#45;&gt;</span></span> <a href="#type-llvalue">llvalue</a></span></code></div><div class="spec-doc"><p><code>const_fmul c1 c2</code> returns the constant product of two constants floats. See the method <code>llvm::ConstantExpr::getFMul</code>.</p></div></div><div class="odoc-spec"><div class="spec value" id="val-const_udiv" class="anchored"><a href="#val-const_udiv" class="anchor"></a><code><span><span class="keyword">val</span> const_udiv : <span><a href="#type-llvalue">llvalue</a> <span class="arrow">&#45;&gt;</span></span> <span><a href="#type-llvalue">llvalue</a> <span class="arrow">&#45;&gt;</span></span> <a href="#type-llvalue">llvalue</a></span></code></div><div class="spec-doc"><p><code>const_udiv c1 c2</code> returns the constant quotient <code>c1 / c2</code> of two unsigned integer constants. See the method <code>llvm::ConstantExpr::getUDiv</code>.</p></div></div><div class="odoc-spec"><div class="spec value" id="val-const_sdiv" class="anchored"><a href="#val-const_sdiv" class="anchor"></a><code><span><span class="keyword">val</span> const_sdiv : <span><a href="#type-llvalue">llvalue</a> <span class="arrow">&#45;&gt;</span></span> <span><a href="#type-llvalue">llvalue</a> <span class="arrow">&#45;&gt;</span></span> <a href="#type-llvalue">llvalue</a></span></code></div><div class="spec-doc"><p><code>const_sdiv c1 c2</code> returns the constant quotient <code>c1 / c2</code> of two signed integer constants. See the method <code>llvm::ConstantExpr::getSDiv</code>.</p></div></div><div class="odoc-spec"><div class="spec value" id="val-const_exact_sdiv" class="anchored"><a href="#val-const_exact_sdiv" class="anchor"></a><code><span><span class="keyword">val</span> const_exact_sdiv : <span><a href="#type-llvalue">llvalue</a> <span class="arrow">&#45;&gt;</span></span> <span><a href="#type-llvalue">llvalue</a> <span class="arrow">&#45;&gt;</span></span> <a href="#type-llvalue">llvalue</a></span></code></div><div class="spec-doc"><p><code>const_exact_sdiv c1 c2</code> returns the constant quotient <code>c1 / c2</code> of two signed integer constants. The result is undefined if the result is rounded or overflows. See the method <code>llvm::ConstantExpr::getExactSDiv</code>.</p></div></div><div class="odoc-spec"><div class="spec value" id="val-const_fdiv" class="anchored"><a href="#val-const_fdiv" class="anchor"></a><code><span><span class="keyword">val</span> const_fdiv : <span><a href="#type-llvalue">llvalue</a> <span class="arrow">&#45;&gt;</span></span> <span><a href="#type-llvalue">llvalue</a> <span class="arrow">&#45;&gt;</span></span> <a href="#type-llvalue">llvalue</a></span></code></div><div class="spec-doc"><p><code>const_fdiv c1 c2</code> returns the constant quotient <code>c1 / c2</code> of two floating point constants. See the method <code>llvm::ConstantExpr::getFDiv</code>.</p></div></div><div class="odoc-spec"><div class="spec value" id="val-const_urem" class="anchored"><a href="#val-const_urem" class="anchor"></a><code><span><span class="keyword">val</span> const_urem : <span><a href="#type-llvalue">llvalue</a> <span class="arrow">&#45;&gt;</span></span> <span><a href="#type-llvalue">llvalue</a> <span class="arrow">&#45;&gt;</span></span> <a href="#type-llvalue">llvalue</a></span></code></div><div class="spec-doc"><p><code>const_urem c1 c2</code> returns the constant remainder <code>c1 MOD c2</code> of two unsigned integer constants. See the method <code>llvm::ConstantExpr::getURem</code>.</p></div></div><div class="odoc-spec"><div class="spec value" id="val-const_srem" class="anchored"><a href="#val-const_srem" class="anchor"></a><code><span><span class="keyword">val</span> const_srem : <span><a href="#type-llvalue">llvalue</a> <span class="arrow">&#45;&gt;</span></span> <span><a href="#type-llvalue">llvalue</a> <span class="arrow">&#45;&gt;</span></span> <a href="#type-llvalue">llvalue</a></span></code></div><div class="spec-doc"><p><code>const_srem c1 c2</code> returns the constant remainder <code>c1 MOD c2</code> of two signed integer constants. See the method <code>llvm::ConstantExpr::getSRem</code>.</p></div></div><div class="odoc-spec"><div class="spec value" id="val-const_frem" class="anchored"><a href="#val-const_frem" class="anchor"></a><code><span><span class="keyword">val</span> const_frem : <span><a href="#type-llvalue">llvalue</a> <span class="arrow">&#45;&gt;</span></span> <span><a href="#type-llvalue">llvalue</a> <span class="arrow">&#45;&gt;</span></span> <a href="#type-llvalue">llvalue</a></span></code></div><div class="spec-doc"><p><code>const_frem c1 c2</code> returns the constant remainder <code>c1 MOD c2</code> of two signed floating point constants. See the method <code>llvm::ConstantExpr::getFRem</code>.</p></div></div><div class="odoc-spec"><div class="spec value" id="val-const_and" class="anchored"><a href="#val-const_and" class="anchor"></a><code><span><span class="keyword">val</span> const_and : <span><a href="#type-llvalue">llvalue</a> <span class="arrow">&#45;&gt;</span></span> <span><a href="#type-llvalue">llvalue</a> <span class="arrow">&#45;&gt;</span></span> <a href="#type-llvalue">llvalue</a></span></code></div><div class="spec-doc"><p><code>const_and c1 c2</code> returns the constant bitwise <code>AND</code> of two integer constants. See the method <code>llvm::ConstantExpr::getAnd</code>.</p></div></div><div class="odoc-spec"><div class="spec value" id="val-const_or" class="anchored"><a href="#val-const_or" class="anchor"></a><code><span><span class="keyword">val</span> const_or : <span><a href="#type-llvalue">llvalue</a> <span class="arrow">&#45;&gt;</span></span> <span><a href="#type-llvalue">llvalue</a> <span class="arrow">&#45;&gt;</span></span> <a href="#type-llvalue">llvalue</a></span></code></div><div class="spec-doc"><p><code>const_or c1 c2</code> returns the constant bitwise <code>OR</code> of two integer constants. See the method <code>llvm::ConstantExpr::getOr</code>.</p></div></div><div class="odoc-spec"><div class="spec value" id="val-const_xor" class="anchored"><a href="#val-const_xor" class="anchor"></a><code><span><span class="keyword">val</span> const_xor : <span><a href="#type-llvalue">llvalue</a> <span class="arrow">&#45;&gt;</span></span> <span><a href="#type-llvalue">llvalue</a> <span class="arrow">&#45;&gt;</span></span> <a href="#type-llvalue">llvalue</a></span></code></div><div class="spec-doc"><p><code>const_xor c1 c2</code> returns the constant bitwise <code>XOR</code> of two integer constants. See the method <code>llvm::ConstantExpr::getXor</code>.</p></div></div><div class="odoc-spec"><div class="spec value" id="val-const_icmp" class="anchored"><a href="#val-const_icmp" class="anchor"></a><code><span><span class="keyword">val</span> const_icmp : <span><a href="Icmp/index.html#type-t">Icmp.t</a> <span class="arrow">&#45;&gt;</span></span> <span><a href="#type-llvalue">llvalue</a> <span class="arrow">&#45;&gt;</span></span> <span><a href="#type-llvalue">llvalue</a> <span class="arrow">&#45;&gt;</span></span> <a href="#type-llvalue">llvalue</a></span></code></div><div class="spec-doc"><p><code>const_icmp pred c1 c2</code> returns the constant comparison of two integer constants, <code>c1 pred c2</code>. See the method <code>llvm::ConstantExpr::getICmp</code>.</p></div></div><div class="odoc-spec"><div class="spec value" id="val-const_fcmp" class="anchored"><a href="#val-const_fcmp" class="anchor"></a><code><span><span class="keyword">val</span> const_fcmp : <span><a href="Fcmp/index.html#type-t">Fcmp.t</a> <span class="arrow">&#45;&gt;</span></span> <span><a href="#type-llvalue">llvalue</a> <span class="arrow">&#45;&gt;</span></span> <span><a href="#type-llvalue">llvalue</a> <span class="arrow">&#45;&gt;</span></span> <a href="#type-llvalue">llvalue</a></span></code></div><div class="spec-doc"><p><code>const_fcmp pred c1 c2</code> returns the constant comparison of two floating point constants, <code>c1 pred c2</code>. See the method <code>llvm::ConstantExpr::getFCmp</code>.</p></div></div><div class="odoc-spec"><div class="spec value" id="val-const_shl" class="anchored"><a href="#val-const_shl" class="anchor"></a><code><span><span class="keyword">val</span> const_shl : <span><a href="#type-llvalue">llvalue</a> <span class="arrow">&#45;&gt;</span></span> <span><a href="#type-llvalue">llvalue</a> <span class="arrow">&#45;&gt;</span></span> <a href="#type-llvalue">llvalue</a></span></code></div><div class="spec-doc"><p><code>const_shl c1 c2</code> returns the constant integer <code>c1</code> left-shifted by the constant integer <code>c2</code>. See the method <code>llvm::ConstantExpr::getShl</code>.</p></div></div><div class="odoc-spec"><div class="spec value" id="val-const_lshr" class="anchored"><a href="#val-const_lshr" class="anchor"></a><code><span><span class="keyword">val</span> const_lshr : <span><a href="#type-llvalue">llvalue</a> <span class="arrow">&#45;&gt;</span></span> <span><a href="#type-llvalue">llvalue</a> <span class="arrow">&#45;&gt;</span></span> <a href="#type-llvalue">llvalue</a></span></code></div><div class="spec-doc"><p><code>const_lshr c1 c2</code> returns the constant integer <code>c1</code> right-shifted by the constant integer <code>c2</code> with zero extension. See the method <code>llvm::ConstantExpr::getLShr</code>.</p></div></div><div class="odoc-spec"><div class="spec value" id="val-const_ashr" class="anchored"><a href="#val-const_ashr" class="anchor"></a><code><span><span class="keyword">val</span> const_ashr : <span><a href="#type-llvalue">llvalue</a> <span class="arrow">&#45;&gt;</span></span> <span><a href="#type-llvalue">llvalue</a> <span class="arrow">&#45;&gt;</span></span> <a href="#type-llvalue">llvalue</a></span></code></div><div class="spec-doc"><p><code>const_ashr c1 c2</code> returns the constant integer <code>c1</code> right-shifted by the constant integer <code>c2</code> with sign extension. See the method <code>llvm::ConstantExpr::getAShr</code>.</p></div></div><div class="odoc-spec"><div class="spec value" id="val-const_gep" class="anchored"><a href="#val-const_gep" class="anchor"></a><code><span><span class="keyword">val</span> const_gep : <span><a href="#type-llvalue">llvalue</a> <span class="arrow">&#45;&gt;</span></span> <span><span><a href="#type-llvalue">llvalue</a> array</span> <span class="arrow">&#45;&gt;</span></span> <a href="#type-llvalue">llvalue</a></span></code></div><div class="spec-doc"><p><code>const_gep pc indices</code> returns the constant <code>getElementPtr</code> of <code>pc</code> with the constant integers indices from the array <code>indices</code>. See the method <code>llvm::ConstantExpr::getGetElementPtr</code>.</p></div></div><div class="odoc-spec"><div class="spec value" id="val-const_in_bounds_gep" class="anchored"><a href="#val-const_in_bounds_gep" class="anchor"></a><code><span><span class="keyword">val</span> const_in_bounds_gep : <span><a href="#type-llvalue">llvalue</a> <span class="arrow">&#45;&gt;</span></span> <span><span><a href="#type-llvalue">llvalue</a> array</span> <span class="arrow">&#45;&gt;</span></span> <a href="#type-llvalue">llvalue</a></span></code></div><div class="spec-doc"><p><code>const_in_bounds_gep pc indices</code> returns the constant <code>getElementPtr</code> of <code>pc</code> with the constant integers indices from the array <code>indices</code>. See the method <code>llvm::ConstantExpr::getInBoundsGetElementPtr</code>.</p></div></div><div class="odoc-spec"><div class="spec value" id="val-const_trunc" class="anchored"><a href="#val-const_trunc" class="anchor"></a><code><span><span class="keyword">val</span> const_trunc : <span><a href="#type-llvalue">llvalue</a> <span class="arrow">&#45;&gt;</span></span> <span><a href="#type-lltype">lltype</a> <span class="arrow">&#45;&gt;</span></span> <a href="#type-llvalue">llvalue</a></span></code></div><div class="spec-doc"><p><code>const_trunc c ty</code> returns the constant truncation of integer constant <code>c</code> to the smaller integer type <code>ty</code>. See the method <code>llvm::ConstantExpr::getTrunc</code>.</p></div></div><div class="odoc-spec"><div class="spec value" id="val-const_sext" class="anchored"><a href="#val-const_sext" class="anchor"></a><code><span><span class="keyword">val</span> const_sext : <span><a href="#type-llvalue">llvalue</a> <span class="arrow">&#45;&gt;</span></span> <span><a href="#type-lltype">lltype</a> <span class="arrow">&#45;&gt;</span></span> <a href="#type-llvalue">llvalue</a></span></code></div><div class="spec-doc"><p><code>const_sext c ty</code> returns the constant sign extension of integer constant <code>c</code> to the larger integer type <code>ty</code>. See the method <code>llvm::ConstantExpr::getSExt</code>.</p></div></div><div class="odoc-spec"><div class="spec value" id="val-const_zext" class="anchored"><a href="#val-const_zext" class="anchor"></a><code><span><span class="keyword">val</span> const_zext : <span><a href="#type-llvalue">llvalue</a> <span class="arrow">&#45;&gt;</span></span> <span><a href="#type-lltype">lltype</a> <span class="arrow">&#45;&gt;</span></span> <a href="#type-llvalue">llvalue</a></span></code></div><div class="spec-doc"><p><code>const_zext c ty</code> returns the constant zero extension of integer constant <code>c</code> to the larger integer type <code>ty</code>. See the method <code>llvm::ConstantExpr::getZExt</code>.</p></div></div><div class="odoc-spec"><div class="spec value" id="val-const_fptrunc" class="anchored"><a href="#val-const_fptrunc" class="anchor"></a><code><span><span class="keyword">val</span> const_fptrunc : <span><a href="#type-llvalue">llvalue</a> <span class="arrow">&#45;&gt;</span></span> <span><a href="#type-lltype">lltype</a> <span class="arrow">&#45;&gt;</span></span> <a href="#type-llvalue">llvalue</a></span></code></div><div class="spec-doc"><p><code>const_fptrunc c ty</code> returns the constant truncation of floating point constant <code>c</code> to the smaller floating point type <code>ty</code>. See the method <code>llvm::ConstantExpr::getFPTrunc</code>.</p></div></div><div class="odoc-spec"><div class="spec value" id="val-const_fpext" class="anchored"><a href="#val-const_fpext" class="anchor"></a><code><span><span class="keyword">val</span> const_fpext : <span><a href="#type-llvalue">llvalue</a> <span class="arrow">&#45;&gt;</span></span> <span><a href="#type-lltype">lltype</a> <span class="arrow">&#45;&gt;</span></span> <a href="#type-llvalue">llvalue</a></span></code></div><div class="spec-doc"><p><code>const_fpext c ty</code> returns the constant extension of floating point constant <code>c</code> to the larger floating point type <code>ty</code>. See the method <code>llvm::ConstantExpr::getFPExt</code>.</p></div></div><div class="odoc-spec"><div class="spec value" id="val-const_uitofp" class="anchored"><a href="#val-const_uitofp" class="anchor"></a><code><span><span class="keyword">val</span> const_uitofp : <span><a href="#type-llvalue">llvalue</a> <span class="arrow">&#45;&gt;</span></span> <span><a href="#type-lltype">lltype</a> <span class="arrow">&#45;&gt;</span></span> <a href="#type-llvalue">llvalue</a></span></code></div><div class="spec-doc"><p><code>const_uitofp c ty</code> returns the constant floating point conversion of unsigned integer constant <code>c</code> to the floating point type <code>ty</code>. See the method <code>llvm::ConstantExpr::getUIToFP</code>.</p></div></div><div class="odoc-spec"><div class="spec value" id="val-const_sitofp" class="anchored"><a href="#val-const_sitofp" class="anchor"></a><code><span><span class="keyword">val</span> const_sitofp : <span><a href="#type-llvalue">llvalue</a> <span class="arrow">&#45;&gt;</span></span> <span><a href="#type-lltype">lltype</a> <span class="arrow">&#45;&gt;</span></span> <a href="#type-llvalue">llvalue</a></span></code></div><div class="spec-doc"><p><code>const_sitofp c ty</code> returns the constant floating point conversion of signed integer constant <code>c</code> to the floating point type <code>ty</code>. See the method <code>llvm::ConstantExpr::getSIToFP</code>.</p></div></div><div class="odoc-spec"><div class="spec value" id="val-const_fptoui" class="anchored"><a href="#val-const_fptoui" class="anchor"></a><code><span><span class="keyword">val</span> const_fptoui : <span><a href="#type-llvalue">llvalue</a> <span class="arrow">&#45;&gt;</span></span> <span><a href="#type-lltype">lltype</a> <span class="arrow">&#45;&gt;</span></span> <a href="#type-llvalue">llvalue</a></span></code></div><div class="spec-doc"><p><code>const_fptoui c ty</code> returns the constant unsigned integer conversion of floating point constant <code>c</code> to integer type <code>ty</code>. See the method <code>llvm::ConstantExpr::getFPToUI</code>.</p></div></div><div class="odoc-spec"><div class="spec value" id="val-const_fptosi" class="anchored"><a href="#val-const_fptosi" class="anchor"></a><code><span><span class="keyword">val</span> const_fptosi : <span><a href="#type-llvalue">llvalue</a> <span class="arrow">&#45;&gt;</span></span> <span><a href="#type-lltype">lltype</a> <span class="arrow">&#45;&gt;</span></span> <a href="#type-llvalue">llvalue</a></span></code></div><div class="spec-doc"><p><code>const_fptoui c ty</code> returns the constant unsigned integer conversion of floating point constant <code>c</code> to integer type <code>ty</code>. See the method <code>llvm::ConstantExpr::getFPToSI</code>.</p></div></div><div class="odoc-spec"><div class="spec value" id="val-const_ptrtoint" class="anchored"><a href="#val-const_ptrtoint" class="anchor"></a><code><span><span class="keyword">val</span> const_ptrtoint : <span><a href="#type-llvalue">llvalue</a> <span class="arrow">&#45;&gt;</span></span> <span><a href="#type-lltype">lltype</a> <span class="arrow">&#45;&gt;</span></span> <a href="#type-llvalue">llvalue</a></span></code></div><div class="spec-doc"><p><code>const_ptrtoint c ty</code> returns the constant integer conversion of pointer constant <code>c</code> to integer type <code>ty</code>. See the method <code>llvm::ConstantExpr::getPtrToInt</code>.</p></div></div><div class="odoc-spec"><div class="spec value" id="val-const_inttoptr" class="anchored"><a href="#val-const_inttoptr" class="anchor"></a><code><span><span class="keyword">val</span> const_inttoptr : <span><a href="#type-llvalue">llvalue</a> <span class="arrow">&#45;&gt;</span></span> <span><a href="#type-lltype">lltype</a> <span class="arrow">&#45;&gt;</span></span> <a href="#type-llvalue">llvalue</a></span></code></div><div class="spec-doc"><p><code>const_inttoptr c ty</code> returns the constant pointer conversion of integer constant <code>c</code> to pointer type <code>ty</code>. See the method <code>llvm::ConstantExpr::getIntToPtr</code>.</p></div></div><div class="odoc-spec"><div class="spec value" id="val-const_bitcast" class="anchored"><a href="#val-const_bitcast" class="anchor"></a><code><span><span class="keyword">val</span> const_bitcast : <span><a href="#type-llvalue">llvalue</a> <span class="arrow">&#45;&gt;</span></span> <span><a href="#type-lltype">lltype</a> <span class="arrow">&#45;&gt;</span></span> <a href="#type-llvalue">llvalue</a></span></code></div><div class="spec-doc"><p><code>const_bitcast c ty</code> returns the constant bitwise conversion of constant <code>c</code> to type <code>ty</code> of equal size. See the method <code>llvm::ConstantExpr::getBitCast</code>.</p></div></div><div class="odoc-spec"><div class="spec value" id="val-const_zext_or_bitcast" class="anchored"><a href="#val-const_zext_or_bitcast" class="anchor"></a><code><span><span class="keyword">val</span> const_zext_or_bitcast : <span><a href="#type-llvalue">llvalue</a> <span class="arrow">&#45;&gt;</span></span> <span><a href="#type-lltype">lltype</a> <span class="arrow">&#45;&gt;</span></span> <a href="#type-llvalue">llvalue</a></span></code></div><div class="spec-doc"><p><code>const_zext_or_bitcast c ty</code> returns a constant zext or bitwise cast conversion of constant <code>c</code> to type <code>ty</code>. See the method <code>llvm::ConstantExpr::getZExtOrBitCast</code>.</p></div></div><div class="odoc-spec"><div class="spec value" id="val-const_sext_or_bitcast" class="anchored"><a href="#val-const_sext_or_bitcast" class="anchor"></a><code><span><span class="keyword">val</span> const_sext_or_bitcast : <span><a href="#type-llvalue">llvalue</a> <span class="arrow">&#45;&gt;</span></span> <span><a href="#type-lltype">lltype</a> <span class="arrow">&#45;&gt;</span></span> <a href="#type-llvalue">llvalue</a></span></code></div><div class="spec-doc"><p><code>const_sext_or_bitcast c ty</code> returns a constant sext or bitwise cast conversion of constant <code>c</code> to type <code>ty</code>. See the method <code>llvm::ConstantExpr::getSExtOrBitCast</code>.</p></div></div><div class="odoc-spec"><div class="spec value" id="val-const_trunc_or_bitcast" class="anchored"><a href="#val-const_trunc_or_bitcast" class="anchor"></a><code><span><span class="keyword">val</span> const_trunc_or_bitcast : <span><a href="#type-llvalue">llvalue</a> <span class="arrow">&#45;&gt;</span></span> <span><a href="#type-lltype">lltype</a> <span class="arrow">&#45;&gt;</span></span> <a href="#type-llvalue">llvalue</a></span></code></div><div class="spec-doc"><p><code>const_trunc_or_bitcast c ty</code> returns a constant trunc or bitwise cast conversion of constant <code>c</code> to type <code>ty</code>. See the method <code>llvm::ConstantExpr::getTruncOrBitCast</code>.</p></div></div><div class="odoc-spec"><div class="spec value" id="val-const_pointercast" class="anchored"><a href="#val-const_pointercast" class="anchor"></a><code><span><span class="keyword">val</span> const_pointercast : <span><a href="#type-llvalue">llvalue</a> <span class="arrow">&#45;&gt;</span></span> <span><a href="#type-lltype">lltype</a> <span class="arrow">&#45;&gt;</span></span> <a href="#type-llvalue">llvalue</a></span></code></div><div class="spec-doc"><p><code>const_pointercast c ty</code> returns a constant bitcast or a pointer-to-int cast conversion of constant <code>c</code> to type <code>ty</code> of equal size. See the method <code>llvm::ConstantExpr::getPointerCast</code>.</p></div></div><div class="odoc-spec"><div class="spec value" id="val-const_intcast" class="anchored"><a href="#val-const_intcast" class="anchor"></a><code><span><span class="keyword">val</span> const_intcast : <span><a href="#type-llvalue">llvalue</a> <span class="arrow">&#45;&gt;</span></span> <span><a href="#type-lltype">lltype</a> <span class="arrow">&#45;&gt;</span></span> <span>is_signed:bool <span class="arrow">&#45;&gt;</span></span> <a href="#type-llvalue">llvalue</a></span></code></div><div class="spec-doc"><p><code>const_intcast c ty ~is_signed</code> returns a constant sext/zext, bitcast, or trunc for integer -&gt; integer casts of constant <code>c</code> to type <code>ty</code>. When converting a narrower value to a wider one, whether sext or zext will be used is controlled by <code>is_signed</code>. See the method <code>llvm::ConstantExpr::getIntegerCast</code>.</p></div></div><div class="odoc-spec"><div class="spec value" id="val-const_fpcast" class="anchored"><a href="#val-const_fpcast" class="anchor"></a><code><span><span class="keyword">val</span> const_fpcast : <span><a href="#type-llvalue">llvalue</a> <span class="arrow">&#45;&gt;</span></span> <span><a href="#type-lltype">lltype</a> <span class="arrow">&#45;&gt;</span></span> <a href="#type-llvalue">llvalue</a></span></code></div><div class="spec-doc"><p><code>const_fpcast c ty</code> returns a constant fpext, bitcast, or fptrunc for fp -&gt; fp casts of constant <code>c</code> to type <code>ty</code>. See the method <code>llvm::ConstantExpr::getFPCast</code>.</p></div></div><div class="odoc-spec"><div class="spec value" id="val-const_select" class="anchored"><a href="#val-const_select" class="anchor"></a><code><span><span class="keyword">val</span> const_select : <span><a href="#type-llvalue">llvalue</a> <span class="arrow">&#45;&gt;</span></span> <span><a href="#type-llvalue">llvalue</a> <span class="arrow">&#45;&gt;</span></span> <span><a href="#type-llvalue">llvalue</a> <span class="arrow">&#45;&gt;</span></span> <a href="#type-llvalue">llvalue</a></span></code></div><div class="spec-doc"><p><code>const_select cond t f</code> returns the constant conditional which returns value <code>t</code> if the boolean constant <code>cond</code> is true and the value <code>f</code> otherwise. See the method <code>llvm::ConstantExpr::getSelect</code>.</p></div></div><div class="odoc-spec"><div class="spec value" id="val-const_extractelement" class="anchored"><a href="#val-const_extractelement" class="anchor"></a><code><span><span class="keyword">val</span> const_extractelement : <span><a href="#type-llvalue">llvalue</a> <span class="arrow">&#45;&gt;</span></span> <span><a href="#type-llvalue">llvalue</a> <span class="arrow">&#45;&gt;</span></span> <a href="#type-llvalue">llvalue</a></span></code></div><div class="spec-doc"><p><code>const_extractelement vec i</code> returns the constant <code>i</code>th element of constant vector <code>vec</code>. <code>i</code> must be a constant <code>i32</code> value unsigned less than the size of the vector. See the method <code>llvm::ConstantExpr::getExtractElement</code>.</p></div></div><div class="odoc-spec"><div class="spec value" id="val-const_insertelement" class="anchored"><a href="#val-const_insertelement" class="anchor"></a><code><span><span class="keyword">val</span> const_insertelement : <span><a href="#type-llvalue">llvalue</a> <span class="arrow">&#45;&gt;</span></span> <span><a href="#type-llvalue">llvalue</a> <span class="arrow">&#45;&gt;</span></span> <span><a href="#type-llvalue">llvalue</a> <span class="arrow">&#45;&gt;</span></span> <a href="#type-llvalue">llvalue</a></span></code></div><div class="spec-doc"><p><code>const_insertelement vec v i</code> returns the constant vector with the same elements as constant vector <code>v</code> but the <code>i</code>th element replaced by the constant <code>v</code>. <code>v</code> must be a constant value with the type of the vector elements. <code>i</code> must be a constant <code>i32</code> value unsigned less than the size of the vector. See the method <code>llvm::ConstantExpr::getInsertElement</code>.</p></div></div><div class="odoc-spec"><div class="spec value" id="val-const_shufflevector" class="anchored"><a href="#val-const_shufflevector" class="anchor"></a><code><span><span class="keyword">val</span> const_shufflevector : <span><a href="#type-llvalue">llvalue</a> <span class="arrow">&#45;&gt;</span></span> <span><a href="#type-llvalue">llvalue</a> <span class="arrow">&#45;&gt;</span></span> <span><a href="#type-llvalue">llvalue</a> <span class="arrow">&#45;&gt;</span></span> <a href="#type-llvalue">llvalue</a></span></code></div><div class="spec-doc"><p><code>const_shufflevector a b mask</code> returns a constant <code>shufflevector</code>. See the LLVM Language Reference for details on the <code>shufflevector</code> instruction. See the method <code>llvm::ConstantExpr::getShuffleVector</code>.</p></div></div><div class="odoc-spec"><div class="spec value" id="val-const_extractvalue" class="anchored"><a href="#val-const_extractvalue" class="anchor"></a><code><span><span class="keyword">val</span> const_extractvalue : <span><a href="#type-llvalue">llvalue</a> <span class="arrow">&#45;&gt;</span></span> <span><span>int array</span> <span class="arrow">&#45;&gt;</span></span> <a href="#type-llvalue">llvalue</a></span></code></div><div class="spec-doc"><p><code>const_extractvalue agg idxs</code> returns the constant <code>idxs</code>th value of constant aggregate <code>agg</code>. Each <code>idxs</code> must be less than the size of the aggregate. See the method <code>llvm::ConstantExpr::getExtractValue</code>.</p></div></div><div class="odoc-spec"><div class="spec value" id="val-const_insertvalue" class="anchored"><a href="#val-const_insertvalue" class="anchor"></a><code><span><span class="keyword">val</span> const_insertvalue : <span><a href="#type-llvalue">llvalue</a> <span class="arrow">&#45;&gt;</span></span> <span><a href="#type-llvalue">llvalue</a> <span class="arrow">&#45;&gt;</span></span> <span><span>int array</span> <span class="arrow">&#45;&gt;</span></span> <a href="#type-llvalue">llvalue</a></span></code></div><div class="spec-doc"><p><code>const_insertvalue agg val idxs</code> inserts the value <code>val</code> in the specified indexs <code>idxs</code> in the aggregate <code>agg</code>. Each <code>idxs</code> must be less than the size of the aggregate. See the method <code>llvm::ConstantExpr::getInsertValue</code>.</p></div></div><div class="odoc-spec"><div class="spec value" id="val-const_inline_asm" class="anchored"><a href="#val-const_inline_asm" class="anchor"></a><code><span><span class="keyword">val</span> const_inline_asm : <span><a href="#type-lltype">lltype</a> <span class="arrow">&#45;&gt;</span></span> <span>string <span class="arrow">&#45;&gt;</span></span> <span>string <span class="arrow">&#45;&gt;</span></span> <span>bool <span class="arrow">&#45;&gt;</span></span> <span>bool <span class="arrow">&#45;&gt;</span></span> <a href="#type-llvalue">llvalue</a></span></code></div><div class="spec-doc"><p><code>const_inline_asm ty asm con side align</code> inserts a inline assembly string. See the method <code>llvm::InlineAsm::get</code>.</p></div></div><div class="odoc-spec"><div class="spec value" id="val-block_address" class="anchored"><a href="#val-block_address" class="anchor"></a><code><span><span class="keyword">val</span> block_address : <span><a href="#type-llvalue">llvalue</a> <span class="arrow">&#45;&gt;</span></span> <span><a href="#type-llbasicblock">llbasicblock</a> <span class="arrow">&#45;&gt;</span></span> <a href="#type-llvalue">llvalue</a></span></code></div><div class="spec-doc"><p><code>block_address f bb</code> returns the address of the basic block <code>bb</code> in the function <code>f</code>. See the method <code>llvm::BasicBlock::get</code>.</p></div></div><h6 id="operations-on-global-variables,-functions,-and-aliases-(globals)"><a href="#operations-on-global-variables,-functions,-and-aliases-(globals)" class="anchor"></a>Operations on global variables, functions, and aliases (globals)</h6><div class="odoc-spec"><div class="spec value" id="val-global_parent" class="anchored"><a href="#val-global_parent" class="anchor"></a><code><span><span class="keyword">val</span> global_parent : <span><a href="#type-llvalue">llvalue</a> <span class="arrow">&#45;&gt;</span></span> <a href="#type-llmodule">llmodule</a></span></code></div><div class="spec-doc"><p><code>global_parent g</code> is the enclosing module of the global value <code>g</code>. See the method <code>llvm::GlobalValue::getParent</code>.</p></div></div><div class="odoc-spec"><div class="spec value" id="val-is_declaration" class="anchored"><a href="#val-is_declaration" class="anchor"></a><code><span><span class="keyword">val</span> is_declaration : <span><a href="#type-llvalue">llvalue</a> <span class="arrow">&#45;&gt;</span></span> bool</span></code></div><div class="spec-doc"><p><code>is_declaration g</code> returns <code>true</code> if the global value <code>g</code> is a declaration only. Returns <code>false</code> otherwise. See the method <code>llvm::GlobalValue::isDeclaration</code>.</p></div></div><div class="odoc-spec"><div class="spec value" id="val-linkage" class="anchored"><a href="#val-linkage" class="anchor"></a><code><span><span class="keyword">val</span> linkage : <span><a href="#type-llvalue">llvalue</a> <span class="arrow">&#45;&gt;</span></span> <a href="Linkage/index.html#type-t">Linkage.t</a></span></code></div><div class="spec-doc"><p><code>linkage g</code> returns the linkage of the global value <code>g</code>. See the method <code>llvm::GlobalValue::getLinkage</code>.</p></div></div><div class="odoc-spec"><div class="spec value" id="val-set_linkage" class="anchored"><a href="#val-set_linkage" class="anchor"></a><code><span><span class="keyword">val</span> set_linkage : <span><a href="Linkage/index.html#type-t">Linkage.t</a> <span class="arrow">&#45;&gt;</span></span> <span><a href="#type-llvalue">llvalue</a> <span class="arrow">&#45;&gt;</span></span> unit</span></code></div><div class="spec-doc"><p><code>set_linkage l g</code> sets the linkage of the global value <code>g</code> to <code>l</code>. See the method <code>llvm::GlobalValue::setLinkage</code>.</p></div></div><div class="odoc-spec"><div class="spec value" id="val-unnamed_addr" class="anchored"><a href="#val-unnamed_addr" class="anchor"></a><code><span><span class="keyword">val</span> unnamed_addr : <span><a href="#type-llvalue">llvalue</a> <span class="arrow">&#45;&gt;</span></span> bool</span></code></div><div class="spec-doc"><p><code>unnamed_addr g</code> returns <code>true</code> if the global value <code>g</code> has the unnamed_addr attribute. Returns <code>false</code> otherwise. See the method <code>llvm::GlobalValue::getUnnamedAddr</code>.</p></div></div><div class="odoc-spec"><div class="spec value" id="val-set_unnamed_addr" class="anchored"><a href="#val-set_unnamed_addr" class="anchor"></a><code><span><span class="keyword">val</span> set_unnamed_addr : <span>bool <span class="arrow">&#45;&gt;</span></span> <span><a href="#type-llvalue">llvalue</a> <span class="arrow">&#45;&gt;</span></span> unit</span></code></div><div class="spec-doc"><p><code>set_unnamed_addr b g</code> if <code>b</code> is <code>true</code>, sets the unnamed_addr attribute of the global value <code>g</code>. Unset it otherwise. See the method <code>llvm::GlobalValue::setUnnamedAddr</code>.</p></div></div><div class="odoc-spec"><div class="spec value" id="val-section" class="anchored"><a href="#val-section" class="anchor"></a><code><span><span class="keyword">val</span> section : <span><a href="#type-llvalue">llvalue</a> <span class="arrow">&#45;&gt;</span></span> string</span></code></div><div class="spec-doc"><p><code>section g</code> returns the linker section of the global value <code>g</code>. See the method <code>llvm::GlobalValue::getSection</code>.</p></div></div><div class="odoc-spec"><div class="spec value" id="val-set_section" class="anchored"><a href="#val-set_section" class="anchor"></a><code><span><span class="keyword">val</span> set_section : <span>string <span class="arrow">&#45;&gt;</span></span> <span><a href="#type-llvalue">llvalue</a> <span class="arrow">&#45;&gt;</span></span> unit</span></code></div><div class="spec-doc"><p><code>set_section s g</code> sets the linker section of the global value <code>g</code> to <code>s</code>. See the method <code>llvm::GlobalValue::setSection</code>.</p></div></div><div class="odoc-spec"><div class="spec value" id="val-visibility" class="anchored"><a href="#val-visibility" class="anchor"></a><code><span><span class="keyword">val</span> visibility : <span><a href="#type-llvalue">llvalue</a> <span class="arrow">&#45;&gt;</span></span> <a href="Visibility/index.html#type-t">Visibility.t</a></span></code></div><div class="spec-doc"><p><code>visibility g</code> returns the linker visibility of the global value <code>g</code>. See the method <code>llvm::GlobalValue::getVisibility</code>.</p></div></div><div class="odoc-spec"><div class="spec value" id="val-set_visibility" class="anchored"><a href="#val-set_visibility" class="anchor"></a><code><span><span class="keyword">val</span> set_visibility : <span><a href="Visibility/index.html#type-t">Visibility.t</a> <span class="arrow">&#45;&gt;</span></span> <span><a href="#type-llvalue">llvalue</a> <span class="arrow">&#45;&gt;</span></span> unit</span></code></div><div class="spec-doc"><p><code>set_visibility v g</code> sets the linker visibility of the global value <code>g</code> to <code>v</code>. See the method <code>llvm::GlobalValue::setVisibility</code>.</p></div></div><div class="odoc-spec"><div class="spec value" id="val-dll_storage_class" class="anchored"><a href="#val-dll_storage_class" class="anchor"></a><code><span><span class="keyword">val</span> dll_storage_class : <span><a href="#type-llvalue">llvalue</a> <span class="arrow">&#45;&gt;</span></span> <a href="DLLStorageClass/index.html#type-t">DLLStorageClass.t</a></span></code></div><div class="spec-doc"><p><code>dll_storage_class g</code> returns the DLL storage class of the global value <code>g</code>. See the method <code>llvm::GlobalValue::getDLLStorageClass</code>.</p></div></div><div class="odoc-spec"><div class="spec value" id="val-set_dll_storage_class" class="anchored"><a href="#val-set_dll_storage_class" class="anchor"></a><code><span><span class="keyword">val</span> set_dll_storage_class : <span><a href="DLLStorageClass/index.html#type-t">DLLStorageClass.t</a> <span class="arrow">&#45;&gt;</span></span> <span><a href="#type-llvalue">llvalue</a> <span class="arrow">&#45;&gt;</span></span> unit</span></code></div><div class="spec-doc"><p><code>set_dll_storage_class v g</code> sets the DLL storage class of the global value <code>g</code> to <code>v</code>. See the method <code>llvm::GlobalValue::setDLLStorageClass</code>.</p></div></div><div class="odoc-spec"><div class="spec value" id="val-alignment" class="anchored"><a href="#val-alignment" class="anchor"></a><code><span><span class="keyword">val</span> alignment : <span><a href="#type-llvalue">llvalue</a> <span class="arrow">&#45;&gt;</span></span> int</span></code></div><div class="spec-doc"><p><code>alignment g</code> returns the required alignment of the global value <code>g</code>. See the method <code>llvm::GlobalValue::getAlignment</code>.</p></div></div><div class="odoc-spec"><div class="spec value" id="val-set_alignment" class="anchored"><a href="#val-set_alignment" class="anchor"></a><code><span><span class="keyword">val</span> set_alignment : <span>int <span class="arrow">&#45;&gt;</span></span> <span><a href="#type-llvalue">llvalue</a> <span class="arrow">&#45;&gt;</span></span> unit</span></code></div><div class="spec-doc"><p><code>set_alignment n g</code> sets the required alignment of the global value <code>g</code> to <code>n</code> bytes. See the method <code>llvm::GlobalValue::setAlignment</code>.</p></div></div><div class="odoc-spec"><div class="spec value" id="val-global_copy_all_metadata" class="anchored"><a href="#val-global_copy_all_metadata" class="anchor"></a><code><span><span class="keyword">val</span> global_copy_all_metadata : <span><a href="#type-llvalue">llvalue</a> <span class="arrow">&#45;&gt;</span></span> <span><span>(<a href="#type-llmdkind">llmdkind</a> * <a href="#type-llmetadata">llmetadata</a>)</span> array</span></span></code></div><div class="spec-doc"><p><code>global_copy_all_metadata g</code> returns all the metadata associated with <code>g</code>, which must be an <code>Instruction</code> or <code>GlobalObject</code>. See the <code>llvm::Instruction::getAllMetadata()</code> and <code>llvm::GlobalObject::getAllMetadata()</code> methods.</p></div></div><h6 id="operations-on-global-variables"><a href="#operations-on-global-variables" class="anchor"></a>Operations on global variables</h6><div class="odoc-spec"><div class="spec value" id="val-declare_global" class="anchored"><a href="#val-declare_global" class="anchor"></a><code><span><span class="keyword">val</span> declare_global : <span><a href="#type-lltype">lltype</a> <span class="arrow">&#45;&gt;</span></span> <span>string <span class="arrow">&#45;&gt;</span></span> <span><a href="#type-llmodule">llmodule</a> <span class="arrow">&#45;&gt;</span></span> <a href="#type-llvalue">llvalue</a></span></code></div><div class="spec-doc"><p><code>declare_global ty name m</code> returns a new global variable of type <code>ty</code> and with name <code>name</code> in module <code>m</code> in the default address space (0). If such a global variable already exists, it is returned. If the type of the existing global differs, then a bitcast to <code>ty</code> is returned.</p></div></div><div class="odoc-spec"><div class="spec value" id="val-declare_qualified_global" class="anchored"><a href="#val-declare_qualified_global" class="anchor"></a><code><span><span class="keyword">val</span> declare_qualified_global : <span><a href="#type-lltype">lltype</a> <span class="arrow">&#45;&gt;</span></span> <span>string <span class="arrow">&#45;&gt;</span></span> <span>int <span class="arrow">&#45;&gt;</span></span> <span><a href="#type-llmodule">llmodule</a> <span class="arrow">&#45;&gt;</span></span> <a href="#type-llvalue">llvalue</a></span></code></div><div class="spec-doc"><p><code>declare_qualified_global ty name addrspace m</code> returns a new global variable of type <code>ty</code> and with name <code>name</code> in module <code>m</code> in the address space <code>addrspace</code>. If such a global variable already exists, it is returned. If the type of the existing global differs, then a bitcast to <code>ty</code> is returned.</p></div></div><div class="odoc-spec"><div class="spec value" id="val-define_global" class="anchored"><a href="#val-define_global" class="anchor"></a><code><span><span class="keyword">val</span> define_global : <span>string <span class="arrow">&#45;&gt;</span></span> <span><a href="#type-llvalue">llvalue</a> <span class="arrow">&#45;&gt;</span></span> <span><a href="#type-llmodule">llmodule</a> <span class="arrow">&#45;&gt;</span></span> <a href="#type-llvalue">llvalue</a></span></code></div><div class="spec-doc"><p><code>define_global name init m</code> returns a new global with name <code>name</code> and initializer <code>init</code> in module <code>m</code> in the default address space (0). If the named global already exists, it is renamed. See the constructor of <code>llvm::GlobalVariable</code>.</p></div></div><div class="odoc-spec"><div class="spec value" id="val-define_qualified_global" class="anchored"><a href="#val-define_qualified_global" class="anchor"></a><code><span><span class="keyword">val</span> define_qualified_global : <span>string <span class="arrow">&#45;&gt;</span></span> <span><a href="#type-llvalue">llvalue</a> <span class="arrow">&#45;&gt;</span></span> <span>int <span class="arrow">&#45;&gt;</span></span> <span><a href="#type-llmodule">llmodule</a> <span class="arrow">&#45;&gt;</span></span> <a href="#type-llvalue">llvalue</a></span></code></div><div class="spec-doc"><p><code>define_qualified_global name init addrspace m</code> returns a new global with name <code>name</code> and initializer <code>init</code> in module <code>m</code> in the address space <code>addrspace</code>. If the named global already exists, it is renamed. See the constructor of <code>llvm::GlobalVariable</code>.</p></div></div><div class="odoc-spec"><div class="spec value" id="val-lookup_global" class="anchored"><a href="#val-lookup_global" class="anchor"></a><code><span><span class="keyword">val</span> lookup_global : <span>string <span class="arrow">&#45;&gt;</span></span> <span><a href="#type-llmodule">llmodule</a> <span class="arrow">&#45;&gt;</span></span> <span><a href="#type-llvalue">llvalue</a> option</span></span></code></div><div class="spec-doc"><p><code>lookup_global name m</code> returns <code>Some g</code> if a global variable with name <code>name</code> exists in module <code>m</code>. If no such global exists, returns <code>None</code>. See the <code>llvm::GlobalVariable</code> constructor.</p></div></div><div class="odoc-spec"><div class="spec value" id="val-delete_global" class="anchored"><a href="#val-delete_global" class="anchor"></a><code><span><span class="keyword">val</span> delete_global : <span><a href="#type-llvalue">llvalue</a> <span class="arrow">&#45;&gt;</span></span> unit</span></code></div><div class="spec-doc"><p><code>delete_global gv</code> destroys the global variable <code>gv</code>. See the method <code>llvm::GlobalVariable::eraseFromParent</code>.</p></div></div><div class="odoc-spec"><div class="spec value" id="val-global_begin" class="anchored"><a href="#val-global_begin" class="anchor"></a><code><span><span class="keyword">val</span> global_begin : <span><a href="#type-llmodule">llmodule</a> <span class="arrow">&#45;&gt;</span></span> <span><span>( <a href="#type-llmodule">llmodule</a>, <a href="#type-llvalue">llvalue</a> )</span> <a href="#type-llpos">llpos</a></span></span></code></div><div class="spec-doc"><p><code>global_begin m</code> returns the first position in the global variable list of the module <code>m</code>. <code>global_begin</code> and <code>global_succ</code> can be used to iterate over the global list in order. See the method <code>llvm::Module::global_begin</code>.</p></div></div><div class="odoc-spec"><div class="spec value" id="val-global_succ" class="anchored"><a href="#val-global_succ" class="anchor"></a><code><span><span class="keyword">val</span> global_succ : <span><a href="#type-llvalue">llvalue</a> <span class="arrow">&#45;&gt;</span></span> <span><span>( <a href="#type-llmodule">llmodule</a>, <a href="#type-llvalue">llvalue</a> )</span> <a href="#type-llpos">llpos</a></span></span></code></div><div class="spec-doc"><p><code>global_succ gv</code> returns the global variable list position succeeding <code>Before gv</code>. See the method <code>llvm::Module::global_iterator::operator++</code>.</p></div></div><div class="odoc-spec"><div class="spec value" id="val-iter_globals" class="anchored"><a href="#val-iter_globals" class="anchor"></a><code><span><span class="keyword">val</span> iter_globals : <span><span>( <span><a href="#type-llvalue">llvalue</a> <span class="arrow">&#45;&gt;</span></span> unit )</span> <span class="arrow">&#45;&gt;</span></span> <span><a href="#type-llmodule">llmodule</a> <span class="arrow">&#45;&gt;</span></span> unit</span></code></div><div class="spec-doc"><p><code>iter_globals f m</code> applies function <code>f</code> to each of the global variables of module <code>m</code> in order. Tail recursive.</p></div></div><div class="odoc-spec"><div class="spec value" id="val-fold_left_globals" class="anchored"><a href="#val-fold_left_globals" class="anchor"></a><code><span><span class="keyword">val</span> fold_left_globals : <span><span>( <span><span class="type-var">'a</span> <span class="arrow">&#45;&gt;</span></span> <span><a href="#type-llvalue">llvalue</a> <span class="arrow">&#45;&gt;</span></span> <span class="type-var">'a</span> )</span> <span class="arrow">&#45;&gt;</span></span> <span><span class="type-var">'a</span> <span class="arrow">&#45;&gt;</span></span> <span><a href="#type-llmodule">llmodule</a> <span class="arrow">&#45;&gt;</span></span> <span class="type-var">'a</span></span></code></div><div class="spec-doc"><p><code>fold_left_globals f init m</code> is <code>f (... (f init g1) ...) gN</code> where <code>g1,...,gN</code> are the global variables of module <code>m</code>. Tail recursive.</p></div></div><div class="odoc-spec"><div class="spec value" id="val-global_end" class="anchored"><a href="#val-global_end" class="anchor"></a><code><span><span class="keyword">val</span> global_end : <span><a href="#type-llmodule">llmodule</a> <span class="arrow">&#45;&gt;</span></span> <span><span>( <a href="#type-llmodule">llmodule</a>, <a href="#type-llvalue">llvalue</a> )</span> <a href="#type-llrev_pos">llrev_pos</a></span></span></code></div><div class="spec-doc"><p><code>global_end m</code> returns the last position in the global variable list of the module <code>m</code>. <code>global_end</code> and <code>global_pred</code> can be used to iterate over the global list in reverse. See the method <code>llvm::Module::global_end</code>.</p></div></div><div class="odoc-spec"><div class="spec value" id="val-global_pred" class="anchored"><a href="#val-global_pred" class="anchor"></a><code><span><span class="keyword">val</span> global_pred : <span><a href="#type-llvalue">llvalue</a> <span class="arrow">&#45;&gt;</span></span> <span><span>( <a href="#type-llmodule">llmodule</a>, <a href="#type-llvalue">llvalue</a> )</span> <a href="#type-llrev_pos">llrev_pos</a></span></span></code></div><div class="spec-doc"><p><code>global_pred gv</code> returns the global variable list position preceding <code>After gv</code>. See the method <code>llvm::Module::global_iterator::operator--</code>.</p></div></div><div class="odoc-spec"><div class="spec value" id="val-rev_iter_globals" class="anchored"><a href="#val-rev_iter_globals" class="anchor"></a><code><span><span class="keyword">val</span> rev_iter_globals : <span><span>( <span><a href="#type-llvalue">llvalue</a> <span class="arrow">&#45;&gt;</span></span> unit )</span> <span class="arrow">&#45;&gt;</span></span> <span><a href="#type-llmodule">llmodule</a> <span class="arrow">&#45;&gt;</span></span> unit</span></code></div><div class="spec-doc"><p><code>rev_iter_globals f m</code> applies function <code>f</code> to each of the global variables of module <code>m</code> in reverse order. Tail recursive.</p></div></div><div class="odoc-spec"><div class="spec value" id="val-fold_right_globals" class="anchored"><a href="#val-fold_right_globals" class="anchor"></a><code><span><span class="keyword">val</span> fold_right_globals : <span><span>( <span><a href="#type-llvalue">llvalue</a> <span class="arrow">&#45;&gt;</span></span> <span><span class="type-var">'a</span> <span class="arrow">&#45;&gt;</span></span> <span class="type-var">'a</span> )</span> <span class="arrow">&#45;&gt;</span></span> <span><a href="#type-llmodule">llmodule</a> <span class="arrow">&#45;&gt;</span></span> <span><span class="type-var">'a</span> <span class="arrow">&#45;&gt;</span></span> <span class="type-var">'a</span></span></code></div><div class="spec-doc"><p><code>fold_right_globals f m init</code> is <code>f g1 (... (f gN init) ...)</code> where <code>g1,...,gN</code> are the global variables of module <code>m</code>. Tail recursive.</p></div></div><div class="odoc-spec"><div class="spec value" id="val-is_global_constant" class="anchored"><a href="#val-is_global_constant" class="anchor"></a><code><span><span class="keyword">val</span> is_global_constant : <span><a href="#type-llvalue">llvalue</a> <span class="arrow">&#45;&gt;</span></span> bool</span></code></div><div class="spec-doc"><p><code>is_global_constant gv</code> returns <code>true</code> if the global variabile <code>gv</code> is a constant. Returns <code>false</code> otherwise. See the method <code>llvm::GlobalVariable::isConstant</code>.</p></div></div><div class="odoc-spec"><div class="spec value" id="val-set_global_constant" class="anchored"><a href="#val-set_global_constant" class="anchor"></a><code><span><span class="keyword">val</span> set_global_constant : <span>bool <span class="arrow">&#45;&gt;</span></span> <span><a href="#type-llvalue">llvalue</a> <span class="arrow">&#45;&gt;</span></span> unit</span></code></div><div class="spec-doc"><p><code>set_global_constant c gv</code> sets the global variable <code>gv</code> to be a constant if <code>c</code> is <code>true</code> and not if <code>c</code> is <code>false</code>. See the method <code>llvm::GlobalVariable::setConstant</code>.</p></div></div><div class="odoc-spec"><div class="spec value" id="val-global_initializer" class="anchored"><a href="#val-global_initializer" class="anchor"></a><code><span><span class="keyword">val</span> global_initializer : <span><a href="#type-llvalue">llvalue</a> <span class="arrow">&#45;&gt;</span></span> <span><a href="#type-llvalue">llvalue</a> option</span></span></code></div><div class="spec-doc"><p><code>global_initializer gv</code> If global variable <code>gv</code> has an initializer it is returned, otherwise returns <code>None</code>. See the method <code>llvm::GlobalVariable::getInitializer</code>.</p></div></div><div class="odoc-spec"><div class="spec value" id="val-set_initializer" class="anchored"><a href="#val-set_initializer" class="anchor"></a><code><span><span class="keyword">val</span> set_initializer : <span><a href="#type-llvalue">llvalue</a> <span class="arrow">&#45;&gt;</span></span> <span><a href="#type-llvalue">llvalue</a> <span class="arrow">&#45;&gt;</span></span> unit</span></code></div><div class="spec-doc"><p><code>set_initializer c gv</code> sets the initializer for the global variable <code>gv</code> to the constant <code>c</code>. See the method <code>llvm::GlobalVariable::setInitializer</code>.</p></div></div><div class="odoc-spec"><div class="spec value" id="val-remove_initializer" class="anchored"><a href="#val-remove_initializer" class="anchor"></a><code><span><span class="keyword">val</span> remove_initializer : <span><a href="#type-llvalue">llvalue</a> <span class="arrow">&#45;&gt;</span></span> unit</span></code></div><div class="spec-doc"><p><code>remove_initializer gv</code> unsets the initializer for the global variable <code>gv</code>. See the method <code>llvm::GlobalVariable::setInitializer</code>.</p></div></div><div class="odoc-spec"><div class="spec value" id="val-is_thread_local" class="anchored"><a href="#val-is_thread_local" class="anchor"></a><code><span><span class="keyword">val</span> is_thread_local : <span><a href="#type-llvalue">llvalue</a> <span class="arrow">&#45;&gt;</span></span> bool</span></code></div><div class="spec-doc"><p><code>is_thread_local gv</code> returns <code>true</code> if the global variable <code>gv</code> is thread-local and <code>false</code> otherwise. See the method <code>llvm::GlobalVariable::isThreadLocal</code>.</p></div></div><div class="odoc-spec"><div class="spec value" id="val-set_thread_local" class="anchored"><a href="#val-set_thread_local" class="anchor"></a><code><span><span class="keyword">val</span> set_thread_local : <span>bool <span class="arrow">&#45;&gt;</span></span> <span><a href="#type-llvalue">llvalue</a> <span class="arrow">&#45;&gt;</span></span> unit</span></code></div><div class="spec-doc"><p><code>set_thread_local c gv</code> sets the global variable <code>gv</code> to be thread local if <code>c</code> is <code>true</code> and not otherwise. See the method <code>llvm::GlobalVariable::setThreadLocal</code>.</p></div></div><div class="odoc-spec"><div class="spec value" id="val-thread_local_mode" class="anchored"><a href="#val-thread_local_mode" class="anchor"></a><code><span><span class="keyword">val</span> thread_local_mode : <span><a href="#type-llvalue">llvalue</a> <span class="arrow">&#45;&gt;</span></span> <a href="ThreadLocalMode/index.html#type-t">ThreadLocalMode.t</a></span></code></div><div class="spec-doc"><p><code>is_thread_local gv</code> returns the thread local mode of the global variable <code>gv</code>. See the method <code>llvm::GlobalVariable::getThreadLocalMode</code>.</p></div></div><div class="odoc-spec"><div class="spec value" id="val-set_thread_local_mode" class="anchored"><a href="#val-set_thread_local_mode" class="anchor"></a><code><span><span class="keyword">val</span> set_thread_local_mode : <span><a href="ThreadLocalMode/index.html#type-t">ThreadLocalMode.t</a> <span class="arrow">&#45;&gt;</span></span> <span><a href="#type-llvalue">llvalue</a> <span class="arrow">&#45;&gt;</span></span> unit</span></code></div><div class="spec-doc"><p><code>set_thread_local c gv</code> sets the thread local mode of the global variable <code>gv</code>. See the method <code>llvm::GlobalVariable::setThreadLocalMode</code>.</p></div></div><div class="odoc-spec"><div class="spec value" id="val-is_externally_initialized" class="anchored"><a href="#val-is_externally_initialized" class="anchor"></a><code><span><span class="keyword">val</span> is_externally_initialized : <span><a href="#type-llvalue">llvalue</a> <span class="arrow">&#45;&gt;</span></span> bool</span></code></div><div class="spec-doc"><p><code>is_externally_initialized gv</code> returns <code>true</code> if the global variable <code>gv</code> is externally initialized and <code>false</code> otherwise. See the method <code>llvm::GlobalVariable::isExternallyInitialized</code>.</p></div></div><div class="odoc-spec"><div class="spec value" id="val-set_externally_initialized" class="anchored"><a href="#val-set_externally_initialized" class="anchor"></a><code><span><span class="keyword">val</span> set_externally_initialized : <span>bool <span class="arrow">&#45;&gt;</span></span> <span><a href="#type-llvalue">llvalue</a> <span class="arrow">&#45;&gt;</span></span> unit</span></code></div><div class="spec-doc"><p><code>set_externally_initialized c gv</code> sets the global variable <code>gv</code> to be externally initialized if <code>c</code> is <code>true</code> and not otherwise. See the method <code>llvm::GlobalVariable::setExternallyInitialized</code>.</p></div></div><h6 id="operations-on-aliases"><a href="#operations-on-aliases" class="anchor"></a>Operations on aliases</h6><div class="odoc-spec"><div class="spec value" id="val-add_alias" class="anchored"><a href="#val-add_alias" class="anchor"></a><code><span><span class="keyword">val</span> add_alias : <span><a href="#type-llmodule">llmodule</a> <span class="arrow">&#45;&gt;</span></span> <span><a href="#type-lltype">lltype</a> <span class="arrow">&#45;&gt;</span></span> <span><a href="#type-llvalue">llvalue</a> <span class="arrow">&#45;&gt;</span></span> <span>string <span class="arrow">&#45;&gt;</span></span> <a href="#type-llvalue">llvalue</a></span></code></div><div class="spec-doc"><p><code>add_alias m t a n</code> inserts an alias in the module <code>m</code> with the type <code>t</code> and the aliasee <code>a</code> with the name <code>n</code>. See the constructor for <code>llvm::GlobalAlias</code>.</p></div></div><h6 id="operations-on-functions"><a href="#operations-on-functions" class="anchor"></a>Operations on functions</h6><div class="odoc-spec"><div class="spec value" id="val-declare_function" class="anchored"><a href="#val-declare_function" class="anchor"></a><code><span><span class="keyword">val</span> declare_function : <span>string <span class="arrow">&#45;&gt;</span></span> <span><a href="#type-lltype">lltype</a> <span class="arrow">&#45;&gt;</span></span> <span><a href="#type-llmodule">llmodule</a> <span class="arrow">&#45;&gt;</span></span> <a href="#type-llvalue">llvalue</a></span></code></div><div class="spec-doc"><p><code>declare_function name ty m</code> returns a new function of type <code>ty</code> and with name <code>name</code> in module <code>m</code>. If such a function already exists, it is returned. If the type of the existing function differs, then a bitcast to <code>ty</code> is returned.</p></div></div><div class="odoc-spec"><div class="spec value" id="val-define_function" class="anchored"><a href="#val-define_function" class="anchor"></a><code><span><span class="keyword">val</span> define_function : <span>string <span class="arrow">&#45;&gt;</span></span> <span><a href="#type-lltype">lltype</a> <span class="arrow">&#45;&gt;</span></span> <span><a href="#type-llmodule">llmodule</a> <span class="arrow">&#45;&gt;</span></span> <a href="#type-llvalue">llvalue</a></span></code></div><div class="spec-doc"><p><code>define_function name ty m</code> creates a new function with name <code>name</code> and type <code>ty</code> in module <code>m</code>. If the named function already exists, it is renamed. An entry basic block is created in the function. See the constructor of <code>llvm::GlobalVariable</code>.</p></div></div><div class="odoc-spec"><div class="spec value" id="val-lookup_function" class="anchored"><a href="#val-lookup_function" class="anchor"></a><code><span><span class="keyword">val</span> lookup_function : <span>string <span class="arrow">&#45;&gt;</span></span> <span><a href="#type-llmodule">llmodule</a> <span class="arrow">&#45;&gt;</span></span> <span><a href="#type-llvalue">llvalue</a> option</span></span></code></div><div class="spec-doc"><p><code>lookup_function name m</code> returns <code>Some f</code> if a function with name <code>name</code> exists in module <code>m</code>. If no such function exists, returns <code>None</code>. See the method <code>llvm::Module</code> constructor.</p></div></div><div class="odoc-spec"><div class="spec value" id="val-delete_function" class="anchored"><a href="#val-delete_function" class="anchor"></a><code><span><span class="keyword">val</span> delete_function : <span><a href="#type-llvalue">llvalue</a> <span class="arrow">&#45;&gt;</span></span> unit</span></code></div><div class="spec-doc"><p><code>delete_function f</code> destroys the function <code>f</code>. See the method <code>llvm::Function::eraseFromParent</code>.</p></div></div><div class="odoc-spec"><div class="spec value" id="val-function_begin" class="anchored"><a href="#val-function_begin" class="anchor"></a><code><span><span class="keyword">val</span> function_begin : <span><a href="#type-llmodule">llmodule</a> <span class="arrow">&#45;&gt;</span></span> <span><span>( <a href="#type-llmodule">llmodule</a>, <a href="#type-llvalue">llvalue</a> )</span> <a href="#type-llpos">llpos</a></span></span></code></div><div class="spec-doc"><p><code>function_begin m</code> returns the first position in the function list of the module <code>m</code>. <code>function_begin</code> and <code>function_succ</code> can be used to iterate over the function list in order. See the method <code>llvm::Module::begin</code>.</p></div></div><div class="odoc-spec"><div class="spec value" id="val-function_succ" class="anchored"><a href="#val-function_succ" class="anchor"></a><code><span><span class="keyword">val</span> function_succ : <span><a href="#type-llvalue">llvalue</a> <span class="arrow">&#45;&gt;</span></span> <span><span>( <a href="#type-llmodule">llmodule</a>, <a href="#type-llvalue">llvalue</a> )</span> <a href="#type-llpos">llpos</a></span></span></code></div><div class="spec-doc"><p><code>function_succ gv</code> returns the function list position succeeding <code>Before gv</code>. See the method <code>llvm::Module::iterator::operator++</code>.</p></div></div><div class="odoc-spec"><div class="spec value" id="val-iter_functions" class="anchored"><a href="#val-iter_functions" class="anchor"></a><code><span><span class="keyword">val</span> iter_functions : <span><span>( <span><a href="#type-llvalue">llvalue</a> <span class="arrow">&#45;&gt;</span></span> unit )</span> <span class="arrow">&#45;&gt;</span></span> <span><a href="#type-llmodule">llmodule</a> <span class="arrow">&#45;&gt;</span></span> unit</span></code></div><div class="spec-doc"><p><code>iter_functions f m</code> applies function <code>f</code> to each of the functions of module <code>m</code> in order. Tail recursive.</p></div></div><div class="odoc-spec"><div class="spec value" id="val-fold_left_functions" class="anchored"><a href="#val-fold_left_functions" class="anchor"></a><code><span><span class="keyword">val</span> fold_left_functions : <span><span>( <span><span class="type-var">'a</span> <span class="arrow">&#45;&gt;</span></span> <span><a href="#type-llvalue">llvalue</a> <span class="arrow">&#45;&gt;</span></span> <span class="type-var">'a</span> )</span> <span class="arrow">&#45;&gt;</span></span> <span><span class="type-var">'a</span> <span class="arrow">&#45;&gt;</span></span> <span><a href="#type-llmodule">llmodule</a> <span class="arrow">&#45;&gt;</span></span> <span class="type-var">'a</span></span></code></div><div class="spec-doc"><p><code>fold_left_function f init m</code> is <code>f (... (f init f1) ...) fN</code> where <code>f1,...,fN</code> are the functions of module <code>m</code>. Tail recursive.</p></div></div><div class="odoc-spec"><div class="spec value" id="val-function_end" class="anchored"><a href="#val-function_end" class="anchor"></a><code><span><span class="keyword">val</span> function_end : <span><a href="#type-llmodule">llmodule</a> <span class="arrow">&#45;&gt;</span></span> <span><span>( <a href="#type-llmodule">llmodule</a>, <a href="#type-llvalue">llvalue</a> )</span> <a href="#type-llrev_pos">llrev_pos</a></span></span></code></div><div class="spec-doc"><p><code>function_end m</code> returns the last position in the function list of the module <code>m</code>. <code>function_end</code> and <code>function_pred</code> can be used to iterate over the function list in reverse. See the method <code>llvm::Module::end</code>.</p></div></div><div class="odoc-spec"><div class="spec value" id="val-function_pred" class="anchored"><a href="#val-function_pred" class="anchor"></a><code><span><span class="keyword">val</span> function_pred : <span><a href="#type-llvalue">llvalue</a> <span class="arrow">&#45;&gt;</span></span> <span><span>( <a href="#type-llmodule">llmodule</a>, <a href="#type-llvalue">llvalue</a> )</span> <a href="#type-llrev_pos">llrev_pos</a></span></span></code></div><div class="spec-doc"><p><code>function_pred gv</code> returns the function list position preceding <code>After gv</code>. See the method <code>llvm::Module::iterator::operator--</code>.</p></div></div><div class="odoc-spec"><div class="spec value" id="val-rev_iter_functions" class="anchored"><a href="#val-rev_iter_functions" class="anchor"></a><code><span><span class="keyword">val</span> rev_iter_functions : <span><span>( <span><a href="#type-llvalue">llvalue</a> <span class="arrow">&#45;&gt;</span></span> unit )</span> <span class="arrow">&#45;&gt;</span></span> <span><a href="#type-llmodule">llmodule</a> <span class="arrow">&#45;&gt;</span></span> unit</span></code></div><div class="spec-doc"><p><code>rev_iter_functions f fn</code> applies function <code>f</code> to each of the functions of module <code>m</code> in reverse order. Tail recursive.</p></div></div><div class="odoc-spec"><div class="spec value" id="val-fold_right_functions" class="anchored"><a href="#val-fold_right_functions" class="anchor"></a><code><span><span class="keyword">val</span> fold_right_functions : <span><span>( <span><a href="#type-llvalue">llvalue</a> <span class="arrow">&#45;&gt;</span></span> <span><span class="type-var">'a</span> <span class="arrow">&#45;&gt;</span></span> <span class="type-var">'a</span> )</span> <span class="arrow">&#45;&gt;</span></span> <span><a href="#type-llmodule">llmodule</a> <span class="arrow">&#45;&gt;</span></span> <span><span class="type-var">'a</span> <span class="arrow">&#45;&gt;</span></span> <span class="type-var">'a</span></span></code></div><div class="spec-doc"><p><code>fold_right_functions f m init</code> is <code>f (... (f init fN) ...) f1</code> where <code>f1,...,fN</code> are the functions of module <code>m</code>. Tail recursive.</p></div></div><div class="odoc-spec"><div class="spec value" id="val-is_intrinsic" class="anchored"><a href="#val-is_intrinsic" class="anchor"></a><code><span><span class="keyword">val</span> is_intrinsic : <span><a href="#type-llvalue">llvalue</a> <span class="arrow">&#45;&gt;</span></span> bool</span></code></div><div class="spec-doc"><p><code>is_intrinsic f</code> returns true if the function <code>f</code> is an intrinsic. See the method <code>llvm::Function::isIntrinsic</code>.</p></div></div><div class="odoc-spec"><div class="spec value" id="val-function_call_conv" class="anchored"><a href="#val-function_call_conv" class="anchor"></a><code><span><span class="keyword">val</span> function_call_conv : <span><a href="#type-llvalue">llvalue</a> <span class="arrow">&#45;&gt;</span></span> int</span></code></div><div class="spec-doc"><p><code>function_call_conv f</code> returns the calling convention of the function <code>f</code>. See the method <code>llvm::Function::getCallingConv</code>.</p></div></div><div class="odoc-spec"><div class="spec value" id="val-set_function_call_conv" class="anchored"><a href="#val-set_function_call_conv" class="anchor"></a><code><span><span class="keyword">val</span> set_function_call_conv : <span>int <span class="arrow">&#45;&gt;</span></span> <span><a href="#type-llvalue">llvalue</a> <span class="arrow">&#45;&gt;</span></span> unit</span></code></div><div class="spec-doc"><p><code>set_function_call_conv cc f</code> sets the calling convention of the function <code>f</code> to the calling convention numbered <code>cc</code>. See the method <code>llvm::Function::setCallingConv</code>.</p></div></div><div class="odoc-spec"><div class="spec value" id="val-gc" class="anchored"><a href="#val-gc" class="anchor"></a><code><span><span class="keyword">val</span> gc : <span><a href="#type-llvalue">llvalue</a> <span class="arrow">&#45;&gt;</span></span> <span>string option</span></span></code></div><div class="spec-doc"><p><code>gc f</code> returns <code>Some name</code> if the function <code>f</code> has a garbage collection algorithm specified and <code>None</code> otherwise. See the method <code>llvm::Function::getGC</code>.</p></div></div><div class="odoc-spec"><div class="spec value" id="val-set_gc" class="anchored"><a href="#val-set_gc" class="anchor"></a><code><span><span class="keyword">val</span> set_gc : <span><span>string option</span> <span class="arrow">&#45;&gt;</span></span> <span><a href="#type-llvalue">llvalue</a> <span class="arrow">&#45;&gt;</span></span> unit</span></code></div><div class="spec-doc"><p><code>set_gc gc f</code> sets the collection algorithm for the function <code>f</code> to <code>gc</code>. See the method <code>llvm::Function::setGC</code>.</p></div></div><div class="odoc-spec"><div class="spec value" id="val-add_function_attr" class="anchored"><a href="#val-add_function_attr" class="anchor"></a><code><span><span class="keyword">val</span> add_function_attr : <span><a href="#type-llvalue">llvalue</a> <span class="arrow">&#45;&gt;</span></span> <span><a href="#type-llattribute">llattribute</a> <span class="arrow">&#45;&gt;</span></span> <span><a href="AttrIndex/index.html#type-t">AttrIndex.t</a> <span class="arrow">&#45;&gt;</span></span> unit</span></code></div><div class="spec-doc"><p><code>add_function_attr f a i</code> adds attribute <code>a</code> to the function <code>f</code> at position <code>i</code>.</p></div></div><div class="odoc-spec"><div class="spec value" id="val-function_attrs" class="anchored"><a href="#val-function_attrs" class="anchor"></a><code><span><span class="keyword">val</span> function_attrs : <span><a href="#type-llvalue">llvalue</a> <span class="arrow">&#45;&gt;</span></span> <span><a href="AttrIndex/index.html#type-t">AttrIndex.t</a> <span class="arrow">&#45;&gt;</span></span> <span><a href="#type-llattribute">llattribute</a> array</span></span></code></div><div class="spec-doc"><p><code>function_attrs f i</code> returns the attributes for the function <code>f</code> at position <code>i</code>.</p></div></div><div class="odoc-spec"><div class="spec value" id="val-remove_enum_function_attr" class="anchored"><a href="#val-remove_enum_function_attr" class="anchor"></a><code><span><span class="keyword">val</span> remove_enum_function_attr : <span><a href="#type-llvalue">llvalue</a> <span class="arrow">&#45;&gt;</span></span> <span><a href="#type-llattrkind">llattrkind</a> <span class="arrow">&#45;&gt;</span></span> <span><a href="AttrIndex/index.html#type-t">AttrIndex.t</a> <span class="arrow">&#45;&gt;</span></span> unit</span></code></div><div class="spec-doc"><p><code>remove_enum_function_attr f k i</code> removes enum attribute with kind <code>k</code> from the function <code>f</code> at position <code>i</code>.</p></div></div><div class="odoc-spec"><div class="spec value" id="val-remove_string_function_attr" class="anchored"><a href="#val-remove_string_function_attr" class="anchor"></a><code><span><span class="keyword">val</span> remove_string_function_attr : <span><a href="#type-llvalue">llvalue</a> <span class="arrow">&#45;&gt;</span></span> <span>string <span class="arrow">&#45;&gt;</span></span> <span><a href="AttrIndex/index.html#type-t">AttrIndex.t</a> <span class="arrow">&#45;&gt;</span></span> unit</span></code></div><div class="spec-doc"><p><code>remove_string_function_attr f k i</code> removes string attribute with kind <code>k</code> from the function <code>f</code> at position <code>i</code>.</p></div></div><h6 id="operations-on-params"><a href="#operations-on-params" class="anchor"></a>Operations on params</h6><div class="odoc-spec"><div class="spec value" id="val-params" class="anchored"><a href="#val-params" class="anchor"></a><code><span><span class="keyword">val</span> params : <span><a href="#type-llvalue">llvalue</a> <span class="arrow">&#45;&gt;</span></span> <span><a href="#type-llvalue">llvalue</a> array</span></span></code></div><div class="spec-doc"><p><code>params f</code> returns the parameters of function <code>f</code>. See the method <code>llvm::Function::getArgumentList</code>.</p></div></div><div class="odoc-spec"><div class="spec value" id="val-param" class="anchored"><a href="#val-param" class="anchor"></a><code><span><span class="keyword">val</span> param : <span><a href="#type-llvalue">llvalue</a> <span class="arrow">&#45;&gt;</span></span> <span>int <span class="arrow">&#45;&gt;</span></span> <a href="#type-llvalue">llvalue</a></span></code></div><div class="spec-doc"><p><code>param f n</code> returns the <code>n</code>th parameter of function <code>f</code>. See the method <code>llvm::Function::getArgumentList</code>.</p></div></div><div class="odoc-spec"><div class="spec value" id="val-param_parent" class="anchored"><a href="#val-param_parent" class="anchor"></a><code><span><span class="keyword">val</span> param_parent : <span><a href="#type-llvalue">llvalue</a> <span class="arrow">&#45;&gt;</span></span> <a href="#type-llvalue">llvalue</a></span></code></div><div class="spec-doc"><p><code>param_parent p</code> returns the parent function that owns the parameter. See the method <code>llvm::Argument::getParent</code>.</p></div></div><div class="odoc-spec"><div class="spec value" id="val-param_begin" class="anchored"><a href="#val-param_begin" class="anchor"></a><code><span><span class="keyword">val</span> param_begin : <span><a href="#type-llvalue">llvalue</a> <span class="arrow">&#45;&gt;</span></span> <span><span>( <a href="#type-llvalue">llvalue</a>, <a href="#type-llvalue">llvalue</a> )</span> <a href="#type-llpos">llpos</a></span></span></code></div><div class="spec-doc"><p><code>param_begin f</code> returns the first position in the parameter list of the function <code>f</code>. <code>param_begin</code> and <code>param_succ</code> can be used to iterate over the parameter list in order. See the method <code>llvm::Function::arg_begin</code>.</p></div></div><div class="odoc-spec"><div class="spec value" id="val-param_succ" class="anchored"><a href="#val-param_succ" class="anchor"></a><code><span><span class="keyword">val</span> param_succ : <span><a href="#type-llvalue">llvalue</a> <span class="arrow">&#45;&gt;</span></span> <span><span>( <a href="#type-llvalue">llvalue</a>, <a href="#type-llvalue">llvalue</a> )</span> <a href="#type-llpos">llpos</a></span></span></code></div><div class="spec-doc"><p><code>param_succ bb</code> returns the parameter list position succeeding <code>Before bb</code>. See the method <code>llvm::Function::arg_iterator::operator++</code>.</p></div></div><div class="odoc-spec"><div class="spec value" id="val-iter_params" class="anchored"><a href="#val-iter_params" class="anchor"></a><code><span><span class="keyword">val</span> iter_params : <span><span>( <span><a href="#type-llvalue">llvalue</a> <span class="arrow">&#45;&gt;</span></span> unit )</span> <span class="arrow">&#45;&gt;</span></span> <span><a href="#type-llvalue">llvalue</a> <span class="arrow">&#45;&gt;</span></span> unit</span></code></div><div class="spec-doc"><p><code>iter_params f fn</code> applies function <code>f</code> to each of the parameters of function <code>fn</code> in order. Tail recursive.</p></div></div><div class="odoc-spec"><div class="spec value" id="val-fold_left_params" class="anchored"><a href="#val-fold_left_params" class="anchor"></a><code><span><span class="keyword">val</span> fold_left_params : <span><span>( <span><span class="type-var">'a</span> <span class="arrow">&#45;&gt;</span></span> <span><a href="#type-llvalue">llvalue</a> <span class="arrow">&#45;&gt;</span></span> <span class="type-var">'a</span> )</span> <span class="arrow">&#45;&gt;</span></span> <span><span class="type-var">'a</span> <span class="arrow">&#45;&gt;</span></span> <span><a href="#type-llvalue">llvalue</a> <span class="arrow">&#45;&gt;</span></span> <span class="type-var">'a</span></span></code></div><div class="spec-doc"><p><code>fold_left_params f init fn</code> is <code>f (... (f init b1) ...) bN</code> where <code>b1,...,bN</code> are the parameters of function <code>fn</code>. Tail recursive.</p></div></div><div class="odoc-spec"><div class="spec value" id="val-param_end" class="anchored"><a href="#val-param_end" class="anchor"></a><code><span><span class="keyword">val</span> param_end : <span><a href="#type-llvalue">llvalue</a> <span class="arrow">&#45;&gt;</span></span> <span><span>( <a href="#type-llvalue">llvalue</a>, <a href="#type-llvalue">llvalue</a> )</span> <a href="#type-llrev_pos">llrev_pos</a></span></span></code></div><div class="spec-doc"><p><code>param_end f</code> returns the last position in the parameter list of the function <code>f</code>. <code>param_end</code> and <code>param_pred</code> can be used to iterate over the parameter list in reverse. See the method <code>llvm::Function::arg_end</code>.</p></div></div><div class="odoc-spec"><div class="spec value" id="val-param_pred" class="anchored"><a href="#val-param_pred" class="anchor"></a><code><span><span class="keyword">val</span> param_pred : <span><a href="#type-llvalue">llvalue</a> <span class="arrow">&#45;&gt;</span></span> <span><span>( <a href="#type-llvalue">llvalue</a>, <a href="#type-llvalue">llvalue</a> )</span> <a href="#type-llrev_pos">llrev_pos</a></span></span></code></div><div class="spec-doc"><p><code>param_pred gv</code> returns the function list position preceding <code>After gv</code>. See the method <code>llvm::Function::arg_iterator::operator--</code>.</p></div></div><div class="odoc-spec"><div class="spec value" id="val-rev_iter_params" class="anchored"><a href="#val-rev_iter_params" class="anchor"></a><code><span><span class="keyword">val</span> rev_iter_params : <span><span>( <span><a href="#type-llvalue">llvalue</a> <span class="arrow">&#45;&gt;</span></span> unit )</span> <span class="arrow">&#45;&gt;</span></span> <span><a href="#type-llvalue">llvalue</a> <span class="arrow">&#45;&gt;</span></span> unit</span></code></div><div class="spec-doc"><p><code>rev_iter_params f fn</code> applies function <code>f</code> to each of the parameters of function <code>fn</code> in reverse order. Tail recursive.</p></div></div><div class="odoc-spec"><div class="spec value" id="val-fold_right_params" class="anchored"><a href="#val-fold_right_params" class="anchor"></a><code><span><span class="keyword">val</span> fold_right_params : <span><span>( <span><a href="#type-llvalue">llvalue</a> <span class="arrow">&#45;&gt;</span></span> <span><span class="type-var">'a</span> <span class="arrow">&#45;&gt;</span></span> <span class="type-var">'a</span> )</span> <span class="arrow">&#45;&gt;</span></span> <span><a href="#type-llvalue">llvalue</a> <span class="arrow">&#45;&gt;</span></span> <span><span class="type-var">'a</span> <span class="arrow">&#45;&gt;</span></span> <span class="type-var">'a</span></span></code></div><div class="spec-doc"><p><code>fold_right_params f fn init</code> is <code>f (... (f init bN) ...) b1</code> where <code>b1,...,bN</code> are the parameters of function <code>fn</code>. Tail recursive.</p></div></div><h6 id="operations-on-basic-blocks"><a href="#operations-on-basic-blocks" class="anchor"></a>Operations on basic blocks</h6><div class="odoc-spec"><div class="spec value" id="val-basic_blocks" class="anchored"><a href="#val-basic_blocks" class="anchor"></a><code><span><span class="keyword">val</span> basic_blocks : <span><a href="#type-llvalue">llvalue</a> <span class="arrow">&#45;&gt;</span></span> <span><a href="#type-llbasicblock">llbasicblock</a> array</span></span></code></div><div class="spec-doc"><p><code>basic_blocks fn</code> returns the basic blocks of the function <code>f</code>. See the method <code>llvm::Function::getBasicBlockList</code>.</p></div></div><div class="odoc-spec"><div class="spec value" id="val-entry_block" class="anchored"><a href="#val-entry_block" class="anchor"></a><code><span><span class="keyword">val</span> entry_block : <span><a href="#type-llvalue">llvalue</a> <span class="arrow">&#45;&gt;</span></span> <a href="#type-llbasicblock">llbasicblock</a></span></code></div><div class="spec-doc"><p><code>entry_block fn</code> returns the entry basic block of the function <code>f</code>. See the method <code>llvm::Function::getEntryBlock</code>.</p></div></div><div class="odoc-spec"><div class="spec value" id="val-delete_block" class="anchored"><a href="#val-delete_block" class="anchor"></a><code><span><span class="keyword">val</span> delete_block : <span><a href="#type-llbasicblock">llbasicblock</a> <span class="arrow">&#45;&gt;</span></span> unit</span></code></div><div class="spec-doc"><p><code>delete_block bb</code> deletes the basic block <code>bb</code>. See the method <code>llvm::BasicBlock::eraseFromParent</code>.</p></div></div><div class="odoc-spec"><div class="spec value" id="val-remove_block" class="anchored"><a href="#val-remove_block" class="anchor"></a><code><span><span class="keyword">val</span> remove_block : <span><a href="#type-llbasicblock">llbasicblock</a> <span class="arrow">&#45;&gt;</span></span> unit</span></code></div><div class="spec-doc"><p><code>remove_block bb</code> removes the basic block <code>bb</code> from its parent function. See the method <code>llvm::BasicBlock::removeFromParent</code>.</p></div></div><div class="odoc-spec"><div class="spec value" id="val-move_block_before" class="anchored"><a href="#val-move_block_before" class="anchor"></a><code><span><span class="keyword">val</span> move_block_before : <span><a href="#type-llbasicblock">llbasicblock</a> <span class="arrow">&#45;&gt;</span></span> <span><a href="#type-llbasicblock">llbasicblock</a> <span class="arrow">&#45;&gt;</span></span> unit</span></code></div><div class="spec-doc"><p><code>move_block_before pos bb</code> moves the basic block <code>bb</code> before <code>pos</code>. See the method <code>llvm::BasicBlock::moveBefore</code>.</p></div></div><div class="odoc-spec"><div class="spec value" id="val-move_block_after" class="anchored"><a href="#val-move_block_after" class="anchor"></a><code><span><span class="keyword">val</span> move_block_after : <span><a href="#type-llbasicblock">llbasicblock</a> <span class="arrow">&#45;&gt;</span></span> <span><a href="#type-llbasicblock">llbasicblock</a> <span class="arrow">&#45;&gt;</span></span> unit</span></code></div><div class="spec-doc"><p><code>move_block_after pos bb</code> moves the basic block <code>bb</code> after <code>pos</code>. See the method <code>llvm::BasicBlock::moveAfter</code>.</p></div></div><div class="odoc-spec"><div class="spec value" id="val-append_block" class="anchored"><a href="#val-append_block" class="anchor"></a><code><span><span class="keyword">val</span> append_block : <span><a href="#type-llcontext">llcontext</a> <span class="arrow">&#45;&gt;</span></span> <span>string <span class="arrow">&#45;&gt;</span></span> <span><a href="#type-llvalue">llvalue</a> <span class="arrow">&#45;&gt;</span></span> <a href="#type-llbasicblock">llbasicblock</a></span></code></div><div class="spec-doc"><p><code>append_block c name f</code> creates a new basic block named <code>name</code> at the end of function <code>f</code> in the context <code>c</code>. See the constructor of <code>llvm::BasicBlock</code>.</p></div></div><div class="odoc-spec"><div class="spec value" id="val-insert_block" class="anchored"><a href="#val-insert_block" class="anchor"></a><code><span><span class="keyword">val</span> insert_block : <span><a href="#type-llcontext">llcontext</a> <span class="arrow">&#45;&gt;</span></span> <span>string <span class="arrow">&#45;&gt;</span></span> <span><a href="#type-llbasicblock">llbasicblock</a> <span class="arrow">&#45;&gt;</span></span> <a href="#type-llbasicblock">llbasicblock</a></span></code></div><div class="spec-doc"><p><code>insert_block c name bb</code> creates a new basic block named <code>name</code> before the basic block <code>bb</code> in the context <code>c</code>. See the constructor of <code>llvm::BasicBlock</code>.</p></div></div><div class="odoc-spec"><div class="spec value" id="val-block_parent" class="anchored"><a href="#val-block_parent" class="anchor"></a><code><span><span class="keyword">val</span> block_parent : <span><a href="#type-llbasicblock">llbasicblock</a> <span class="arrow">&#45;&gt;</span></span> <a href="#type-llvalue">llvalue</a></span></code></div><div class="spec-doc"><p><code>block_parent bb</code> returns the parent function that owns the basic block. See the method <code>llvm::BasicBlock::getParent</code>.</p></div></div><div class="odoc-spec"><div class="spec value" id="val-block_begin" class="anchored"><a href="#val-block_begin" class="anchor"></a><code><span><span class="keyword">val</span> block_begin : <span><a href="#type-llvalue">llvalue</a> <span class="arrow">&#45;&gt;</span></span> <span><span>( <a href="#type-llvalue">llvalue</a>, <a href="#type-llbasicblock">llbasicblock</a> )</span> <a href="#type-llpos">llpos</a></span></span></code></div><div class="spec-doc"><p><code>block_begin f</code> returns the first position in the basic block list of the function <code>f</code>. <code>block_begin</code> and <code>block_succ</code> can be used to iterate over the basic block list in order. See the method <code>llvm::Function::begin</code>.</p></div></div><div class="odoc-spec"><div class="spec value" id="val-block_succ" class="anchored"><a href="#val-block_succ" class="anchor"></a><code><span><span class="keyword">val</span> block_succ : <span><a href="#type-llbasicblock">llbasicblock</a> <span class="arrow">&#45;&gt;</span></span> <span><span>( <a href="#type-llvalue">llvalue</a>, <a href="#type-llbasicblock">llbasicblock</a> )</span> <a href="#type-llpos">llpos</a></span></span></code></div><div class="spec-doc"><p><code>block_succ bb</code> returns the basic block list position succeeding <code>Before bb</code>. See the method <code>llvm::Function::iterator::operator++</code>.</p></div></div><div class="odoc-spec"><div class="spec value" id="val-iter_blocks" class="anchored"><a href="#val-iter_blocks" class="anchor"></a><code><span><span class="keyword">val</span> iter_blocks : <span><span>( <span><a href="#type-llbasicblock">llbasicblock</a> <span class="arrow">&#45;&gt;</span></span> unit )</span> <span class="arrow">&#45;&gt;</span></span> <span><a href="#type-llvalue">llvalue</a> <span class="arrow">&#45;&gt;</span></span> unit</span></code></div><div class="spec-doc"><p><code>iter_blocks f fn</code> applies function <code>f</code> to each of the basic blocks of function <code>fn</code> in order. Tail recursive.</p></div></div><div class="odoc-spec"><div class="spec value" id="val-fold_left_blocks" class="anchored"><a href="#val-fold_left_blocks" class="anchor"></a><code><span><span class="keyword">val</span> fold_left_blocks : <span><span>( <span><span class="type-var">'a</span> <span class="arrow">&#45;&gt;</span></span> <span><a href="#type-llbasicblock">llbasicblock</a> <span class="arrow">&#45;&gt;</span></span> <span class="type-var">'a</span> )</span> <span class="arrow">&#45;&gt;</span></span> <span><span class="type-var">'a</span> <span class="arrow">&#45;&gt;</span></span> <span><a href="#type-llvalue">llvalue</a> <span class="arrow">&#45;&gt;</span></span> <span class="type-var">'a</span></span></code></div><div class="spec-doc"><p><code>fold_left_blocks f init fn</code> is <code>f (... (f init b1) ...) bN</code> where <code>b1,...,bN</code> are the basic blocks of function <code>fn</code>. Tail recursive.</p></div></div><div class="odoc-spec"><div class="spec value" id="val-block_end" class="anchored"><a href="#val-block_end" class="anchor"></a><code><span><span class="keyword">val</span> block_end : <span><a href="#type-llvalue">llvalue</a> <span class="arrow">&#45;&gt;</span></span> <span><span>( <a href="#type-llvalue">llvalue</a>, <a href="#type-llbasicblock">llbasicblock</a> )</span> <a href="#type-llrev_pos">llrev_pos</a></span></span></code></div><div class="spec-doc"><p><code>block_end f</code> returns the last position in the basic block list of the function <code>f</code>. <code>block_end</code> and <code>block_pred</code> can be used to iterate over the basic block list in reverse. See the method <code>llvm::Function::end</code>.</p></div></div><div class="odoc-spec"><div class="spec value" id="val-block_pred" class="anchored"><a href="#val-block_pred" class="anchor"></a><code><span><span class="keyword">val</span> block_pred : <span><a href="#type-llbasicblock">llbasicblock</a> <span class="arrow">&#45;&gt;</span></span> <span><span>( <a href="#type-llvalue">llvalue</a>, <a href="#type-llbasicblock">llbasicblock</a> )</span> <a href="#type-llrev_pos">llrev_pos</a></span></span></code></div><div class="spec-doc"><p><code>block_pred bb</code> returns the basic block list position preceding <code>After bb</code>. See the method <code>llvm::Function::iterator::operator--</code>.</p></div></div><div class="odoc-spec"><div class="spec value" id="val-block_terminator" class="anchored"><a href="#val-block_terminator" class="anchor"></a><code><span><span class="keyword">val</span> block_terminator : <span><a href="#type-llbasicblock">llbasicblock</a> <span class="arrow">&#45;&gt;</span></span> <span><a href="#type-llvalue">llvalue</a> option</span></span></code></div><div class="spec-doc"><p><code>block_terminator bb</code> returns the terminator of the basic block <code>bb</code>.</p></div></div><div class="odoc-spec"><div class="spec value" id="val-rev_iter_blocks" class="anchored"><a href="#val-rev_iter_blocks" class="anchor"></a><code><span><span class="keyword">val</span> rev_iter_blocks : <span><span>( <span><a href="#type-llbasicblock">llbasicblock</a> <span class="arrow">&#45;&gt;</span></span> unit )</span> <span class="arrow">&#45;&gt;</span></span> <span><a href="#type-llvalue">llvalue</a> <span class="arrow">&#45;&gt;</span></span> unit</span></code></div><div class="spec-doc"><p><code>rev_iter_blocks f fn</code> applies function <code>f</code> to each of the basic blocks of function <code>fn</code> in reverse order. Tail recursive.</p></div></div><div class="odoc-spec"><div class="spec value" id="val-fold_right_blocks" class="anchored"><a href="#val-fold_right_blocks" class="anchor"></a><code><span><span class="keyword">val</span> fold_right_blocks : <span><span>( <span><a href="#type-llbasicblock">llbasicblock</a> <span class="arrow">&#45;&gt;</span></span> <span><span class="type-var">'a</span> <span class="arrow">&#45;&gt;</span></span> <span class="type-var">'a</span> )</span> <span class="arrow">&#45;&gt;</span></span> <span><a href="#type-llvalue">llvalue</a> <span class="arrow">&#45;&gt;</span></span> <span><span class="type-var">'a</span> <span class="arrow">&#45;&gt;</span></span> <span class="type-var">'a</span></span></code></div><div class="spec-doc"><p><code>fold_right_blocks f fn init</code> is <code>f (... (f init bN) ...) b1</code> where <code>b1,...,bN</code> are the basic blocks of function <code>fn</code>. Tail recursive.</p></div></div><div class="odoc-spec"><div class="spec value" id="val-value_of_block" class="anchored"><a href="#val-value_of_block" class="anchor"></a><code><span><span class="keyword">val</span> value_of_block : <span><a href="#type-llbasicblock">llbasicblock</a> <span class="arrow">&#45;&gt;</span></span> <a href="#type-llvalue">llvalue</a></span></code></div><div class="spec-doc"><p><code>value_of_block bb</code> losslessly casts <code>bb</code> to an <code>llvalue</code>.</p></div></div><div class="odoc-spec"><div class="spec value" id="val-value_is_block" class="anchored"><a href="#val-value_is_block" class="anchor"></a><code><span><span class="keyword">val</span> value_is_block : <span><a href="#type-llvalue">llvalue</a> <span class="arrow">&#45;&gt;</span></span> bool</span></code></div><div class="spec-doc"><p><code>value_is_block v</code> returns <code>true</code> if the value <code>v</code> is a basic block and <code>false</code> otherwise. Similar to <code>llvm::isa&lt;BasicBlock&gt;</code>.</p></div></div><div class="odoc-spec"><div class="spec value" id="val-block_of_value" class="anchored"><a href="#val-block_of_value" class="anchor"></a><code><span><span class="keyword">val</span> block_of_value : <span><a href="#type-llvalue">llvalue</a> <span class="arrow">&#45;&gt;</span></span> <a href="#type-llbasicblock">llbasicblock</a></span></code></div><div class="spec-doc"><p><code>block_of_value v</code> losslessly casts <code>v</code> to an <code>llbasicblock</code>.</p></div></div><h6 id="operations-on-instructions_2"><a href="#operations-on-instructions_2" class="anchor"></a>Operations on instructions</h6><div class="odoc-spec"><div class="spec value" id="val-instr_parent" class="anchored"><a href="#val-instr_parent" class="anchor"></a><code><span><span class="keyword">val</span> instr_parent : <span><a href="#type-llvalue">llvalue</a> <span class="arrow">&#45;&gt;</span></span> <a href="#type-llbasicblock">llbasicblock</a></span></code></div><div class="spec-doc"><p><code>instr_parent i</code> is the enclosing basic block of the instruction <code>i</code>. See the method <code>llvm::Instruction::getParent</code>.</p></div></div><div class="odoc-spec"><div class="spec value" id="val-delete_instruction" class="anchored"><a href="#val-delete_instruction" class="anchor"></a><code><span><span class="keyword">val</span> delete_instruction : <span><a href="#type-llvalue">llvalue</a> <span class="arrow">&#45;&gt;</span></span> unit</span></code></div><div class="spec-doc"><p><code>delete_instruction i</code> deletes the instruction <code>i</code>. * See the method <code>llvm::Instruction::eraseFromParent</code>.</p></div></div><div class="odoc-spec"><div class="spec value" id="val-instr_begin" class="anchored"><a href="#val-instr_begin" class="anchor"></a><code><span><span class="keyword">val</span> instr_begin : <span><a href="#type-llbasicblock">llbasicblock</a> <span class="arrow">&#45;&gt;</span></span> <span><span>( <a href="#type-llbasicblock">llbasicblock</a>, <a href="#type-llvalue">llvalue</a> )</span> <a href="#type-llpos">llpos</a></span></span></code></div><div class="spec-doc"><p><code>instr_begin bb</code> returns the first position in the instruction list of the basic block <code>bb</code>. <code>instr_begin</code> and <code>instr_succ</code> can be used to iterate over the instruction list in order. See the method <code>llvm::BasicBlock::begin</code>.</p></div></div><div class="odoc-spec"><div class="spec value" id="val-instr_succ" class="anchored"><a href="#val-instr_succ" class="anchor"></a><code><span><span class="keyword">val</span> instr_succ : <span><a href="#type-llvalue">llvalue</a> <span class="arrow">&#45;&gt;</span></span> <span><span>( <a href="#type-llbasicblock">llbasicblock</a>, <a href="#type-llvalue">llvalue</a> )</span> <a href="#type-llpos">llpos</a></span></span></code></div><div class="spec-doc"><p><code>instr_succ i</code> returns the instruction list position succeeding <code>Before i</code>. See the method <code>llvm::BasicBlock::iterator::operator++</code>.</p></div></div><div class="odoc-spec"><div class="spec value" id="val-iter_instrs" class="anchored"><a href="#val-iter_instrs" class="anchor"></a><code><span><span class="keyword">val</span> iter_instrs : <span><span>( <span><a href="#type-llvalue">llvalue</a> <span class="arrow">&#45;&gt;</span></span> unit )</span> <span class="arrow">&#45;&gt;</span></span> <span><a href="#type-llbasicblock">llbasicblock</a> <span class="arrow">&#45;&gt;</span></span> unit</span></code></div><div class="spec-doc"><p><code>iter_instrs f bb</code> applies function <code>f</code> to each of the instructions of basic block <code>bb</code> in order. Tail recursive.</p></div></div><div class="odoc-spec"><div class="spec value" id="val-fold_left_instrs" class="anchored"><a href="#val-fold_left_instrs" class="anchor"></a><code><span><span class="keyword">val</span> fold_left_instrs : <span><span>( <span><span class="type-var">'a</span> <span class="arrow">&#45;&gt;</span></span> <span><a href="#type-llvalue">llvalue</a> <span class="arrow">&#45;&gt;</span></span> <span class="type-var">'a</span> )</span> <span class="arrow">&#45;&gt;</span></span> <span><span class="type-var">'a</span> <span class="arrow">&#45;&gt;</span></span> <span><a href="#type-llbasicblock">llbasicblock</a> <span class="arrow">&#45;&gt;</span></span> <span class="type-var">'a</span></span></code></div><div class="spec-doc"><p><code>fold_left_instrs f init bb</code> is <code>f (... (f init g1) ...) gN</code> where <code>g1,...,gN</code> are the instructions of basic block <code>bb</code>. Tail recursive.</p></div></div><div class="odoc-spec"><div class="spec value" id="val-instr_end" class="anchored"><a href="#val-instr_end" class="anchor"></a><code><span><span class="keyword">val</span> instr_end : <span><a href="#type-llbasicblock">llbasicblock</a> <span class="arrow">&#45;&gt;</span></span> <span><span>( <a href="#type-llbasicblock">llbasicblock</a>, <a href="#type-llvalue">llvalue</a> )</span> <a href="#type-llrev_pos">llrev_pos</a></span></span></code></div><div class="spec-doc"><p><code>instr_end bb</code> returns the last position in the instruction list of the basic block <code>bb</code>. <code>instr_end</code> and <code>instr_pred</code> can be used to iterate over the instruction list in reverse. See the method <code>llvm::BasicBlock::end</code>.</p></div></div><div class="odoc-spec"><div class="spec value" id="val-instr_pred" class="anchored"><a href="#val-instr_pred" class="anchor"></a><code><span><span class="keyword">val</span> instr_pred : <span><a href="#type-llvalue">llvalue</a> <span class="arrow">&#45;&gt;</span></span> <span><span>( <a href="#type-llbasicblock">llbasicblock</a>, <a href="#type-llvalue">llvalue</a> )</span> <a href="#type-llrev_pos">llrev_pos</a></span></span></code></div><div class="spec-doc"><p><code>instr_pred i</code> returns the instruction list position preceding <code>After i</code>. See the method <code>llvm::BasicBlock::iterator::operator--</code>.</p></div></div><div class="odoc-spec"><div class="spec value" id="val-fold_right_instrs" class="anchored"><a href="#val-fold_right_instrs" class="anchor"></a><code><span><span class="keyword">val</span> fold_right_instrs : <span><span>( <span><a href="#type-llvalue">llvalue</a> <span class="arrow">&#45;&gt;</span></span> <span><span class="type-var">'a</span> <span class="arrow">&#45;&gt;</span></span> <span class="type-var">'a</span> )</span> <span class="arrow">&#45;&gt;</span></span> <span><a href="#type-llbasicblock">llbasicblock</a> <span class="arrow">&#45;&gt;</span></span> <span><span class="type-var">'a</span> <span class="arrow">&#45;&gt;</span></span> <span class="type-var">'a</span></span></code></div><div class="spec-doc"><p><code>fold_right_instrs f bb init</code> is <code>f (... (f init fN) ...) f1</code> where <code>f1,...,fN</code> are the instructions of basic block <code>bb</code>. Tail recursive.</p></div></div><div class="odoc-spec"><div class="spec value" id="val-instr_opcode" class="anchored"><a href="#val-instr_opcode" class="anchor"></a><code><span><span class="keyword">val</span> instr_opcode : <span><a href="#type-llvalue">llvalue</a> <span class="arrow">&#45;&gt;</span></span> <a href="Opcode/index.html#type-t">Opcode.t</a></span></code></div><div class="spec-doc"><p><code>inst_opcode i</code> returns the <code>Opcode.t</code> corresponding to instruction <code>i</code>, or <code>Opcode.Invalid</code> if <code>i</code> is not an instruction.</p></div></div><div class="odoc-spec"><div class="spec value" id="val-icmp_predicate" class="anchored"><a href="#val-icmp_predicate" class="anchor"></a><code><span><span class="keyword">val</span> icmp_predicate : <span><a href="#type-llvalue">llvalue</a> <span class="arrow">&#45;&gt;</span></span> <span><a href="Icmp/index.html#type-t">Icmp.t</a> option</span></span></code></div><div class="spec-doc"><p><code>icmp_predicate i</code> returns the <code>Icmp.t</code> corresponding to an <code>icmp</code> instruction <code>i</code>.</p></div></div><div class="odoc-spec"><div class="spec value" id="val-fcmp_predicate" class="anchored"><a href="#val-fcmp_predicate" class="anchor"></a><code><span><span class="keyword">val</span> fcmp_predicate : <span><a href="#type-llvalue">llvalue</a> <span class="arrow">&#45;&gt;</span></span> <span><a href="Fcmp/index.html#type-t">Fcmp.t</a> option</span></span></code></div><div class="spec-doc"><p><code>fcmp_predicate i</code> returns the <code>fcmp.t</code> corresponding to an <code>fcmp</code> instruction <code>i</code>.</p></div></div><div class="odoc-spec"><div class="spec value" id="val-instr_clone" class="anchored"><a href="#val-instr_clone" class="anchor"></a><code><span><span class="keyword">val</span> instr_clone : <span><a href="#type-llvalue">llvalue</a> <span class="arrow">&#45;&gt;</span></span> <a href="#type-llvalue">llvalue</a></span></code></div><div class="spec-doc"><p><code>inst_clone i</code> returns a copy of instruction <code>i</code>, The instruction has no parent, and no name. See the method <code>llvm::Instruction::clone</code>.</p></div></div><h6 id="operations-on-call-sites"><a href="#operations-on-call-sites" class="anchor"></a>Operations on call sites</h6><div class="odoc-spec"><div class="spec value" id="val-instruction_call_conv" class="anchored"><a href="#val-instruction_call_conv" class="anchor"></a><code><span><span class="keyword">val</span> instruction_call_conv : <span><a href="#type-llvalue">llvalue</a> <span class="arrow">&#45;&gt;</span></span> int</span></code></div><div class="spec-doc"><p><code>instruction_call_conv ci</code> is the calling convention for the call or invoke instruction <code>ci</code>, which may be one of the values from the module <a href="CallConv/index.html"><code>CallConv</code></a>. See the method <code>llvm::CallInst::getCallingConv</code> and <code>llvm::InvokeInst::getCallingConv</code>.</p></div></div><div class="odoc-spec"><div class="spec value" id="val-set_instruction_call_conv" class="anchored"><a href="#val-set_instruction_call_conv" class="anchor"></a><code><span><span class="keyword">val</span> set_instruction_call_conv : <span>int <span class="arrow">&#45;&gt;</span></span> <span><a href="#type-llvalue">llvalue</a> <span class="arrow">&#45;&gt;</span></span> unit</span></code></div><div class="spec-doc"><p><code>set_instruction_call_conv cc ci</code> sets the calling convention for the call or invoke instruction <code>ci</code> to the integer <code>cc</code>, which can be one of the values from the module <a href="CallConv/index.html"><code>CallConv</code></a>. See the method <code>llvm::CallInst::setCallingConv</code> and <code>llvm::InvokeInst::setCallingConv</code>.</p></div></div><div class="odoc-spec"><div class="spec value" id="val-add_call_site_attr" class="anchored"><a href="#val-add_call_site_attr" class="anchor"></a><code><span><span class="keyword">val</span> add_call_site_attr : <span><a href="#type-llvalue">llvalue</a> <span class="arrow">&#45;&gt;</span></span> <span><a href="#type-llattribute">llattribute</a> <span class="arrow">&#45;&gt;</span></span> <span><a href="AttrIndex/index.html#type-t">AttrIndex.t</a> <span class="arrow">&#45;&gt;</span></span> unit</span></code></div><div class="spec-doc"><p><code>add_call_site_attr f a i</code> adds attribute <code>a</code> to the call instruction <code>ci</code> at position <code>i</code>.</p></div></div><div class="odoc-spec"><div class="spec value" id="val-call_site_attrs" class="anchored"><a href="#val-call_site_attrs" class="anchor"></a><code><span><span class="keyword">val</span> call_site_attrs : <span><a href="#type-llvalue">llvalue</a> <span class="arrow">&#45;&gt;</span></span> <span><a href="AttrIndex/index.html#type-t">AttrIndex.t</a> <span class="arrow">&#45;&gt;</span></span> <span><a href="#type-llattribute">llattribute</a> array</span></span></code></div><div class="spec-doc"><p><code>call_site_attr f i</code> returns the attributes for the call instruction <code>ci</code> at position <code>i</code>.</p></div></div><div class="odoc-spec"><div class="spec value" id="val-remove_enum_call_site_attr" class="anchored"><a href="#val-remove_enum_call_site_attr" class="anchor"></a><code><span><span class="keyword">val</span> remove_enum_call_site_attr : <span><a href="#type-llvalue">llvalue</a> <span class="arrow">&#45;&gt;</span></span> <span><a href="#type-llattrkind">llattrkind</a> <span class="arrow">&#45;&gt;</span></span> <span><a href="AttrIndex/index.html#type-t">AttrIndex.t</a> <span class="arrow">&#45;&gt;</span></span> unit</span></code></div><div class="spec-doc"><p><code>remove_enum_call_site_attr f k i</code> removes enum attribute with kind <code>k</code> from the call instruction <code>ci</code> at position <code>i</code>.</p></div></div><div class="odoc-spec"><div class="spec value" id="val-remove_string_call_site_attr" class="anchored"><a href="#val-remove_string_call_site_attr" class="anchor"></a><code><span><span class="keyword">val</span> remove_string_call_site_attr : <span><a href="#type-llvalue">llvalue</a> <span class="arrow">&#45;&gt;</span></span> <span>string <span class="arrow">&#45;&gt;</span></span> <span><a href="AttrIndex/index.html#type-t">AttrIndex.t</a> <span class="arrow">&#45;&gt;</span></span> unit</span></code></div><div class="spec-doc"><p><code>remove_string_call_site_attr f k i</code> removes string attribute with kind <code>k</code> from the call instruction <code>ci</code> at position <code>i</code>.</p></div></div><h6 id="operations-on-call-and-invoke-instructions-(only)"><a href="#operations-on-call-and-invoke-instructions-(only)" class="anchor"></a>Operations on call and invoke instructions (only)</h6><div class="odoc-spec"><div class="spec value" id="val-num_arg_operands" class="anchored"><a href="#val-num_arg_operands" class="anchor"></a><code><span><span class="keyword">val</span> num_arg_operands : <span><a href="#type-llvalue">llvalue</a> <span class="arrow">&#45;&gt;</span></span> int</span></code></div><div class="spec-doc"><p><code>num_arg_operands ci</code> returns the number of arguments for the call or invoke instruction <code>ci</code>. See the method <code>llvm::CallInst::getNumArgOperands</code>.</p></div></div><div class="odoc-spec"><div class="spec value" id="val-is_tail_call" class="anchored"><a href="#val-is_tail_call" class="anchor"></a><code><span><span class="keyword">val</span> is_tail_call : <span><a href="#type-llvalue">llvalue</a> <span class="arrow">&#45;&gt;</span></span> bool</span></code></div><div class="spec-doc"><p><code>is_tail_call ci</code> is <code>true</code> if the call instruction <code>ci</code> is flagged as eligible for tail call optimization, <code>false</code> otherwise. See the method <code>llvm::CallInst::isTailCall</code>.</p></div></div><div class="odoc-spec"><div class="spec value" id="val-set_tail_call" class="anchored"><a href="#val-set_tail_call" class="anchor"></a><code><span><span class="keyword">val</span> set_tail_call : <span>bool <span class="arrow">&#45;&gt;</span></span> <span><a href="#type-llvalue">llvalue</a> <span class="arrow">&#45;&gt;</span></span> unit</span></code></div><div class="spec-doc"><p><code>set_tail_call tc ci</code> flags the call instruction <code>ci</code> as eligible for tail call optimization if <code>tc</code> is <code>true</code>, clears otherwise. See the method <code>llvm::CallInst::setTailCall</code>.</p></div></div><div class="odoc-spec"><div class="spec value" id="val-get_normal_dest" class="anchored"><a href="#val-get_normal_dest" class="anchor"></a><code><span><span class="keyword">val</span> get_normal_dest : <span><a href="#type-llvalue">llvalue</a> <span class="arrow">&#45;&gt;</span></span> <a href="#type-llbasicblock">llbasicblock</a></span></code></div><div class="spec-doc"><p><code>get_normal_dest ii</code> is the normal destination basic block of an invoke instruction. See the method <code>llvm::InvokeInst::getNormalDest()</code>.</p></div></div><div class="odoc-spec"><div class="spec value" id="val-get_unwind_dest" class="anchored"><a href="#val-get_unwind_dest" class="anchor"></a><code><span><span class="keyword">val</span> get_unwind_dest : <span><a href="#type-llvalue">llvalue</a> <span class="arrow">&#45;&gt;</span></span> <a href="#type-llbasicblock">llbasicblock</a></span></code></div><div class="spec-doc"><p><code>get_unwind_dest ii</code> is the unwind destination basic block of an invoke instruction. See the method <code>llvm::InvokeInst::getUnwindDest()</code>.</p></div></div><h6 id="operations-on-load/store-instructions-(only)"><a href="#operations-on-load/store-instructions-(only)" class="anchor"></a>Operations on load/store instructions (only)</h6><div class="odoc-spec"><div class="spec value" id="val-is_volatile" class="anchored"><a href="#val-is_volatile" class="anchor"></a><code><span><span class="keyword">val</span> is_volatile : <span><a href="#type-llvalue">llvalue</a> <span class="arrow">&#45;&gt;</span></span> bool</span></code></div><div class="spec-doc"><p><code>is_volatile i</code> is <code>true</code> if the load or store instruction <code>i</code> is marked as volatile. See the methods <code>llvm::LoadInst::isVolatile</code> and <code>llvm::StoreInst::isVolatile</code>.</p></div></div><div class="odoc-spec"><div class="spec value" id="val-set_volatile" class="anchored"><a href="#val-set_volatile" class="anchor"></a><code><span><span class="keyword">val</span> set_volatile : <span>bool <span class="arrow">&#45;&gt;</span></span> <span><a href="#type-llvalue">llvalue</a> <span class="arrow">&#45;&gt;</span></span> unit</span></code></div><div class="spec-doc"><p><code>set_volatile v i</code> marks the load or store instruction <code>i</code> as volatile if <code>v</code> is <code>true</code>, unmarks otherwise. See the methods <code>llvm::LoadInst::setVolatile</code> and <code>llvm::StoreInst::setVolatile</code>.</p></div></div><h6 id="operations-on-terminators"><a href="#operations-on-terminators" class="anchor"></a>Operations on terminators</h6><div class="odoc-spec"><div class="spec value" id="val-is_terminator" class="anchored"><a href="#val-is_terminator" class="anchor"></a><code><span><span class="keyword">val</span> is_terminator : <span><a href="#type-llvalue">llvalue</a> <span class="arrow">&#45;&gt;</span></span> bool</span></code></div><div class="spec-doc"><p><code>is_terminator v</code> returns true if the instruction <code>v</code> is a terminator.</p></div></div><div class="odoc-spec"><div class="spec value" id="val-successor" class="anchored"><a href="#val-successor" class="anchor"></a><code><span><span class="keyword">val</span> successor : <span><a href="#type-llvalue">llvalue</a> <span class="arrow">&#45;&gt;</span></span> <span>int <span class="arrow">&#45;&gt;</span></span> <a href="#type-llbasicblock">llbasicblock</a></span></code></div><div class="spec-doc"><p><code>successor v i</code> returns the successor at index <code>i</code> for the value <code>v</code>. See the method <code>llvm::Instruction::getSuccessor</code>.</p></div></div><div class="odoc-spec"><div class="spec value" id="val-set_successor" class="anchored"><a href="#val-set_successor" class="anchor"></a><code><span><span class="keyword">val</span> set_successor : <span><a href="#type-llvalue">llvalue</a> <span class="arrow">&#45;&gt;</span></span> <span>int <span class="arrow">&#45;&gt;</span></span> <span><a href="#type-llbasicblock">llbasicblock</a> <span class="arrow">&#45;&gt;</span></span> unit</span></code></div><div class="spec-doc"><p><code>set_successor v i o</code> sets the successor of the value <code>v</code> at the index <code>i</code> to the value <code>o</code>. See the method <code>llvm::Instruction::setSuccessor</code>.</p></div></div><div class="odoc-spec"><div class="spec value" id="val-num_successors" class="anchored"><a href="#val-num_successors" class="anchor"></a><code><span><span class="keyword">val</span> num_successors : <span><a href="#type-llvalue">llvalue</a> <span class="arrow">&#45;&gt;</span></span> int</span></code></div><div class="spec-doc"><p><code>num_successors v</code> returns the number of successors for the value <code>v</code>. See the method <code>llvm::Instruction::getNumSuccessors</code>.</p></div></div><div class="odoc-spec"><div class="spec value" id="val-successors" class="anchored"><a href="#val-successors" class="anchor"></a><code><span><span class="keyword">val</span> successors : <span><a href="#type-llvalue">llvalue</a> <span class="arrow">&#45;&gt;</span></span> <span><a href="#type-llbasicblock">llbasicblock</a> array</span></span></code></div><div class="spec-doc"><p><code>successors v</code> returns the successors of <code>v</code>.</p></div></div><div class="odoc-spec"><div class="spec value" id="val-iter_successors" class="anchored"><a href="#val-iter_successors" class="anchor"></a><code><span><span class="keyword">val</span> iter_successors : <span><span>( <span><a href="#type-llbasicblock">llbasicblock</a> <span class="arrow">&#45;&gt;</span></span> unit )</span> <span class="arrow">&#45;&gt;</span></span> <span><a href="#type-llvalue">llvalue</a> <span class="arrow">&#45;&gt;</span></span> unit</span></code></div><div class="spec-doc"><p><code>iter_successors f v</code> applies function f to each successor <code>v</code> in order. Tail recursive.</p></div></div><div class="odoc-spec"><div class="spec value" id="val-fold_successors" class="anchored"><a href="#val-fold_successors" class="anchor"></a><code><span><span class="keyword">val</span> fold_successors : <span><span>( <span><a href="#type-llbasicblock">llbasicblock</a> <span class="arrow">&#45;&gt;</span></span> <span><span class="type-var">'a</span> <span class="arrow">&#45;&gt;</span></span> <span class="type-var">'a</span> )</span> <span class="arrow">&#45;&gt;</span></span> <span><a href="#type-llvalue">llvalue</a> <span class="arrow">&#45;&gt;</span></span> <span><span class="type-var">'a</span> <span class="arrow">&#45;&gt;</span></span> <span class="type-var">'a</span></span></code></div><div class="spec-doc"><p><code>fold_successors f v init</code> is <code>f (... (f init vN) ...) v1</code> where <code>v1,...,vN</code> are the successors of <code>v</code>. Tail recursive.</p></div></div><h6 id="operations-on-branches"><a href="#operations-on-branches" class="anchor"></a>Operations on branches</h6><div class="odoc-spec"><div class="spec value" id="val-is_conditional" class="anchored"><a href="#val-is_conditional" class="anchor"></a><code><span><span class="keyword">val</span> is_conditional : <span><a href="#type-llvalue">llvalue</a> <span class="arrow">&#45;&gt;</span></span> bool</span></code></div><div class="spec-doc"><p><code>is_conditional v</code> returns true if the branch instruction <code>v</code> is conditional. See the method <code>llvm::BranchInst::isConditional</code>.</p></div></div><div class="odoc-spec"><div class="spec value" id="val-condition" class="anchored"><a href="#val-condition" class="anchor"></a><code><span><span class="keyword">val</span> condition : <span><a href="#type-llvalue">llvalue</a> <span class="arrow">&#45;&gt;</span></span> <a href="#type-llvalue">llvalue</a></span></code></div><div class="spec-doc"><p><code>condition v</code> return the condition of the branch instruction <code>v</code>. See the method <code>llvm::BranchInst::getCondition</code>.</p></div></div><div class="odoc-spec"><div class="spec value" id="val-set_condition" class="anchored"><a href="#val-set_condition" class="anchor"></a><code><span><span class="keyword">val</span> set_condition : <span><a href="#type-llvalue">llvalue</a> <span class="arrow">&#45;&gt;</span></span> <span><a href="#type-llvalue">llvalue</a> <span class="arrow">&#45;&gt;</span></span> unit</span></code></div><div class="spec-doc"><p><code>set_condition v c</code> sets the condition of the branch instruction <code>v</code> to the value <code>c</code>. See the method <code>llvm::BranchInst::setCondition</code>.</p></div></div><div class="odoc-spec"><div class="spec value" id="val-get_branch" class="anchored"><a href="#val-get_branch" class="anchor"></a><code><span><span class="keyword">val</span> get_branch : 
  <span><a href="#type-llvalue">llvalue</a> <span class="arrow">&#45;&gt;</span></span>
  <span><span>[ <span>`Conditional of <a href="#type-llvalue">llvalue</a> * <a href="#type-llbasicblock">llbasicblock</a> * <a href="#type-llbasicblock">llbasicblock</a></span>
  <span><span>| `Unconditional</span> of <a href="#type-llbasicblock">llbasicblock</a></span> ]</span>
    option</span></span></code></div><div class="spec-doc"><p><code>get_branch c</code> returns a description of the branch instruction <code>c</code>.</p></div></div><h6 id="operations-on-phi-nodes"><a href="#operations-on-phi-nodes" class="anchor"></a>Operations on phi nodes</h6><div class="odoc-spec"><div class="spec value" id="val-add_incoming" class="anchored"><a href="#val-add_incoming" class="anchor"></a><code><span><span class="keyword">val</span> add_incoming : <span><span>(<a href="#type-llvalue">llvalue</a> * <a href="#type-llbasicblock">llbasicblock</a>)</span> <span class="arrow">&#45;&gt;</span></span> <span><a href="#type-llvalue">llvalue</a> <span class="arrow">&#45;&gt;</span></span> unit</span></code></div><div class="spec-doc"><p><code>add_incoming (v, bb) pn</code> adds the value <code>v</code> to the phi node <code>pn</code> for use with branches from <code>bb</code>. See the method <code>llvm::PHINode::addIncoming</code>.</p></div></div><div class="odoc-spec"><div class="spec value" id="val-incoming" class="anchored"><a href="#val-incoming" class="anchor"></a><code><span><span class="keyword">val</span> incoming : <span><a href="#type-llvalue">llvalue</a> <span class="arrow">&#45;&gt;</span></span> <span><span>(<a href="#type-llvalue">llvalue</a> * <a href="#type-llbasicblock">llbasicblock</a>)</span> list</span></span></code></div><div class="spec-doc"><p><code>incoming pn</code> returns the list of value-block pairs for phi node <code>pn</code>. See the method <code>llvm::PHINode::getIncomingValue</code>.</p></div></div><h6 id="instruction-builders"><a href="#instruction-builders" class="anchor"></a>Instruction builders</h6><div class="odoc-spec"><div class="spec value" id="val-builder" class="anchored"><a href="#val-builder" class="anchor"></a><code><span><span class="keyword">val</span> builder : <span><a href="#type-llcontext">llcontext</a> <span class="arrow">&#45;&gt;</span></span> <a href="#type-llbuilder">llbuilder</a></span></code></div><div class="spec-doc"><p><code>builder context</code> creates an instruction builder with no position in the context <code>context</code>. It is invalid to use this builder until its position is set with <a href="#val-position_before"><code>position_before</code></a> or <a href="#val-position_at_end"><code>position_at_end</code></a>. See the constructor for <code>llvm::LLVMBuilder</code>.</p></div></div><div class="odoc-spec"><div class="spec value" id="val-builder_at" class="anchored"><a href="#val-builder_at" class="anchor"></a><code><span><span class="keyword">val</span> builder_at : <span><a href="#type-llcontext">llcontext</a> <span class="arrow">&#45;&gt;</span></span> <span><span><span>( <a href="#type-llbasicblock">llbasicblock</a>, <a href="#type-llvalue">llvalue</a> )</span> <a href="#type-llpos">llpos</a></span> <span class="arrow">&#45;&gt;</span></span> <a href="#type-llbuilder">llbuilder</a></span></code></div><div class="spec-doc"><p><code>builder_at ip</code> creates an instruction builder positioned at <code>ip</code>. See the constructor for <code>llvm::LLVMBuilder</code>.</p></div></div><div class="odoc-spec"><div class="spec value" id="val-builder_before" class="anchored"><a href="#val-builder_before" class="anchor"></a><code><span><span class="keyword">val</span> builder_before : <span><a href="#type-llcontext">llcontext</a> <span class="arrow">&#45;&gt;</span></span> <span><a href="#type-llvalue">llvalue</a> <span class="arrow">&#45;&gt;</span></span> <a href="#type-llbuilder">llbuilder</a></span></code></div><div class="spec-doc"><p><code>builder_before ins</code> creates an instruction builder positioned before the instruction <code>isn</code>. See the constructor for <code>llvm::LLVMBuilder</code>.</p></div></div><div class="odoc-spec"><div class="spec value" id="val-builder_at_end" class="anchored"><a href="#val-builder_at_end" class="anchor"></a><code><span><span class="keyword">val</span> builder_at_end : <span><a href="#type-llcontext">llcontext</a> <span class="arrow">&#45;&gt;</span></span> <span><a href="#type-llbasicblock">llbasicblock</a> <span class="arrow">&#45;&gt;</span></span> <a href="#type-llbuilder">llbuilder</a></span></code></div><div class="spec-doc"><p><code>builder_at_end bb</code> creates an instruction builder positioned at the end of the basic block <code>bb</code>. See the constructor for <code>llvm::LLVMBuilder</code>.</p></div></div><div class="odoc-spec"><div class="spec value" id="val-position_builder" class="anchored"><a href="#val-position_builder" class="anchor"></a><code><span><span class="keyword">val</span> position_builder : <span><span><span>( <a href="#type-llbasicblock">llbasicblock</a>, <a href="#type-llvalue">llvalue</a> )</span> <a href="#type-llpos">llpos</a></span> <span class="arrow">&#45;&gt;</span></span> <span><a href="#type-llbuilder">llbuilder</a> <span class="arrow">&#45;&gt;</span></span> unit</span></code></div><div class="spec-doc"><p><code>position_builder ip bb</code> moves the instruction builder <code>bb</code> to the position <code>ip</code>. See the constructor for <code>llvm::LLVMBuilder</code>.</p></div></div><div class="odoc-spec"><div class="spec value" id="val-position_before" class="anchored"><a href="#val-position_before" class="anchor"></a><code><span><span class="keyword">val</span> position_before : <span><a href="#type-llvalue">llvalue</a> <span class="arrow">&#45;&gt;</span></span> <span><a href="#type-llbuilder">llbuilder</a> <span class="arrow">&#45;&gt;</span></span> unit</span></code></div><div class="spec-doc"><p><code>position_before ins b</code> moves the instruction builder <code>b</code> to before the instruction <code>isn</code>. See the method <code>llvm::LLVMBuilder::SetInsertPoint</code>.</p></div></div><div class="odoc-spec"><div class="spec value" id="val-position_at_end" class="anchored"><a href="#val-position_at_end" class="anchor"></a><code><span><span class="keyword">val</span> position_at_end : <span><a href="#type-llbasicblock">llbasicblock</a> <span class="arrow">&#45;&gt;</span></span> <span><a href="#type-llbuilder">llbuilder</a> <span class="arrow">&#45;&gt;</span></span> unit</span></code></div><div class="spec-doc"><p><code>position_at_end bb b</code> moves the instruction builder <code>b</code> to the end of the basic block <code>bb</code>. See the method <code>llvm::LLVMBuilder::SetInsertPoint</code>.</p></div></div><div class="odoc-spec"><div class="spec value" id="val-insertion_block" class="anchored"><a href="#val-insertion_block" class="anchor"></a><code><span><span class="keyword">val</span> insertion_block : <span><a href="#type-llbuilder">llbuilder</a> <span class="arrow">&#45;&gt;</span></span> <a href="#type-llbasicblock">llbasicblock</a></span></code></div><div class="spec-doc"><p><code>insertion_block b</code> returns the basic block that the builder <code>b</code> is positioned to insert into. Raises <code>Not_Found</code> if the instruction builder is uninitialized. See the method <code>llvm::LLVMBuilder::GetInsertBlock</code>.</p></div></div><div class="odoc-spec"><div class="spec value" id="val-insert_into_builder" class="anchored"><a href="#val-insert_into_builder" class="anchor"></a><code><span><span class="keyword">val</span> insert_into_builder : <span><a href="#type-llvalue">llvalue</a> <span class="arrow">&#45;&gt;</span></span> <span>string <span class="arrow">&#45;&gt;</span></span> <span><a href="#type-llbuilder">llbuilder</a> <span class="arrow">&#45;&gt;</span></span> unit</span></code></div><div class="spec-doc"><p><code>insert_into_builder i name b</code> inserts the specified instruction <code>i</code> at the position specified by the instruction builder <code>b</code>. See the method <code>llvm::LLVMBuilder::Insert</code>.</p></div></div><h6 id="metadata"><a href="#metadata" class="anchor"></a>Metadata</h6><div class="odoc-spec"><div class="spec value" id="val-set_current_debug_location" class="anchored"><a href="#val-set_current_debug_location" class="anchor"></a><code><span><span class="keyword">val</span> set_current_debug_location : <span><a href="#type-llbuilder">llbuilder</a> <span class="arrow">&#45;&gt;</span></span> <span><a href="#type-llvalue">llvalue</a> <span class="arrow">&#45;&gt;</span></span> unit</span></code></div><div class="spec-doc"><p><code>set_current_debug_location b md</code> sets the current debug location <code>md</code> in the builder <code>b</code>. See the method <code>llvm::IRBuilder::SetDebugLocation</code>.</p></div></div><div class="odoc-spec"><div class="spec value" id="val-clear_current_debug_location" class="anchored"><a href="#val-clear_current_debug_location" class="anchor"></a><code><span><span class="keyword">val</span> clear_current_debug_location : <span><a href="#type-llbuilder">llbuilder</a> <span class="arrow">&#45;&gt;</span></span> unit</span></code></div><div class="spec-doc"><p><code>clear_current_debug_location b</code> clears the current debug location in the builder <code>b</code>.</p></div></div><div class="odoc-spec"><div class="spec value" id="val-current_debug_location" class="anchored"><a href="#val-current_debug_location" class="anchor"></a><code><span><span class="keyword">val</span> current_debug_location : <span><a href="#type-llbuilder">llbuilder</a> <span class="arrow">&#45;&gt;</span></span> <span><a href="#type-llvalue">llvalue</a> option</span></span></code></div><div class="spec-doc"><p><code>current_debug_location b</code> returns the current debug location, or None if none is currently set. See the method <code>llvm::IRBuilder::GetDebugLocation</code>.</p></div></div><div class="odoc-spec"><div class="spec value" id="val-set_inst_debug_location" class="anchored"><a href="#val-set_inst_debug_location" class="anchor"></a><code><span><span class="keyword">val</span> set_inst_debug_location : <span><a href="#type-llbuilder">llbuilder</a> <span class="arrow">&#45;&gt;</span></span> <span><a href="#type-llvalue">llvalue</a> <span class="arrow">&#45;&gt;</span></span> unit</span></code></div><div class="spec-doc"><p><code>set_inst_debug_location b i</code> sets the current debug location of the builder <code>b</code> to the instruction <code>i</code>. See the method <code>llvm::IRBuilder::SetInstDebugLocation</code>.</p></div></div><h6 id="terminators"><a href="#terminators" class="anchor"></a>Terminators</h6><div class="odoc-spec"><div class="spec value" id="val-build_ret_void" class="anchored"><a href="#val-build_ret_void" class="anchor"></a><code><span><span class="keyword">val</span> build_ret_void : <span><a href="#type-llbuilder">llbuilder</a> <span class="arrow">&#45;&gt;</span></span> <a href="#type-llvalue">llvalue</a></span></code></div><div class="spec-doc"><p><code>build_ret_void b</code> creates a <code>ret void</code> instruction at the position specified by the instruction builder <code>b</code>. See the method <code>llvm::LLVMBuilder::CreateRetVoid</code>.</p></div></div><div class="odoc-spec"><div class="spec value" id="val-build_ret" class="anchored"><a href="#val-build_ret" class="anchor"></a><code><span><span class="keyword">val</span> build_ret : <span><a href="#type-llvalue">llvalue</a> <span class="arrow">&#45;&gt;</span></span> <span><a href="#type-llbuilder">llbuilder</a> <span class="arrow">&#45;&gt;</span></span> <a href="#type-llvalue">llvalue</a></span></code></div><div class="spec-doc"><p><code>build_ret v b</code> creates a <code>ret %v</code> instruction at the position specified by the instruction builder <code>b</code>. See the method <code>llvm::LLVMBuilder::CreateRet</code>.</p></div></div><div class="odoc-spec"><div class="spec value" id="val-build_aggregate_ret" class="anchored"><a href="#val-build_aggregate_ret" class="anchor"></a><code><span><span class="keyword">val</span> build_aggregate_ret : <span><span><a href="#type-llvalue">llvalue</a> array</span> <span class="arrow">&#45;&gt;</span></span> <span><a href="#type-llbuilder">llbuilder</a> <span class="arrow">&#45;&gt;</span></span> <a href="#type-llvalue">llvalue</a></span></code></div><div class="spec-doc"><p><code>build_aggregate_ret vs b</code> creates a <code>ret {...} { %v1, %v2, ... } </code> instruction at the position specified by the instruction builder <code>b</code>. See the method <code>llvm::LLVMBuilder::CreateAggregateRet</code>.</p></div></div><div class="odoc-spec"><div class="spec value" id="val-build_br" class="anchored"><a href="#val-build_br" class="anchor"></a><code><span><span class="keyword">val</span> build_br : <span><a href="#type-llbasicblock">llbasicblock</a> <span class="arrow">&#45;&gt;</span></span> <span><a href="#type-llbuilder">llbuilder</a> <span class="arrow">&#45;&gt;</span></span> <a href="#type-llvalue">llvalue</a></span></code></div><div class="spec-doc"><p><code>build_br bb b</code> creates a <code>br %bb</code> instruction at the position specified by the instruction builder <code>b</code>. See the method <code>llvm::LLVMBuilder::CreateBr</code>.</p></div></div><div class="odoc-spec"><div class="spec value" id="val-build_cond_br" class="anchored"><a href="#val-build_cond_br" class="anchor"></a><code><span><span class="keyword">val</span> build_cond_br : 
  <span><a href="#type-llvalue">llvalue</a> <span class="arrow">&#45;&gt;</span></span>
  <span><a href="#type-llbasicblock">llbasicblock</a> <span class="arrow">&#45;&gt;</span></span>
  <span><a href="#type-llbasicblock">llbasicblock</a> <span class="arrow">&#45;&gt;</span></span>
  <span><a href="#type-llbuilder">llbuilder</a> <span class="arrow">&#45;&gt;</span></span>
  <a href="#type-llvalue">llvalue</a></span></code></div><div class="spec-doc"><p><code>build_cond_br cond tbb fbb b</code> creates a <code>br %cond, %tbb, %fbb</code> instruction at the position specified by the instruction builder <code>b</code>. See the method <code>llvm::LLVMBuilder::CreateCondBr</code>.</p></div></div><div class="odoc-spec"><div class="spec value" id="val-build_switch" class="anchored"><a href="#val-build_switch" class="anchor"></a><code><span><span class="keyword">val</span> build_switch : <span><a href="#type-llvalue">llvalue</a> <span class="arrow">&#45;&gt;</span></span> <span><a href="#type-llbasicblock">llbasicblock</a> <span class="arrow">&#45;&gt;</span></span> <span>int <span class="arrow">&#45;&gt;</span></span> <span><a href="#type-llbuilder">llbuilder</a> <span class="arrow">&#45;&gt;</span></span> <a href="#type-llvalue">llvalue</a></span></code></div><div class="spec-doc"><p><code>build_switch case elsebb count b</code> creates an empty <code>switch %case, %elsebb</code> instruction at the position specified by the instruction builder <code>b</code> with space reserved for <code>count</code> cases. See the method <code>llvm::LLVMBuilder::CreateSwitch</code>.</p></div></div><div class="odoc-spec"><div class="spec value" id="val-build_malloc" class="anchored"><a href="#val-build_malloc" class="anchor"></a><code><span><span class="keyword">val</span> build_malloc : <span><a href="#type-lltype">lltype</a> <span class="arrow">&#45;&gt;</span></span> <span>string <span class="arrow">&#45;&gt;</span></span> <span><a href="#type-llbuilder">llbuilder</a> <span class="arrow">&#45;&gt;</span></span> <a href="#type-llvalue">llvalue</a></span></code></div><div class="spec-doc"><p><code>build_malloc ty name b</code> creates an <code>malloc</code> instruction at the position specified by the instruction builder <code>b</code>. See the method <code>llvm::CallInst::CreateMalloc</code>.</p></div></div><div class="odoc-spec"><div class="spec value" id="val-build_array_malloc" class="anchored"><a href="#val-build_array_malloc" class="anchor"></a><code><span><span class="keyword">val</span> build_array_malloc : <span><a href="#type-lltype">lltype</a> <span class="arrow">&#45;&gt;</span></span> <span><a href="#type-llvalue">llvalue</a> <span class="arrow">&#45;&gt;</span></span> <span>string <span class="arrow">&#45;&gt;</span></span> <span><a href="#type-llbuilder">llbuilder</a> <span class="arrow">&#45;&gt;</span></span> <a href="#type-llvalue">llvalue</a></span></code></div><div class="spec-doc"><p><code>build_array_malloc ty val name b</code> creates an <code>array malloc</code> instruction at the position specified by the instruction builder <code>b</code>. See the method <code>llvm::CallInst::CreateArrayMalloc</code>.</p></div></div><div class="odoc-spec"><div class="spec value" id="val-build_free" class="anchored"><a href="#val-build_free" class="anchor"></a><code><span><span class="keyword">val</span> build_free : <span><a href="#type-llvalue">llvalue</a> <span class="arrow">&#45;&gt;</span></span> <span><a href="#type-llbuilder">llbuilder</a> <span class="arrow">&#45;&gt;</span></span> <a href="#type-llvalue">llvalue</a></span></code></div><div class="spec-doc"><p><code>build_free p b</code> creates a <code>free</code> instruction at the position specified by the instruction builder <code>b</code>. See the method <code>llvm::LLVMBuilder::CreateFree</code>.</p></div></div><div class="odoc-spec"><div class="spec value" id="val-add_case" class="anchored"><a href="#val-add_case" class="anchor"></a><code><span><span class="keyword">val</span> add_case : <span><a href="#type-llvalue">llvalue</a> <span class="arrow">&#45;&gt;</span></span> <span><a href="#type-llvalue">llvalue</a> <span class="arrow">&#45;&gt;</span></span> <span><a href="#type-llbasicblock">llbasicblock</a> <span class="arrow">&#45;&gt;</span></span> unit</span></code></div><div class="spec-doc"><p><code>add_case sw onval bb</code> causes switch instruction <code>sw</code> to branch to <code>bb</code> when its input matches the constant <code>onval</code>. See the method <code>llvm::SwitchInst::addCase</code>. *</p></div></div><div class="odoc-spec"><div class="spec value" id="val-switch_default_dest" class="anchored"><a href="#val-switch_default_dest" class="anchor"></a><code><span><span class="keyword">val</span> switch_default_dest : <span><a href="#type-llvalue">llvalue</a> <span class="arrow">&#45;&gt;</span></span> <a href="#type-llbasicblock">llbasicblock</a></span></code></div><div class="spec-doc"><p><code>switch_default_dest sw</code> returns the default destination of the <code>switch</code> instruction. See the method <code>llvm:;SwitchInst::getDefaultDest</code>. *</p></div></div><div class="odoc-spec"><div class="spec value" id="val-build_indirect_br" class="anchored"><a href="#val-build_indirect_br" class="anchor"></a><code><span><span class="keyword">val</span> build_indirect_br : <span><a href="#type-llvalue">llvalue</a> <span class="arrow">&#45;&gt;</span></span> <span>int <span class="arrow">&#45;&gt;</span></span> <span><a href="#type-llbuilder">llbuilder</a> <span class="arrow">&#45;&gt;</span></span> <a href="#type-llvalue">llvalue</a></span></code></div><div class="spec-doc"><p><code>build_indirect_br addr count b</code> creates a <code>indirectbr %addr</code> instruction at the position specified by the instruction builder <code>b</code> with space reserved for <code>count</code> destinations. See the method <code>llvm::LLVMBuilder::CreateIndirectBr</code>.</p></div></div><div class="odoc-spec"><div class="spec value" id="val-add_destination" class="anchored"><a href="#val-add_destination" class="anchor"></a><code><span><span class="keyword">val</span> add_destination : <span><a href="#type-llvalue">llvalue</a> <span class="arrow">&#45;&gt;</span></span> <span><a href="#type-llbasicblock">llbasicblock</a> <span class="arrow">&#45;&gt;</span></span> unit</span></code></div><div class="spec-doc"><p><code>add_destination br bb</code> adds the basic block <code>bb</code> as a possible branch location for the indirectbr instruction <code>br</code>. See the method <code>llvm::IndirectBrInst::addDestination</code>. *</p></div></div><div class="odoc-spec"><div class="spec value" id="val-build_invoke" class="anchored"><a href="#val-build_invoke" class="anchor"></a><code><span><span class="keyword">val</span> build_invoke : 
  <span><a href="#type-llvalue">llvalue</a> <span class="arrow">&#45;&gt;</span></span>
  <span><span><a href="#type-llvalue">llvalue</a> array</span> <span class="arrow">&#45;&gt;</span></span>
  <span><a href="#type-llbasicblock">llbasicblock</a> <span class="arrow">&#45;&gt;</span></span>
  <span><a href="#type-llbasicblock">llbasicblock</a> <span class="arrow">&#45;&gt;</span></span>
  <span>string <span class="arrow">&#45;&gt;</span></span>
  <span><a href="#type-llbuilder">llbuilder</a> <span class="arrow">&#45;&gt;</span></span>
  <a href="#type-llvalue">llvalue</a></span></code></div><div class="spec-doc"><p><code>build_invoke fn args tobb unwindbb name b</code> creates an <code>%name = invoke %fn(args) to %tobb unwind %unwindbb</code> instruction at the position specified by the instruction builder <code>b</code>. See the method <code>llvm::LLVMBuilder::CreateInvoke</code>.</p></div></div><div class="odoc-spec"><div class="spec value" id="val-build_landingpad" class="anchored"><a href="#val-build_landingpad" class="anchor"></a><code><span><span class="keyword">val</span> build_landingpad : 
  <span><a href="#type-lltype">lltype</a> <span class="arrow">&#45;&gt;</span></span>
  <span><a href="#type-llvalue">llvalue</a> <span class="arrow">&#45;&gt;</span></span>
  <span>int <span class="arrow">&#45;&gt;</span></span>
  <span>string <span class="arrow">&#45;&gt;</span></span>
  <span><a href="#type-llbuilder">llbuilder</a> <span class="arrow">&#45;&gt;</span></span>
  <a href="#type-llvalue">llvalue</a></span></code></div><div class="spec-doc"><p><code>build_landingpad ty persfn numclauses name b</code> creates an <code>landingpad</code> instruction at the position specified by the instruction builder <code>b</code>. See the method <code>llvm::LLVMBuilder::CreateLandingPad</code>.</p></div></div><div class="odoc-spec"><div class="spec value" id="val-is_cleanup" class="anchored"><a href="#val-is_cleanup" class="anchor"></a><code><span><span class="keyword">val</span> is_cleanup : <span><a href="#type-llvalue">llvalue</a> <span class="arrow">&#45;&gt;</span></span> bool</span></code></div><div class="spec-doc"><p><code>is_cleanup lp</code> returns <code>true</code> if <code>landingpad</code> instruction lp is a cleanup. See the method <code>llvm::LandingPadInst::isCleanup</code>.</p></div></div><div class="odoc-spec"><div class="spec value" id="val-set_cleanup" class="anchored"><a href="#val-set_cleanup" class="anchor"></a><code><span><span class="keyword">val</span> set_cleanup : <span><a href="#type-llvalue">llvalue</a> <span class="arrow">&#45;&gt;</span></span> <span>bool <span class="arrow">&#45;&gt;</span></span> unit</span></code></div><div class="spec-doc"><p><code>set_cleanup lp</code> sets the cleanup flag in the <code>landingpad</code>instruction. See the method <code>llvm::LandingPadInst::setCleanup</code>.</p></div></div><div class="odoc-spec"><div class="spec value" id="val-add_clause" class="anchored"><a href="#val-add_clause" class="anchor"></a><code><span><span class="keyword">val</span> add_clause : <span><a href="#type-llvalue">llvalue</a> <span class="arrow">&#45;&gt;</span></span> <span><a href="#type-llvalue">llvalue</a> <span class="arrow">&#45;&gt;</span></span> unit</span></code></div><div class="spec-doc"><p><code>add_clause lp clause</code> adds the clause to the <code>landingpad</code>instruction. See the method <code>llvm::LandingPadInst::addClause</code>.</p></div></div><div class="odoc-spec"><div class="spec value" id="val-build_resume" class="anchored"><a href="#val-build_resume" class="anchor"></a><code><span><span class="keyword">val</span> build_resume : <span><a href="#type-llvalue">llvalue</a> <span class="arrow">&#45;&gt;</span></span> <span><a href="#type-llbuilder">llbuilder</a> <span class="arrow">&#45;&gt;</span></span> <a href="#type-llvalue">llvalue</a></span></code></div><div class="spec-doc"><p><code>build_resume exn b</code> builds a <code>resume exn</code> instruction at the position specified by the instruction builder <code>b</code>. See the method <code>llvm::LLVMBuilder::CreateResume</code></p></div></div><div class="odoc-spec"><div class="spec value" id="val-build_unreachable" class="anchored"><a href="#val-build_unreachable" class="anchor"></a><code><span><span class="keyword">val</span> build_unreachable : <span><a href="#type-llbuilder">llbuilder</a> <span class="arrow">&#45;&gt;</span></span> <a href="#type-llvalue">llvalue</a></span></code></div><div class="spec-doc"><p><code>build_unreachable b</code> creates an <code>unreachable</code> instruction at the position specified by the instruction builder <code>b</code>. See the method <code>llvm::LLVMBuilder::CreateUnwind</code>.</p></div></div><h6 id="arithmetic"><a href="#arithmetic" class="anchor"></a>Arithmetic</h6><div class="odoc-spec"><div class="spec value" id="val-build_add" class="anchored"><a href="#val-build_add" class="anchor"></a><code><span><span class="keyword">val</span> build_add : <span><a href="#type-llvalue">llvalue</a> <span class="arrow">&#45;&gt;</span></span> <span><a href="#type-llvalue">llvalue</a> <span class="arrow">&#45;&gt;</span></span> <span>string <span class="arrow">&#45;&gt;</span></span> <span><a href="#type-llbuilder">llbuilder</a> <span class="arrow">&#45;&gt;</span></span> <a href="#type-llvalue">llvalue</a></span></code></div><div class="spec-doc"><p><code>build_add x y name b</code> creates a <code>%name = add %x, %y</code> instruction at the position specified by the instruction builder <code>b</code>. See the method <code>llvm::LLVMBuilder::CreateAdd</code>.</p></div></div><div class="odoc-spec"><div class="spec value" id="val-build_nsw_add" class="anchored"><a href="#val-build_nsw_add" class="anchor"></a><code><span><span class="keyword">val</span> build_nsw_add : <span><a href="#type-llvalue">llvalue</a> <span class="arrow">&#45;&gt;</span></span> <span><a href="#type-llvalue">llvalue</a> <span class="arrow">&#45;&gt;</span></span> <span>string <span class="arrow">&#45;&gt;</span></span> <span><a href="#type-llbuilder">llbuilder</a> <span class="arrow">&#45;&gt;</span></span> <a href="#type-llvalue">llvalue</a></span></code></div><div class="spec-doc"><p><code>build_nsw_add x y name b</code> creates a <code>%name = nsw add %x, %y</code> instruction at the position specified by the instruction builder <code>b</code>. See the method <code>llvm::LLVMBuilder::CreateNSWAdd</code>.</p></div></div><div class="odoc-spec"><div class="spec value" id="val-build_nuw_add" class="anchored"><a href="#val-build_nuw_add" class="anchor"></a><code><span><span class="keyword">val</span> build_nuw_add : <span><a href="#type-llvalue">llvalue</a> <span class="arrow">&#45;&gt;</span></span> <span><a href="#type-llvalue">llvalue</a> <span class="arrow">&#45;&gt;</span></span> <span>string <span class="arrow">&#45;&gt;</span></span> <span><a href="#type-llbuilder">llbuilder</a> <span class="arrow">&#45;&gt;</span></span> <a href="#type-llvalue">llvalue</a></span></code></div><div class="spec-doc"><p><code>build_nuw_add x y name b</code> creates a <code>%name = nuw add %x, %y</code> instruction at the position specified by the instruction builder <code>b</code>. See the method <code>llvm::LLVMBuilder::CreateNUWAdd</code>.</p></div></div><div class="odoc-spec"><div class="spec value" id="val-build_fadd" class="anchored"><a href="#val-build_fadd" class="anchor"></a><code><span><span class="keyword">val</span> build_fadd : <span><a href="#type-llvalue">llvalue</a> <span class="arrow">&#45;&gt;</span></span> <span><a href="#type-llvalue">llvalue</a> <span class="arrow">&#45;&gt;</span></span> <span>string <span class="arrow">&#45;&gt;</span></span> <span><a href="#type-llbuilder">llbuilder</a> <span class="arrow">&#45;&gt;</span></span> <a href="#type-llvalue">llvalue</a></span></code></div><div class="spec-doc"><p><code>build_fadd x y name b</code> creates a <code>%name = fadd %x, %y</code> instruction at the position specified by the instruction builder <code>b</code>. See the method <code>llvm::LLVMBuilder::CreateFAdd</code>.</p></div></div><div class="odoc-spec"><div class="spec value" id="val-build_sub" class="anchored"><a href="#val-build_sub" class="anchor"></a><code><span><span class="keyword">val</span> build_sub : <span><a href="#type-llvalue">llvalue</a> <span class="arrow">&#45;&gt;</span></span> <span><a href="#type-llvalue">llvalue</a> <span class="arrow">&#45;&gt;</span></span> <span>string <span class="arrow">&#45;&gt;</span></span> <span><a href="#type-llbuilder">llbuilder</a> <span class="arrow">&#45;&gt;</span></span> <a href="#type-llvalue">llvalue</a></span></code></div><div class="spec-doc"><p><code>build_sub x y name b</code> creates a <code>%name = sub %x, %y</code> instruction at the position specified by the instruction builder <code>b</code>. See the method <code>llvm::LLVMBuilder::CreateSub</code>.</p></div></div><div class="odoc-spec"><div class="spec value" id="val-build_nsw_sub" class="anchored"><a href="#val-build_nsw_sub" class="anchor"></a><code><span><span class="keyword">val</span> build_nsw_sub : <span><a href="#type-llvalue">llvalue</a> <span class="arrow">&#45;&gt;</span></span> <span><a href="#type-llvalue">llvalue</a> <span class="arrow">&#45;&gt;</span></span> <span>string <span class="arrow">&#45;&gt;</span></span> <span><a href="#type-llbuilder">llbuilder</a> <span class="arrow">&#45;&gt;</span></span> <a href="#type-llvalue">llvalue</a></span></code></div><div class="spec-doc"><p><code>build_nsw_sub x y name b</code> creates a <code>%name = nsw sub %x, %y</code> instruction at the position specified by the instruction builder <code>b</code>. See the method <code>llvm::LLVMBuilder::CreateNSWSub</code>.</p></div></div><div class="odoc-spec"><div class="spec value" id="val-build_nuw_sub" class="anchored"><a href="#val-build_nuw_sub" class="anchor"></a><code><span><span class="keyword">val</span> build_nuw_sub : <span><a href="#type-llvalue">llvalue</a> <span class="arrow">&#45;&gt;</span></span> <span><a href="#type-llvalue">llvalue</a> <span class="arrow">&#45;&gt;</span></span> <span>string <span class="arrow">&#45;&gt;</span></span> <span><a href="#type-llbuilder">llbuilder</a> <span class="arrow">&#45;&gt;</span></span> <a href="#type-llvalue">llvalue</a></span></code></div><div class="spec-doc"><p><code>build_nuw_sub x y name b</code> creates a <code>%name = nuw sub %x, %y</code> instruction at the position specified by the instruction builder <code>b</code>. See the method <code>llvm::LLVMBuilder::CreateNUWSub</code>.</p></div></div><div class="odoc-spec"><div class="spec value" id="val-build_fsub" class="anchored"><a href="#val-build_fsub" class="anchor"></a><code><span><span class="keyword">val</span> build_fsub : <span><a href="#type-llvalue">llvalue</a> <span class="arrow">&#45;&gt;</span></span> <span><a href="#type-llvalue">llvalue</a> <span class="arrow">&#45;&gt;</span></span> <span>string <span class="arrow">&#45;&gt;</span></span> <span><a href="#type-llbuilder">llbuilder</a> <span class="arrow">&#45;&gt;</span></span> <a href="#type-llvalue">llvalue</a></span></code></div><div class="spec-doc"><p><code>build_fsub x y name b</code> creates a <code>%name = fsub %x, %y</code> instruction at the position specified by the instruction builder <code>b</code>. See the method <code>llvm::LLVMBuilder::CreateFSub</code>.</p></div></div><div class="odoc-spec"><div class="spec value" id="val-build_mul" class="anchored"><a href="#val-build_mul" class="anchor"></a><code><span><span class="keyword">val</span> build_mul : <span><a href="#type-llvalue">llvalue</a> <span class="arrow">&#45;&gt;</span></span> <span><a href="#type-llvalue">llvalue</a> <span class="arrow">&#45;&gt;</span></span> <span>string <span class="arrow">&#45;&gt;</span></span> <span><a href="#type-llbuilder">llbuilder</a> <span class="arrow">&#45;&gt;</span></span> <a href="#type-llvalue">llvalue</a></span></code></div><div class="spec-doc"><p><code>build_mul x y name b</code> creates a <code>%name = mul %x, %y</code> instruction at the position specified by the instruction builder <code>b</code>. See the method <code>llvm::LLVMBuilder::CreateMul</code>.</p></div></div><div class="odoc-spec"><div class="spec value" id="val-build_nsw_mul" class="anchored"><a href="#val-build_nsw_mul" class="anchor"></a><code><span><span class="keyword">val</span> build_nsw_mul : <span><a href="#type-llvalue">llvalue</a> <span class="arrow">&#45;&gt;</span></span> <span><a href="#type-llvalue">llvalue</a> <span class="arrow">&#45;&gt;</span></span> <span>string <span class="arrow">&#45;&gt;</span></span> <span><a href="#type-llbuilder">llbuilder</a> <span class="arrow">&#45;&gt;</span></span> <a href="#type-llvalue">llvalue</a></span></code></div><div class="spec-doc"><p><code>build_nsw_mul x y name b</code> creates a <code>%name = nsw mul %x, %y</code> instruction at the position specified by the instruction builder <code>b</code>. See the method <code>llvm::LLVMBuilder::CreateNSWMul</code>.</p></div></div><div class="odoc-spec"><div class="spec value" id="val-build_nuw_mul" class="anchored"><a href="#val-build_nuw_mul" class="anchor"></a><code><span><span class="keyword">val</span> build_nuw_mul : <span><a href="#type-llvalue">llvalue</a> <span class="arrow">&#45;&gt;</span></span> <span><a href="#type-llvalue">llvalue</a> <span class="arrow">&#45;&gt;</span></span> <span>string <span class="arrow">&#45;&gt;</span></span> <span><a href="#type-llbuilder">llbuilder</a> <span class="arrow">&#45;&gt;</span></span> <a href="#type-llvalue">llvalue</a></span></code></div><div class="spec-doc"><p><code>build_nuw_mul x y name b</code> creates a <code>%name = nuw mul %x, %y</code> instruction at the position specified by the instruction builder <code>b</code>. See the method <code>llvm::LLVMBuilder::CreateNUWMul</code>.</p></div></div><div class="odoc-spec"><div class="spec value" id="val-build_fmul" class="anchored"><a href="#val-build_fmul" class="anchor"></a><code><span><span class="keyword">val</span> build_fmul : <span><a href="#type-llvalue">llvalue</a> <span class="arrow">&#45;&gt;</span></span> <span><a href="#type-llvalue">llvalue</a> <span class="arrow">&#45;&gt;</span></span> <span>string <span class="arrow">&#45;&gt;</span></span> <span><a href="#type-llbuilder">llbuilder</a> <span class="arrow">&#45;&gt;</span></span> <a href="#type-llvalue">llvalue</a></span></code></div><div class="spec-doc"><p><code>build_fmul x y name b</code> creates a <code>%name = fmul %x, %y</code> instruction at the position specified by the instruction builder <code>b</code>. See the method <code>llvm::LLVMBuilder::CreateFMul</code>.</p></div></div><div class="odoc-spec"><div class="spec value" id="val-build_udiv" class="anchored"><a href="#val-build_udiv" class="anchor"></a><code><span><span class="keyword">val</span> build_udiv : <span><a href="#type-llvalue">llvalue</a> <span class="arrow">&#45;&gt;</span></span> <span><a href="#type-llvalue">llvalue</a> <span class="arrow">&#45;&gt;</span></span> <span>string <span class="arrow">&#45;&gt;</span></span> <span><a href="#type-llbuilder">llbuilder</a> <span class="arrow">&#45;&gt;</span></span> <a href="#type-llvalue">llvalue</a></span></code></div><div class="spec-doc"><p><code>build_udiv x y name b</code> creates a <code>%name = udiv %x, %y</code> instruction at the position specified by the instruction builder <code>b</code>. See the method <code>llvm::LLVMBuilder::CreateUDiv</code>.</p></div></div><div class="odoc-spec"><div class="spec value" id="val-build_sdiv" class="anchored"><a href="#val-build_sdiv" class="anchor"></a><code><span><span class="keyword">val</span> build_sdiv : <span><a href="#type-llvalue">llvalue</a> <span class="arrow">&#45;&gt;</span></span> <span><a href="#type-llvalue">llvalue</a> <span class="arrow">&#45;&gt;</span></span> <span>string <span class="arrow">&#45;&gt;</span></span> <span><a href="#type-llbuilder">llbuilder</a> <span class="arrow">&#45;&gt;</span></span> <a href="#type-llvalue">llvalue</a></span></code></div><div class="spec-doc"><p><code>build_sdiv x y name b</code> creates a <code>%name = sdiv %x, %y</code> instruction at the position specified by the instruction builder <code>b</code>. See the method <code>llvm::LLVMBuilder::CreateSDiv</code>.</p></div></div><div class="odoc-spec"><div class="spec value" id="val-build_exact_sdiv" class="anchored"><a href="#val-build_exact_sdiv" class="anchor"></a><code><span><span class="keyword">val</span> build_exact_sdiv : <span><a href="#type-llvalue">llvalue</a> <span class="arrow">&#45;&gt;</span></span> <span><a href="#type-llvalue">llvalue</a> <span class="arrow">&#45;&gt;</span></span> <span>string <span class="arrow">&#45;&gt;</span></span> <span><a href="#type-llbuilder">llbuilder</a> <span class="arrow">&#45;&gt;</span></span> <a href="#type-llvalue">llvalue</a></span></code></div><div class="spec-doc"><p><code>build_exact_sdiv x y name b</code> creates a <code>%name = exact sdiv %x, %y</code> instruction at the position specified by the instruction builder <code>b</code>. See the method <code>llvm::LLVMBuilder::CreateExactSDiv</code>.</p></div></div><div class="odoc-spec"><div class="spec value" id="val-build_fdiv" class="anchored"><a href="#val-build_fdiv" class="anchor"></a><code><span><span class="keyword">val</span> build_fdiv : <span><a href="#type-llvalue">llvalue</a> <span class="arrow">&#45;&gt;</span></span> <span><a href="#type-llvalue">llvalue</a> <span class="arrow">&#45;&gt;</span></span> <span>string <span class="arrow">&#45;&gt;</span></span> <span><a href="#type-llbuilder">llbuilder</a> <span class="arrow">&#45;&gt;</span></span> <a href="#type-llvalue">llvalue</a></span></code></div><div class="spec-doc"><p><code>build_fdiv x y name b</code> creates a <code>%name = fdiv %x, %y</code> instruction at the position specified by the instruction builder <code>b</code>. See the method <code>llvm::LLVMBuilder::CreateFDiv</code>.</p></div></div><div class="odoc-spec"><div class="spec value" id="val-build_urem" class="anchored"><a href="#val-build_urem" class="anchor"></a><code><span><span class="keyword">val</span> build_urem : <span><a href="#type-llvalue">llvalue</a> <span class="arrow">&#45;&gt;</span></span> <span><a href="#type-llvalue">llvalue</a> <span class="arrow">&#45;&gt;</span></span> <span>string <span class="arrow">&#45;&gt;</span></span> <span><a href="#type-llbuilder">llbuilder</a> <span class="arrow">&#45;&gt;</span></span> <a href="#type-llvalue">llvalue</a></span></code></div><div class="spec-doc"><p><code>build_urem x y name b</code> creates a <code>%name = urem %x, %y</code> instruction at the position specified by the instruction builder <code>b</code>. See the method <code>llvm::LLVMBuilder::CreateURem</code>.</p></div></div><div class="odoc-spec"><div class="spec value" id="val-build_srem" class="anchored"><a href="#val-build_srem" class="anchor"></a><code><span><span class="keyword">val</span> build_srem : <span><a href="#type-llvalue">llvalue</a> <span class="arrow">&#45;&gt;</span></span> <span><a href="#type-llvalue">llvalue</a> <span class="arrow">&#45;&gt;</span></span> <span>string <span class="arrow">&#45;&gt;</span></span> <span><a href="#type-llbuilder">llbuilder</a> <span class="arrow">&#45;&gt;</span></span> <a href="#type-llvalue">llvalue</a></span></code></div><div class="spec-doc"><p><code>build_SRem x y name b</code> creates a <code>%name = srem %x, %y</code> instruction at the position specified by the instruction builder <code>b</code>. See the method <code>llvm::LLVMBuilder::CreateSRem</code>.</p></div></div><div class="odoc-spec"><div class="spec value" id="val-build_frem" class="anchored"><a href="#val-build_frem" class="anchor"></a><code><span><span class="keyword">val</span> build_frem : <span><a href="#type-llvalue">llvalue</a> <span class="arrow">&#45;&gt;</span></span> <span><a href="#type-llvalue">llvalue</a> <span class="arrow">&#45;&gt;</span></span> <span>string <span class="arrow">&#45;&gt;</span></span> <span><a href="#type-llbuilder">llbuilder</a> <span class="arrow">&#45;&gt;</span></span> <a href="#type-llvalue">llvalue</a></span></code></div><div class="spec-doc"><p><code>build_frem x y name b</code> creates a <code>%name = frem %x, %y</code> instruction at the position specified by the instruction builder <code>b</code>. See the method <code>llvm::LLVMBuilder::CreateFRem</code>.</p></div></div><div class="odoc-spec"><div class="spec value" id="val-build_shl" class="anchored"><a href="#val-build_shl" class="anchor"></a><code><span><span class="keyword">val</span> build_shl : <span><a href="#type-llvalue">llvalue</a> <span class="arrow">&#45;&gt;</span></span> <span><a href="#type-llvalue">llvalue</a> <span class="arrow">&#45;&gt;</span></span> <span>string <span class="arrow">&#45;&gt;</span></span> <span><a href="#type-llbuilder">llbuilder</a> <span class="arrow">&#45;&gt;</span></span> <a href="#type-llvalue">llvalue</a></span></code></div><div class="spec-doc"><p><code>build_shl x y name b</code> creates a <code>%name = shl %x, %y</code> instruction at the position specified by the instruction builder <code>b</code>. See the method <code>llvm::LLVMBuilder::CreateShl</code>.</p></div></div><div class="odoc-spec"><div class="spec value" id="val-build_lshr" class="anchored"><a href="#val-build_lshr" class="anchor"></a><code><span><span class="keyword">val</span> build_lshr : <span><a href="#type-llvalue">llvalue</a> <span class="arrow">&#45;&gt;</span></span> <span><a href="#type-llvalue">llvalue</a> <span class="arrow">&#45;&gt;</span></span> <span>string <span class="arrow">&#45;&gt;</span></span> <span><a href="#type-llbuilder">llbuilder</a> <span class="arrow">&#45;&gt;</span></span> <a href="#type-llvalue">llvalue</a></span></code></div><div class="spec-doc"><p><code>build_lshr x y name b</code> creates a <code>%name = lshr %x, %y</code> instruction at the position specified by the instruction builder <code>b</code>. See the method <code>llvm::LLVMBuilder::CreateLShr</code>.</p></div></div><div class="odoc-spec"><div class="spec value" id="val-build_ashr" class="anchored"><a href="#val-build_ashr" class="anchor"></a><code><span><span class="keyword">val</span> build_ashr : <span><a href="#type-llvalue">llvalue</a> <span class="arrow">&#45;&gt;</span></span> <span><a href="#type-llvalue">llvalue</a> <span class="arrow">&#45;&gt;</span></span> <span>string <span class="arrow">&#45;&gt;</span></span> <span><a href="#type-llbuilder">llbuilder</a> <span class="arrow">&#45;&gt;</span></span> <a href="#type-llvalue">llvalue</a></span></code></div><div class="spec-doc"><p><code>build_ashr x y name b</code> creates a <code>%name = ashr %x, %y</code> instruction at the position specified by the instruction builder <code>b</code>. See the method <code>llvm::LLVMBuilder::CreateAShr</code>.</p></div></div><div class="odoc-spec"><div class="spec value" id="val-build_and" class="anchored"><a href="#val-build_and" class="anchor"></a><code><span><span class="keyword">val</span> build_and : <span><a href="#type-llvalue">llvalue</a> <span class="arrow">&#45;&gt;</span></span> <span><a href="#type-llvalue">llvalue</a> <span class="arrow">&#45;&gt;</span></span> <span>string <span class="arrow">&#45;&gt;</span></span> <span><a href="#type-llbuilder">llbuilder</a> <span class="arrow">&#45;&gt;</span></span> <a href="#type-llvalue">llvalue</a></span></code></div><div class="spec-doc"><p><code>build_and x y name b</code> creates a <code>%name = and %x, %y</code> instruction at the position specified by the instruction builder <code>b</code>. See the method <code>llvm::LLVMBuilder::CreateAnd</code>.</p></div></div><div class="odoc-spec"><div class="spec value" id="val-build_or" class="anchored"><a href="#val-build_or" class="anchor"></a><code><span><span class="keyword">val</span> build_or : <span><a href="#type-llvalue">llvalue</a> <span class="arrow">&#45;&gt;</span></span> <span><a href="#type-llvalue">llvalue</a> <span class="arrow">&#45;&gt;</span></span> <span>string <span class="arrow">&#45;&gt;</span></span> <span><a href="#type-llbuilder">llbuilder</a> <span class="arrow">&#45;&gt;</span></span> <a href="#type-llvalue">llvalue</a></span></code></div><div class="spec-doc"><p><code>build_or x y name b</code> creates a <code>%name = or %x, %y</code> instruction at the position specified by the instruction builder <code>b</code>. See the method <code>llvm::LLVMBuilder::CreateOr</code>.</p></div></div><div class="odoc-spec"><div class="spec value" id="val-build_xor" class="anchored"><a href="#val-build_xor" class="anchor"></a><code><span><span class="keyword">val</span> build_xor : <span><a href="#type-llvalue">llvalue</a> <span class="arrow">&#45;&gt;</span></span> <span><a href="#type-llvalue">llvalue</a> <span class="arrow">&#45;&gt;</span></span> <span>string <span class="arrow">&#45;&gt;</span></span> <span><a href="#type-llbuilder">llbuilder</a> <span class="arrow">&#45;&gt;</span></span> <a href="#type-llvalue">llvalue</a></span></code></div><div class="spec-doc"><p><code>build_xor x y name b</code> creates a <code>%name = xor %x, %y</code> instruction at the position specified by the instruction builder <code>b</code>. See the method <code>llvm::LLVMBuilder::CreateXor</code>.</p></div></div><div class="odoc-spec"><div class="spec value" id="val-build_neg" class="anchored"><a href="#val-build_neg" class="anchor"></a><code><span><span class="keyword">val</span> build_neg : <span><a href="#type-llvalue">llvalue</a> <span class="arrow">&#45;&gt;</span></span> <span>string <span class="arrow">&#45;&gt;</span></span> <span><a href="#type-llbuilder">llbuilder</a> <span class="arrow">&#45;&gt;</span></span> <a href="#type-llvalue">llvalue</a></span></code></div><div class="spec-doc"><p><code>build_neg x name b</code> creates a <code>%name = sub 0, %x</code> instruction at the position specified by the instruction builder <code>b</code>. <code>-0.0</code> is used for floating point types to compute the correct sign. See the method <code>llvm::LLVMBuilder::CreateNeg</code>.</p></div></div><div class="odoc-spec"><div class="spec value" id="val-build_nsw_neg" class="anchored"><a href="#val-build_nsw_neg" class="anchor"></a><code><span><span class="keyword">val</span> build_nsw_neg : <span><a href="#type-llvalue">llvalue</a> <span class="arrow">&#45;&gt;</span></span> <span>string <span class="arrow">&#45;&gt;</span></span> <span><a href="#type-llbuilder">llbuilder</a> <span class="arrow">&#45;&gt;</span></span> <a href="#type-llvalue">llvalue</a></span></code></div><div class="spec-doc"><p><code>build_nsw_neg x name b</code> creates a <code>%name = nsw sub 0, %x</code> instruction at the position specified by the instruction builder <code>b</code>. <code>-0.0</code> is used for floating point types to compute the correct sign. See the method <code>llvm::LLVMBuilder::CreateNeg</code>.</p></div></div><div class="odoc-spec"><div class="spec value" id="val-build_nuw_neg" class="anchored"><a href="#val-build_nuw_neg" class="anchor"></a><code><span><span class="keyword">val</span> build_nuw_neg : <span><a href="#type-llvalue">llvalue</a> <span class="arrow">&#45;&gt;</span></span> <span>string <span class="arrow">&#45;&gt;</span></span> <span><a href="#type-llbuilder">llbuilder</a> <span class="arrow">&#45;&gt;</span></span> <a href="#type-llvalue">llvalue</a></span></code></div><div class="spec-doc"><p><code>build_nuw_neg x name b</code> creates a <code>%name = nuw sub 0, %x</code> instruction at the position specified by the instruction builder <code>b</code>. <code>-0.0</code> is used for floating point types to compute the correct sign. See the method <code>llvm::LLVMBuilder::CreateNeg</code>.</p></div></div><div class="odoc-spec"><div class="spec value" id="val-build_fneg" class="anchored"><a href="#val-build_fneg" class="anchor"></a><code><span><span class="keyword">val</span> build_fneg : <span><a href="#type-llvalue">llvalue</a> <span class="arrow">&#45;&gt;</span></span> <span>string <span class="arrow">&#45;&gt;</span></span> <span><a href="#type-llbuilder">llbuilder</a> <span class="arrow">&#45;&gt;</span></span> <a href="#type-llvalue">llvalue</a></span></code></div><div class="spec-doc"><p><code>build_fneg x name b</code> creates a <code>%name = fsub 0, %x</code> instruction at the position specified by the instruction builder <code>b</code>. <code>-0.0</code> is used for floating point types to compute the correct sign. See the method <code>llvm::LLVMBuilder::CreateFNeg</code>.</p></div></div><div class="odoc-spec"><div class="spec value" id="val-build_not" class="anchored"><a href="#val-build_not" class="anchor"></a><code><span><span class="keyword">val</span> build_not : <span><a href="#type-llvalue">llvalue</a> <span class="arrow">&#45;&gt;</span></span> <span>string <span class="arrow">&#45;&gt;</span></span> <span><a href="#type-llbuilder">llbuilder</a> <span class="arrow">&#45;&gt;</span></span> <a href="#type-llvalue">llvalue</a></span></code></div><div class="spec-doc"><p><code>build_xor x name b</code> creates a <code>%name = xor %x, -1</code> instruction at the position specified by the instruction builder <code>b</code>. <code>-1</code> is the correct &quot;all ones&quot; value for the type of <code>x</code>. See the method <code>llvm::LLVMBuilder::CreateXor</code>.</p></div></div><h6 id="memory"><a href="#memory" class="anchor"></a>Memory</h6><div class="odoc-spec"><div class="spec value" id="val-build_alloca" class="anchored"><a href="#val-build_alloca" class="anchor"></a><code><span><span class="keyword">val</span> build_alloca : <span><a href="#type-lltype">lltype</a> <span class="arrow">&#45;&gt;</span></span> <span>string <span class="arrow">&#45;&gt;</span></span> <span><a href="#type-llbuilder">llbuilder</a> <span class="arrow">&#45;&gt;</span></span> <a href="#type-llvalue">llvalue</a></span></code></div><div class="spec-doc"><p><code>build_alloca ty name b</code> creates a <code>%name = alloca %ty</code> instruction at the position specified by the instruction builder <code>b</code>. See the method <code>llvm::LLVMBuilder::CreateAlloca</code>.</p></div></div><div class="odoc-spec"><div class="spec value" id="val-build_array_alloca" class="anchored"><a href="#val-build_array_alloca" class="anchor"></a><code><span><span class="keyword">val</span> build_array_alloca : <span><a href="#type-lltype">lltype</a> <span class="arrow">&#45;&gt;</span></span> <span><a href="#type-llvalue">llvalue</a> <span class="arrow">&#45;&gt;</span></span> <span>string <span class="arrow">&#45;&gt;</span></span> <span><a href="#type-llbuilder">llbuilder</a> <span class="arrow">&#45;&gt;</span></span> <a href="#type-llvalue">llvalue</a></span></code></div><div class="spec-doc"><p><code>build_array_alloca ty n name b</code> creates a <code>%name = alloca %ty, %n</code> instruction at the position specified by the instruction builder <code>b</code>. See the method <code>llvm::LLVMBuilder::CreateAlloca</code>.</p></div></div><div class="odoc-spec"><div class="spec value" id="val-build_load" class="anchored"><a href="#val-build_load" class="anchor"></a><code><span><span class="keyword">val</span> build_load : <span><a href="#type-llvalue">llvalue</a> <span class="arrow">&#45;&gt;</span></span> <span>string <span class="arrow">&#45;&gt;</span></span> <span><a href="#type-llbuilder">llbuilder</a> <span class="arrow">&#45;&gt;</span></span> <a href="#type-llvalue">llvalue</a></span></code></div><div class="spec-doc"><p><code>build_load v name b</code> creates a <code>%name = load %v</code> instruction at the position specified by the instruction builder <code>b</code>. See the method <code>llvm::LLVMBuilder::CreateLoad</code>.</p></div></div><div class="odoc-spec"><div class="spec value" id="val-build_store" class="anchored"><a href="#val-build_store" class="anchor"></a><code><span><span class="keyword">val</span> build_store : <span><a href="#type-llvalue">llvalue</a> <span class="arrow">&#45;&gt;</span></span> <span><a href="#type-llvalue">llvalue</a> <span class="arrow">&#45;&gt;</span></span> <span><a href="#type-llbuilder">llbuilder</a> <span class="arrow">&#45;&gt;</span></span> <a href="#type-llvalue">llvalue</a></span></code></div><div class="spec-doc"><p><code>build_store v p b</code> creates a <code>store %v, %p</code> instruction at the position specified by the instruction builder <code>b</code>. See the method <code>llvm::LLVMBuilder::CreateStore</code>.</p></div></div><div class="odoc-spec"><div class="spec value" id="val-build_atomicrmw" class="anchored"><a href="#val-build_atomicrmw" class="anchor"></a><code><span><span class="keyword">val</span> build_atomicrmw : 
  <span><a href="AtomicRMWBinOp/index.html#type-t">AtomicRMWBinOp.t</a> <span class="arrow">&#45;&gt;</span></span>
  <span><a href="#type-llvalue">llvalue</a> <span class="arrow">&#45;&gt;</span></span>
  <span><a href="#type-llvalue">llvalue</a> <span class="arrow">&#45;&gt;</span></span>
  <span><a href="AtomicOrdering/index.html#type-t">AtomicOrdering.t</a> <span class="arrow">&#45;&gt;</span></span>
  <span>bool <span class="arrow">&#45;&gt;</span></span>
  <span>string <span class="arrow">&#45;&gt;</span></span>
  <span><a href="#type-llbuilder">llbuilder</a> <span class="arrow">&#45;&gt;</span></span>
  <a href="#type-llvalue">llvalue</a></span></code></div><div class="spec-doc"><p><code>build_atomicrmw op ptr val o st b</code> creates an <code>atomicrmw</code> instruction with operation <code>op</code> performed on pointer <code>ptr</code> and value <code>val</code> with ordering <code>o</code> and singlethread flag set to <code>st</code> at the position specified by the instruction builder <code>b</code>. See the method <code>llvm::IRBuilder::CreateAtomicRMW</code>.</p></div></div><div class="odoc-spec"><div class="spec value" id="val-build_gep" class="anchored"><a href="#val-build_gep" class="anchor"></a><code><span><span class="keyword">val</span> build_gep : <span><a href="#type-llvalue">llvalue</a> <span class="arrow">&#45;&gt;</span></span> <span><span><a href="#type-llvalue">llvalue</a> array</span> <span class="arrow">&#45;&gt;</span></span> <span>string <span class="arrow">&#45;&gt;</span></span> <span><a href="#type-llbuilder">llbuilder</a> <span class="arrow">&#45;&gt;</span></span> <a href="#type-llvalue">llvalue</a></span></code></div><div class="spec-doc"><p><code>build_gep p indices name b</code> creates a <code>%name = getelementptr %p, indices...</code> instruction at the position specified by the instruction builder <code>b</code>. See the method <code>llvm::LLVMBuilder::CreateGetElementPtr</code>.</p></div></div><div class="odoc-spec"><div class="spec value" id="val-build_in_bounds_gep" class="anchored"><a href="#val-build_in_bounds_gep" class="anchor"></a><code><span><span class="keyword">val</span> build_in_bounds_gep : 
  <span><a href="#type-llvalue">llvalue</a> <span class="arrow">&#45;&gt;</span></span>
  <span><span><a href="#type-llvalue">llvalue</a> array</span> <span class="arrow">&#45;&gt;</span></span>
  <span>string <span class="arrow">&#45;&gt;</span></span>
  <span><a href="#type-llbuilder">llbuilder</a> <span class="arrow">&#45;&gt;</span></span>
  <a href="#type-llvalue">llvalue</a></span></code></div><div class="spec-doc"><p><code>build_in_bounds_gep p indices name b</code> creates a <code>%name = gelementptr inbounds %p, indices...</code> instruction at the position specified by the instruction builder <code>b</code>. See the method <code>llvm::LLVMBuilder::CreateInBoundsGetElementPtr</code>.</p></div></div><div class="odoc-spec"><div class="spec value" id="val-build_struct_gep" class="anchored"><a href="#val-build_struct_gep" class="anchor"></a><code><span><span class="keyword">val</span> build_struct_gep : <span><a href="#type-llvalue">llvalue</a> <span class="arrow">&#45;&gt;</span></span> <span>int <span class="arrow">&#45;&gt;</span></span> <span>string <span class="arrow">&#45;&gt;</span></span> <span><a href="#type-llbuilder">llbuilder</a> <span class="arrow">&#45;&gt;</span></span> <a href="#type-llvalue">llvalue</a></span></code></div><div class="spec-doc"><p><code>build_struct_gep p idx name b</code> creates a <code>%name = getelementptr %p, 0, idx</code> instruction at the position specified by the instruction builder <code>b</code>. See the method <code>llvm::LLVMBuilder::CreateStructGetElementPtr</code>.</p></div></div><div class="odoc-spec"><div class="spec value" id="val-build_global_string" class="anchored"><a href="#val-build_global_string" class="anchor"></a><code><span><span class="keyword">val</span> build_global_string : <span>string <span class="arrow">&#45;&gt;</span></span> <span>string <span class="arrow">&#45;&gt;</span></span> <span><a href="#type-llbuilder">llbuilder</a> <span class="arrow">&#45;&gt;</span></span> <a href="#type-llvalue">llvalue</a></span></code></div><div class="spec-doc"><p><code>build_global_string str name b</code> creates a series of instructions that adds a global string at the position specified by the instruction builder <code>b</code>. See the method <code>llvm::LLVMBuilder::CreateGlobalString</code>.</p></div></div><div class="odoc-spec"><div class="spec value" id="val-build_global_stringptr" class="anchored"><a href="#val-build_global_stringptr" class="anchor"></a><code><span><span class="keyword">val</span> build_global_stringptr : <span>string <span class="arrow">&#45;&gt;</span></span> <span>string <span class="arrow">&#45;&gt;</span></span> <span><a href="#type-llbuilder">llbuilder</a> <span class="arrow">&#45;&gt;</span></span> <a href="#type-llvalue">llvalue</a></span></code></div><div class="spec-doc"><p><code>build_global_stringptr str name b</code> creates a series of instructions that adds a global string pointer at the position specified by the instruction builder <code>b</code>. See the method <code>llvm::LLVMBuilder::CreateGlobalStringPtr</code>.</p></div></div><h6 id="casts"><a href="#casts" class="anchor"></a>Casts</h6><div class="odoc-spec"><div class="spec value" id="val-build_trunc" class="anchored"><a href="#val-build_trunc" class="anchor"></a><code><span><span class="keyword">val</span> build_trunc : <span><a href="#type-llvalue">llvalue</a> <span class="arrow">&#45;&gt;</span></span> <span><a href="#type-lltype">lltype</a> <span class="arrow">&#45;&gt;</span></span> <span>string <span class="arrow">&#45;&gt;</span></span> <span><a href="#type-llbuilder">llbuilder</a> <span class="arrow">&#45;&gt;</span></span> <a href="#type-llvalue">llvalue</a></span></code></div><div class="spec-doc"><p><code>build_trunc v ty name b</code> creates a <code>%name = trunc %p to %ty</code> instruction at the position specified by the instruction builder <code>b</code>. See the method <code>llvm::LLVMBuilder::CreateTrunc</code>.</p></div></div><div class="odoc-spec"><div class="spec value" id="val-build_zext" class="anchored"><a href="#val-build_zext" class="anchor"></a><code><span><span class="keyword">val</span> build_zext : <span><a href="#type-llvalue">llvalue</a> <span class="arrow">&#45;&gt;</span></span> <span><a href="#type-lltype">lltype</a> <span class="arrow">&#45;&gt;</span></span> <span>string <span class="arrow">&#45;&gt;</span></span> <span><a href="#type-llbuilder">llbuilder</a> <span class="arrow">&#45;&gt;</span></span> <a href="#type-llvalue">llvalue</a></span></code></div><div class="spec-doc"><p><code>build_zext v ty name b</code> creates a <code>%name = zext %p to %ty</code> instruction at the position specified by the instruction builder <code>b</code>. See the method <code>llvm::LLVMBuilder::CreateZExt</code>.</p></div></div><div class="odoc-spec"><div class="spec value" id="val-build_sext" class="anchored"><a href="#val-build_sext" class="anchor"></a><code><span><span class="keyword">val</span> build_sext : <span><a href="#type-llvalue">llvalue</a> <span class="arrow">&#45;&gt;</span></span> <span><a href="#type-lltype">lltype</a> <span class="arrow">&#45;&gt;</span></span> <span>string <span class="arrow">&#45;&gt;</span></span> <span><a href="#type-llbuilder">llbuilder</a> <span class="arrow">&#45;&gt;</span></span> <a href="#type-llvalue">llvalue</a></span></code></div><div class="spec-doc"><p><code>build_sext v ty name b</code> creates a <code>%name = sext %p to %ty</code> instruction at the position specified by the instruction builder <code>b</code>. See the method <code>llvm::LLVMBuilder::CreateSExt</code>.</p></div></div><div class="odoc-spec"><div class="spec value" id="val-build_fptoui" class="anchored"><a href="#val-build_fptoui" class="anchor"></a><code><span><span class="keyword">val</span> build_fptoui : <span><a href="#type-llvalue">llvalue</a> <span class="arrow">&#45;&gt;</span></span> <span><a href="#type-lltype">lltype</a> <span class="arrow">&#45;&gt;</span></span> <span>string <span class="arrow">&#45;&gt;</span></span> <span><a href="#type-llbuilder">llbuilder</a> <span class="arrow">&#45;&gt;</span></span> <a href="#type-llvalue">llvalue</a></span></code></div><div class="spec-doc"><p><code>build_fptoui v ty name b</code> creates a <code>%name = fptoui %p to %ty</code> instruction at the position specified by the instruction builder <code>b</code>. See the method <code>llvm::LLVMBuilder::CreateFPToUI</code>.</p></div></div><div class="odoc-spec"><div class="spec value" id="val-build_fptosi" class="anchored"><a href="#val-build_fptosi" class="anchor"></a><code><span><span class="keyword">val</span> build_fptosi : <span><a href="#type-llvalue">llvalue</a> <span class="arrow">&#45;&gt;</span></span> <span><a href="#type-lltype">lltype</a> <span class="arrow">&#45;&gt;</span></span> <span>string <span class="arrow">&#45;&gt;</span></span> <span><a href="#type-llbuilder">llbuilder</a> <span class="arrow">&#45;&gt;</span></span> <a href="#type-llvalue">llvalue</a></span></code></div><div class="spec-doc"><p><code>build_fptosi v ty name b</code> creates a <code>%name = fptosi %p to %ty</code> instruction at the position specified by the instruction builder <code>b</code>. See the method <code>llvm::LLVMBuilder::CreateFPToSI</code>.</p></div></div><div class="odoc-spec"><div class="spec value" id="val-build_uitofp" class="anchored"><a href="#val-build_uitofp" class="anchor"></a><code><span><span class="keyword">val</span> build_uitofp : <span><a href="#type-llvalue">llvalue</a> <span class="arrow">&#45;&gt;</span></span> <span><a href="#type-lltype">lltype</a> <span class="arrow">&#45;&gt;</span></span> <span>string <span class="arrow">&#45;&gt;</span></span> <span><a href="#type-llbuilder">llbuilder</a> <span class="arrow">&#45;&gt;</span></span> <a href="#type-llvalue">llvalue</a></span></code></div><div class="spec-doc"><p><code>build_uitofp v ty name b</code> creates a <code>%name = uitofp %p to %ty</code> instruction at the position specified by the instruction builder <code>b</code>. See the method <code>llvm::LLVMBuilder::CreateUIToFP</code>.</p></div></div><div class="odoc-spec"><div class="spec value" id="val-build_sitofp" class="anchored"><a href="#val-build_sitofp" class="anchor"></a><code><span><span class="keyword">val</span> build_sitofp : <span><a href="#type-llvalue">llvalue</a> <span class="arrow">&#45;&gt;</span></span> <span><a href="#type-lltype">lltype</a> <span class="arrow">&#45;&gt;</span></span> <span>string <span class="arrow">&#45;&gt;</span></span> <span><a href="#type-llbuilder">llbuilder</a> <span class="arrow">&#45;&gt;</span></span> <a href="#type-llvalue">llvalue</a></span></code></div><div class="spec-doc"><p><code>build_sitofp v ty name b</code> creates a <code>%name = sitofp %p to %ty</code> instruction at the position specified by the instruction builder <code>b</code>. See the method <code>llvm::LLVMBuilder::CreateSIToFP</code>.</p></div></div><div class="odoc-spec"><div class="spec value" id="val-build_fptrunc" class="anchored"><a href="#val-build_fptrunc" class="anchor"></a><code><span><span class="keyword">val</span> build_fptrunc : <span><a href="#type-llvalue">llvalue</a> <span class="arrow">&#45;&gt;</span></span> <span><a href="#type-lltype">lltype</a> <span class="arrow">&#45;&gt;</span></span> <span>string <span class="arrow">&#45;&gt;</span></span> <span><a href="#type-llbuilder">llbuilder</a> <span class="arrow">&#45;&gt;</span></span> <a href="#type-llvalue">llvalue</a></span></code></div><div class="spec-doc"><p><code>build_fptrunc v ty name b</code> creates a <code>%name = fptrunc %p to %ty</code> instruction at the position specified by the instruction builder <code>b</code>. See the method <code>llvm::LLVMBuilder::CreateFPTrunc</code>.</p></div></div><div class="odoc-spec"><div class="spec value" id="val-build_fpext" class="anchored"><a href="#val-build_fpext" class="anchor"></a><code><span><span class="keyword">val</span> build_fpext : <span><a href="#type-llvalue">llvalue</a> <span class="arrow">&#45;&gt;</span></span> <span><a href="#type-lltype">lltype</a> <span class="arrow">&#45;&gt;</span></span> <span>string <span class="arrow">&#45;&gt;</span></span> <span><a href="#type-llbuilder">llbuilder</a> <span class="arrow">&#45;&gt;</span></span> <a href="#type-llvalue">llvalue</a></span></code></div><div class="spec-doc"><p><code>build_fpext v ty name b</code> creates a <code>%name = fpext %p to %ty</code> instruction at the position specified by the instruction builder <code>b</code>. See the method <code>llvm::LLVMBuilder::CreateFPExt</code>.</p></div></div><div class="odoc-spec"><div class="spec value" id="val-build_ptrtoint" class="anchored"><a href="#val-build_ptrtoint" class="anchor"></a><code><span><span class="keyword">val</span> build_ptrtoint : <span><a href="#type-llvalue">llvalue</a> <span class="arrow">&#45;&gt;</span></span> <span><a href="#type-lltype">lltype</a> <span class="arrow">&#45;&gt;</span></span> <span>string <span class="arrow">&#45;&gt;</span></span> <span><a href="#type-llbuilder">llbuilder</a> <span class="arrow">&#45;&gt;</span></span> <a href="#type-llvalue">llvalue</a></span></code></div><div class="spec-doc"><p><code>build_ptrtoint v ty name b</code> creates a <code>%name = prtotint %p to %ty</code> instruction at the position specified by the instruction builder <code>b</code>. See the method <code>llvm::LLVMBuilder::CreatePtrToInt</code>.</p></div></div><div class="odoc-spec"><div class="spec value" id="val-build_inttoptr" class="anchored"><a href="#val-build_inttoptr" class="anchor"></a><code><span><span class="keyword">val</span> build_inttoptr : <span><a href="#type-llvalue">llvalue</a> <span class="arrow">&#45;&gt;</span></span> <span><a href="#type-lltype">lltype</a> <span class="arrow">&#45;&gt;</span></span> <span>string <span class="arrow">&#45;&gt;</span></span> <span><a href="#type-llbuilder">llbuilder</a> <span class="arrow">&#45;&gt;</span></span> <a href="#type-llvalue">llvalue</a></span></code></div><div class="spec-doc"><p><code>build_inttoptr v ty name b</code> creates a <code>%name = inttoptr %p to %ty</code> instruction at the position specified by the instruction builder <code>b</code>. See the method <code>llvm::LLVMBuilder::CreateIntToPtr</code>.</p></div></div><div class="odoc-spec"><div class="spec value" id="val-build_bitcast" class="anchored"><a href="#val-build_bitcast" class="anchor"></a><code><span><span class="keyword">val</span> build_bitcast : <span><a href="#type-llvalue">llvalue</a> <span class="arrow">&#45;&gt;</span></span> <span><a href="#type-lltype">lltype</a> <span class="arrow">&#45;&gt;</span></span> <span>string <span class="arrow">&#45;&gt;</span></span> <span><a href="#type-llbuilder">llbuilder</a> <span class="arrow">&#45;&gt;</span></span> <a href="#type-llvalue">llvalue</a></span></code></div><div class="spec-doc"><p><code>build_bitcast v ty name b</code> creates a <code>%name = bitcast %p to %ty</code> instruction at the position specified by the instruction builder <code>b</code>. See the method <code>llvm::LLVMBuilder::CreateBitCast</code>.</p></div></div><div class="odoc-spec"><div class="spec value" id="val-build_zext_or_bitcast" class="anchored"><a href="#val-build_zext_or_bitcast" class="anchor"></a><code><span><span class="keyword">val</span> build_zext_or_bitcast : <span><a href="#type-llvalue">llvalue</a> <span class="arrow">&#45;&gt;</span></span> <span><a href="#type-lltype">lltype</a> <span class="arrow">&#45;&gt;</span></span> <span>string <span class="arrow">&#45;&gt;</span></span> <span><a href="#type-llbuilder">llbuilder</a> <span class="arrow">&#45;&gt;</span></span> <a href="#type-llvalue">llvalue</a></span></code></div><div class="spec-doc"><p><code>build_zext_or_bitcast v ty name b</code> creates a zext or bitcast instruction at the position specified by the instruction builder <code>b</code>. See the method <code>llvm::LLVMBuilder::CreateZExtOrBitCast</code>.</p></div></div><div class="odoc-spec"><div class="spec value" id="val-build_sext_or_bitcast" class="anchored"><a href="#val-build_sext_or_bitcast" class="anchor"></a><code><span><span class="keyword">val</span> build_sext_or_bitcast : <span><a href="#type-llvalue">llvalue</a> <span class="arrow">&#45;&gt;</span></span> <span><a href="#type-lltype">lltype</a> <span class="arrow">&#45;&gt;</span></span> <span>string <span class="arrow">&#45;&gt;</span></span> <span><a href="#type-llbuilder">llbuilder</a> <span class="arrow">&#45;&gt;</span></span> <a href="#type-llvalue">llvalue</a></span></code></div><div class="spec-doc"><p><code>build_sext_or_bitcast v ty name b</code> creates a sext or bitcast instruction at the position specified by the instruction builder <code>b</code>. See the method <code>llvm::LLVMBuilder::CreateSExtOrBitCast</code>.</p></div></div><div class="odoc-spec"><div class="spec value" id="val-build_trunc_or_bitcast" class="anchored"><a href="#val-build_trunc_or_bitcast" class="anchor"></a><code><span><span class="keyword">val</span> build_trunc_or_bitcast : 
  <span><a href="#type-llvalue">llvalue</a> <span class="arrow">&#45;&gt;</span></span>
  <span><a href="#type-lltype">lltype</a> <span class="arrow">&#45;&gt;</span></span>
  <span>string <span class="arrow">&#45;&gt;</span></span>
  <span><a href="#type-llbuilder">llbuilder</a> <span class="arrow">&#45;&gt;</span></span>
  <a href="#type-llvalue">llvalue</a></span></code></div><div class="spec-doc"><p><code>build_trunc_or_bitcast v ty name b</code> creates a trunc or bitcast instruction at the position specified by the instruction builder <code>b</code>. See the method <code>llvm::LLVMBuilder::CreateZExtOrBitCast</code>.</p></div></div><div class="odoc-spec"><div class="spec value" id="val-build_pointercast" class="anchored"><a href="#val-build_pointercast" class="anchor"></a><code><span><span class="keyword">val</span> build_pointercast : <span><a href="#type-llvalue">llvalue</a> <span class="arrow">&#45;&gt;</span></span> <span><a href="#type-lltype">lltype</a> <span class="arrow">&#45;&gt;</span></span> <span>string <span class="arrow">&#45;&gt;</span></span> <span><a href="#type-llbuilder">llbuilder</a> <span class="arrow">&#45;&gt;</span></span> <a href="#type-llvalue">llvalue</a></span></code></div><div class="spec-doc"><p><code>build_pointercast v ty name b</code> creates a bitcast or pointer-to-int instruction at the position specified by the instruction builder <code>b</code>. See the method <code>llvm::LLVMBuilder::CreatePointerCast</code>.</p></div></div><div class="odoc-spec"><div class="spec value" id="val-build_intcast" class="anchored"><a href="#val-build_intcast" class="anchor"></a><code><span><span class="keyword">val</span> build_intcast : <span><a href="#type-llvalue">llvalue</a> <span class="arrow">&#45;&gt;</span></span> <span><a href="#type-lltype">lltype</a> <span class="arrow">&#45;&gt;</span></span> <span>string <span class="arrow">&#45;&gt;</span></span> <span><a href="#type-llbuilder">llbuilder</a> <span class="arrow">&#45;&gt;</span></span> <a href="#type-llvalue">llvalue</a></span></code></div><div class="spec-doc"><p><code>build_intcast v ty name b</code> creates a zext, bitcast, or trunc instruction at the position specified by the instruction builder <code>b</code>. See the method <code>llvm::LLVMBuilder::CreateIntCast</code>.</p></div></div><div class="odoc-spec"><div class="spec value" id="val-build_fpcast" class="anchored"><a href="#val-build_fpcast" class="anchor"></a><code><span><span class="keyword">val</span> build_fpcast : <span><a href="#type-llvalue">llvalue</a> <span class="arrow">&#45;&gt;</span></span> <span><a href="#type-lltype">lltype</a> <span class="arrow">&#45;&gt;</span></span> <span>string <span class="arrow">&#45;&gt;</span></span> <span><a href="#type-llbuilder">llbuilder</a> <span class="arrow">&#45;&gt;</span></span> <a href="#type-llvalue">llvalue</a></span></code></div><div class="spec-doc"><p><code>build_fpcast v ty name b</code> creates a fpext, bitcast, or fptrunc instruction at the position specified by the instruction builder <code>b</code>. See the method <code>llvm::LLVMBuilder::CreateFPCast</code>.</p></div></div><h6 id="comparisons"><a href="#comparisons" class="anchor"></a>Comparisons</h6><div class="odoc-spec"><div class="spec value" id="val-build_icmp" class="anchored"><a href="#val-build_icmp" class="anchor"></a><code><span><span class="keyword">val</span> build_icmp : <span><a href="Icmp/index.html#type-t">Icmp.t</a> <span class="arrow">&#45;&gt;</span></span> <span><a href="#type-llvalue">llvalue</a> <span class="arrow">&#45;&gt;</span></span> <span><a href="#type-llvalue">llvalue</a> <span class="arrow">&#45;&gt;</span></span> <span>string <span class="arrow">&#45;&gt;</span></span> <span><a href="#type-llbuilder">llbuilder</a> <span class="arrow">&#45;&gt;</span></span> <a href="#type-llvalue">llvalue</a></span></code></div><div class="spec-doc"><p><code>build_icmp pred x y name b</code> creates a <code>%name = icmp %pred %x, %y</code> instruction at the position specified by the instruction builder <code>b</code>. See the method <code>llvm::LLVMBuilder::CreateICmp</code>.</p></div></div><div class="odoc-spec"><div class="spec value" id="val-build_fcmp" class="anchored"><a href="#val-build_fcmp" class="anchor"></a><code><span><span class="keyword">val</span> build_fcmp : <span><a href="Fcmp/index.html#type-t">Fcmp.t</a> <span class="arrow">&#45;&gt;</span></span> <span><a href="#type-llvalue">llvalue</a> <span class="arrow">&#45;&gt;</span></span> <span><a href="#type-llvalue">llvalue</a> <span class="arrow">&#45;&gt;</span></span> <span>string <span class="arrow">&#45;&gt;</span></span> <span><a href="#type-llbuilder">llbuilder</a> <span class="arrow">&#45;&gt;</span></span> <a href="#type-llvalue">llvalue</a></span></code></div><div class="spec-doc"><p><code>build_fcmp pred x y name b</code> creates a <code>%name = fcmp %pred %x, %y</code> instruction at the position specified by the instruction builder <code>b</code>. See the method <code>llvm::LLVMBuilder::CreateFCmp</code>.</p></div></div><h6 id="miscellaneous-instructions"><a href="#miscellaneous-instructions" class="anchor"></a>Miscellaneous instructions</h6><div class="odoc-spec"><div class="spec value" id="val-build_phi" class="anchored"><a href="#val-build_phi" class="anchor"></a><code><span><span class="keyword">val</span> build_phi : <span><span><span>(<a href="#type-llvalue">llvalue</a> * <a href="#type-llbasicblock">llbasicblock</a>)</span> list</span> <span class="arrow">&#45;&gt;</span></span> <span>string <span class="arrow">&#45;&gt;</span></span> <span><a href="#type-llbuilder">llbuilder</a> <span class="arrow">&#45;&gt;</span></span> <a href="#type-llvalue">llvalue</a></span></code></div><div class="spec-doc"><p><code>build_phi incoming name b</code> creates a <code>%name = phi %incoming</code> instruction at the position specified by the instruction builder <code>b</code>. <code>incoming</code> is a list of <code>(llvalue, llbasicblock)</code> tuples. See the method <code>llvm::LLVMBuilder::CreatePHI</code>.</p></div></div><div class="odoc-spec"><div class="spec value" id="val-build_empty_phi" class="anchored"><a href="#val-build_empty_phi" class="anchor"></a><code><span><span class="keyword">val</span> build_empty_phi : <span><a href="#type-lltype">lltype</a> <span class="arrow">&#45;&gt;</span></span> <span>string <span class="arrow">&#45;&gt;</span></span> <span><a href="#type-llbuilder">llbuilder</a> <span class="arrow">&#45;&gt;</span></span> <a href="#type-llvalue">llvalue</a></span></code></div><div class="spec-doc"><p><code>build_empty_phi ty name b</code> creates a <code>%name = phi %ty</code> instruction at the position specified by the instruction builder <code>b</code>. <code>ty</code> is the type of the instruction. See the method <code>llvm::LLVMBuilder::CreatePHI</code>.</p></div></div><div class="odoc-spec"><div class="spec value" id="val-build_call" class="anchored"><a href="#val-build_call" class="anchor"></a><code><span><span class="keyword">val</span> build_call : <span><a href="#type-llvalue">llvalue</a> <span class="arrow">&#45;&gt;</span></span> <span><span><a href="#type-llvalue">llvalue</a> array</span> <span class="arrow">&#45;&gt;</span></span> <span>string <span class="arrow">&#45;&gt;</span></span> <span><a href="#type-llbuilder">llbuilder</a> <span class="arrow">&#45;&gt;</span></span> <a href="#type-llvalue">llvalue</a></span></code></div><div class="spec-doc"><p><code>build_call fn args name b</code> creates a <code>%name = call %fn(args...)</code> instruction at the position specified by the instruction builder <code>b</code>. See the method <code>llvm::LLVMBuilder::CreateCall</code>.</p></div></div><div class="odoc-spec"><div class="spec value" id="val-build_select" class="anchored"><a href="#val-build_select" class="anchor"></a><code><span><span class="keyword">val</span> build_select : 
  <span><a href="#type-llvalue">llvalue</a> <span class="arrow">&#45;&gt;</span></span>
  <span><a href="#type-llvalue">llvalue</a> <span class="arrow">&#45;&gt;</span></span>
  <span><a href="#type-llvalue">llvalue</a> <span class="arrow">&#45;&gt;</span></span>
  <span>string <span class="arrow">&#45;&gt;</span></span>
  <span><a href="#type-llbuilder">llbuilder</a> <span class="arrow">&#45;&gt;</span></span>
  <a href="#type-llvalue">llvalue</a></span></code></div><div class="spec-doc"><p><code>build_select cond thenv elsev name b</code> creates a <code>%name = select %cond, %thenv, %elsev</code> instruction at the position specified by the instruction builder <code>b</code>. See the method <code>llvm::LLVMBuilder::CreateSelect</code>.</p></div></div><div class="odoc-spec"><div class="spec value" id="val-build_va_arg" class="anchored"><a href="#val-build_va_arg" class="anchor"></a><code><span><span class="keyword">val</span> build_va_arg : <span><a href="#type-llvalue">llvalue</a> <span class="arrow">&#45;&gt;</span></span> <span><a href="#type-lltype">lltype</a> <span class="arrow">&#45;&gt;</span></span> <span>string <span class="arrow">&#45;&gt;</span></span> <span><a href="#type-llbuilder">llbuilder</a> <span class="arrow">&#45;&gt;</span></span> <a href="#type-llvalue">llvalue</a></span></code></div><div class="spec-doc"><p><code>build_va_arg valist argty name b</code> creates a <code>%name = va_arg %valist, %argty</code> instruction at the position specified by the instruction builder <code>b</code>. See the method <code>llvm::LLVMBuilder::CreateVAArg</code>.</p></div></div><div class="odoc-spec"><div class="spec value" id="val-build_extractelement" class="anchored"><a href="#val-build_extractelement" class="anchor"></a><code><span><span class="keyword">val</span> build_extractelement : <span><a href="#type-llvalue">llvalue</a> <span class="arrow">&#45;&gt;</span></span> <span><a href="#type-llvalue">llvalue</a> <span class="arrow">&#45;&gt;</span></span> <span>string <span class="arrow">&#45;&gt;</span></span> <span><a href="#type-llbuilder">llbuilder</a> <span class="arrow">&#45;&gt;</span></span> <a href="#type-llvalue">llvalue</a></span></code></div><div class="spec-doc"><p><code>build_extractelement vec i name b</code> creates a <code>%name = extractelement %vec, %i</code> instruction at the position specified by the instruction builder <code>b</code>. See the method <code>llvm::LLVMBuilder::CreateExtractElement</code>.</p></div></div><div class="odoc-spec"><div class="spec value" id="val-build_insertelement" class="anchored"><a href="#val-build_insertelement" class="anchor"></a><code><span><span class="keyword">val</span> build_insertelement : 
  <span><a href="#type-llvalue">llvalue</a> <span class="arrow">&#45;&gt;</span></span>
  <span><a href="#type-llvalue">llvalue</a> <span class="arrow">&#45;&gt;</span></span>
  <span><a href="#type-llvalue">llvalue</a> <span class="arrow">&#45;&gt;</span></span>
  <span>string <span class="arrow">&#45;&gt;</span></span>
  <span><a href="#type-llbuilder">llbuilder</a> <span class="arrow">&#45;&gt;</span></span>
  <a href="#type-llvalue">llvalue</a></span></code></div><div class="spec-doc"><p><code>build_insertelement vec elt i name b</code> creates a <code>%name = insertelement %vec, %elt, %i</code> instruction at the position specified by the instruction builder <code>b</code>. See the method <code>llvm::LLVMBuilder::CreateInsertElement</code>.</p></div></div><div class="odoc-spec"><div class="spec value" id="val-build_shufflevector" class="anchored"><a href="#val-build_shufflevector" class="anchor"></a><code><span><span class="keyword">val</span> build_shufflevector : 
  <span><a href="#type-llvalue">llvalue</a> <span class="arrow">&#45;&gt;</span></span>
  <span><a href="#type-llvalue">llvalue</a> <span class="arrow">&#45;&gt;</span></span>
  <span><a href="#type-llvalue">llvalue</a> <span class="arrow">&#45;&gt;</span></span>
  <span>string <span class="arrow">&#45;&gt;</span></span>
  <span><a href="#type-llbuilder">llbuilder</a> <span class="arrow">&#45;&gt;</span></span>
  <a href="#type-llvalue">llvalue</a></span></code></div><div class="spec-doc"><p><code>build_shufflevector veca vecb mask name b</code> creates a <code>%name = shufflevector %veca, %vecb, %mask</code> instruction at the position specified by the instruction builder <code>b</code>. See the method <code>llvm::LLVMBuilder::CreateShuffleVector</code>.</p></div></div><div class="odoc-spec"><div class="spec value" id="val-build_extractvalue" class="anchored"><a href="#val-build_extractvalue" class="anchor"></a><code><span><span class="keyword">val</span> build_extractvalue : <span><a href="#type-llvalue">llvalue</a> <span class="arrow">&#45;&gt;</span></span> <span>int <span class="arrow">&#45;&gt;</span></span> <span>string <span class="arrow">&#45;&gt;</span></span> <span><a href="#type-llbuilder">llbuilder</a> <span class="arrow">&#45;&gt;</span></span> <a href="#type-llvalue">llvalue</a></span></code></div><div class="spec-doc"><p><code>build_extractvalue agg idx name b</code> creates a <code>%name = extractvalue %agg, %idx</code> instruction at the position specified by the instruction builder <code>b</code>. See the method <code>llvm::LLVMBuilder::CreateExtractValue</code>.</p></div></div><div class="odoc-spec"><div class="spec value" id="val-build_insertvalue" class="anchored"><a href="#val-build_insertvalue" class="anchor"></a><code><span><span class="keyword">val</span> build_insertvalue : 
  <span><a href="#type-llvalue">llvalue</a> <span class="arrow">&#45;&gt;</span></span>
  <span><a href="#type-llvalue">llvalue</a> <span class="arrow">&#45;&gt;</span></span>
  <span>int <span class="arrow">&#45;&gt;</span></span>
  <span>string <span class="arrow">&#45;&gt;</span></span>
  <span><a href="#type-llbuilder">llbuilder</a> <span class="arrow">&#45;&gt;</span></span>
  <a href="#type-llvalue">llvalue</a></span></code></div><div class="spec-doc"><p><code>build_insertvalue agg val idx name b</code> creates a <code>%name = insertvalue %agg, %val, %idx</code> instruction at the position specified by the instruction builder <code>b</code>. See the method <code>llvm::LLVMBuilder::CreateInsertValue</code>.</p></div></div><div class="odoc-spec"><div class="spec value" id="val-build_is_null" class="anchored"><a href="#val-build_is_null" class="anchor"></a><code><span><span class="keyword">val</span> build_is_null : <span><a href="#type-llvalue">llvalue</a> <span class="arrow">&#45;&gt;</span></span> <span>string <span class="arrow">&#45;&gt;</span></span> <span><a href="#type-llbuilder">llbuilder</a> <span class="arrow">&#45;&gt;</span></span> <a href="#type-llvalue">llvalue</a></span></code></div><div class="spec-doc"><p><code>build_is_null val name b</code> creates a <code>%name = icmp eq %val, null</code> instruction at the position specified by the instruction builder <code>b</code>. See the method <code>llvm::LLVMBuilder::CreateIsNull</code>.</p></div></div><div class="odoc-spec"><div class="spec value" id="val-build_is_not_null" class="anchored"><a href="#val-build_is_not_null" class="anchor"></a><code><span><span class="keyword">val</span> build_is_not_null : <span><a href="#type-llvalue">llvalue</a> <span class="arrow">&#45;&gt;</span></span> <span>string <span class="arrow">&#45;&gt;</span></span> <span><a href="#type-llbuilder">llbuilder</a> <span class="arrow">&#45;&gt;</span></span> <a href="#type-llvalue">llvalue</a></span></code></div><div class="spec-doc"><p><code>build_is_not_null val name b</code> creates a <code>%name = icmp ne %val, null</code> instruction at the position specified by the instruction builder <code>b</code>. See the method <code>llvm::LLVMBuilder::CreateIsNotNull</code>.</p></div></div><div class="odoc-spec"><div class="spec value" id="val-build_ptrdiff" class="anchored"><a href="#val-build_ptrdiff" class="anchor"></a><code><span><span class="keyword">val</span> build_ptrdiff : <span><a href="#type-llvalue">llvalue</a> <span class="arrow">&#45;&gt;</span></span> <span><a href="#type-llvalue">llvalue</a> <span class="arrow">&#45;&gt;</span></span> <span>string <span class="arrow">&#45;&gt;</span></span> <span><a href="#type-llbuilder">llbuilder</a> <span class="arrow">&#45;&gt;</span></span> <a href="#type-llvalue">llvalue</a></span></code></div><div class="spec-doc"><p><code>build_ptrdiff lhs rhs name b</code> creates a series of instructions that measure the difference between two pointer values at the position specified by the instruction builder <code>b</code>. See the method <code>llvm::LLVMBuilder::CreatePtrDiff</code>.</p></div></div><div class="odoc-spec"><div class="spec value" id="val-build_freeze" class="anchored"><a href="#val-build_freeze" class="anchor"></a><code><span><span class="keyword">val</span> build_freeze : <span><a href="#type-llvalue">llvalue</a> <span class="arrow">&#45;&gt;</span></span> <span>string <span class="arrow">&#45;&gt;</span></span> <span><a href="#type-llbuilder">llbuilder</a> <span class="arrow">&#45;&gt;</span></span> <a href="#type-llvalue">llvalue</a></span></code></div><div class="spec-doc"><p><code>build_freeze x name b</code> creates a <code>%name = freeze %x</code> instruction at the position specified by the instruction builder <code>b</code>. See the method <code>llvm::LLVMBuilder::CreateFreeze</code>.</p></div></div><h6 id="memory-buffers"><a href="#memory-buffers" class="anchor"></a>Memory buffers</h6><div class="odoc-spec"><div class="spec module" id="module-MemoryBuffer" class="anchored"><a href="#module-MemoryBuffer" class="anchor"></a><code><span><span class="keyword">module</span> <a href="MemoryBuffer/index.html">MemoryBuffer</a></span><span> : <span class="keyword">sig</span> ... <span class="keyword">end</span></span></code></div></div><h6 id="pass-managers"><a href="#pass-managers" class="anchor"></a>Pass Managers</h6><div class="odoc-spec"><div class="spec module" id="module-PassManager" class="anchored"><a href="#module-PassManager" class="anchor"></a><code><span><span class="keyword">module</span> <a href="PassManager/index.html">PassManager</a></span><span> : <span class="keyword">sig</span> ... <span class="keyword">end</span></span></code></div></div></div></body></html>