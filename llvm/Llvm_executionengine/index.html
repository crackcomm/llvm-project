<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml"><head><title>Llvm_executionengine (llvm.Llvm_executionengine)</title><link rel="stylesheet" href="../../odoc.css"/><meta charset="utf-8"/><meta name="generator" content="odoc 2.1.0"/><meta name="viewport" content="width=device-width,initial-scale=1.0"/><script src="../../highlight.pack.js"></script><script>hljs.initHighlightingOnLoad();</script></head><body class="odoc"><nav class="odoc-nav"><a href="../index.html">Up</a> â€“ <a href="../index.html">llvm</a> &#x00BB; Llvm_executionengine</nav><header class="odoc-preamble"><h1>Module <code><span>Llvm_executionengine</span></code></h1><p>JIT Interpreter.</p><p>This interface provides an OCaml API for LLVM execution engine (JIT/ interpreter), the classes in the <code>ExecutionEngine</code> library.</p></header><div class="odoc-content"><div class="odoc-spec"><div class="spec exception" id="exception-Error" class="anchored"><a href="#exception-Error" class="anchor"></a><code><span><span class="keyword">exception</span> </span><span><span class="exception">Error</span> <span class="keyword">of</span> string</span></code></div></div><div class="odoc-spec"><div class="spec value" id="val-initialize" class="anchored"><a href="#val-initialize" class="anchor"></a><code><span><span class="keyword">val</span> initialize : <span>unit <span class="arrow">&#45;&gt;</span></span> bool</span></code></div><div class="spec-doc"><p><code>initialize ()</code> initializes the backend corresponding to the host. Returns <code>true</code> if initialization is successful; <code>false</code> indicates that there is no such backend or it is unable to emit object code via MCJIT.</p></div></div><div class="odoc-spec"><div class="spec type" id="type-llexecutionengine" class="anchored"><a href="#type-llexecutionengine" class="anchor"></a><code><span><span class="keyword">type</span> llexecutionengine</span></code></div><div class="spec-doc"><p>An execution engine is either a JIT compiler or an interpreter, capable of directly loading an LLVM module and executing its functions without first invoking a static compiler and generating a native executable.</p></div></div><div class="odoc-spec"><div class="spec type" id="type-llcompileroptions" class="anchored"><a href="#type-llcompileroptions" class="anchor"></a><code><span><span class="keyword">type</span> llcompileroptions</span><span> = </span><span>{</span></code><table><tr id="type-llcompileroptions.opt_level" class="anchored"><td class="def record field"><a href="#type-llcompileroptions.opt_level" class="anchor"></a><code><span>opt_level : int;</span></code></td></tr><tr id="type-llcompileroptions.code_model" class="anchored"><td class="def record field"><a href="#type-llcompileroptions.code_model" class="anchor"></a><code><span>code_model : <a href="../Llvm_target/CodeModel/index.html#type-t">Llvm_target.CodeModel.t</a>;</span></code></td></tr><tr id="type-llcompileroptions.no_framepointer_elim" class="anchored"><td class="def record field"><a href="#type-llcompileroptions.no_framepointer_elim" class="anchor"></a><code><span>no_framepointer_elim : bool;</span></code></td></tr><tr id="type-llcompileroptions.enable_fast_isel" class="anchored"><td class="def record field"><a href="#type-llcompileroptions.enable_fast_isel" class="anchor"></a><code><span>enable_fast_isel : bool;</span></code></td></tr></table><code><span>}</span></code></div><div class="spec-doc"><p>MCJIT compiler options. See <code>llvm::TargetOptions</code>.</p></div></div><div class="odoc-spec"><div class="spec value" id="val-default_compiler_options" class="anchored"><a href="#val-default_compiler_options" class="anchor"></a><code><span><span class="keyword">val</span> default_compiler_options : <a href="#type-llcompileroptions">llcompileroptions</a></span></code></div><div class="spec-doc"><p>Default MCJIT compiler options: <code>{ opt_level = 0; code_model = CodeModel.JIT_default;
       no_framepointer_elim = false; enable_fast_isel = false }</code></p></div></div><div class="odoc-spec"><div class="spec value" id="val-create" class="anchored"><a href="#val-create" class="anchor"></a><code><span><span class="keyword">val</span> create : <span>?options:<a href="#type-llcompileroptions">llcompileroptions</a> <span class="arrow">&#45;&gt;</span></span> <span><a href="../Llvm/index.html#type-llmodule">Llvm.llmodule</a> <span class="arrow">&#45;&gt;</span></span> <a href="#type-llexecutionengine">llexecutionengine</a></span></code></div><div class="spec-doc"><p><code>create m optlevel</code> creates a new MCJIT just-in-time compiler, taking ownership of the module <code>m</code> if successful with the desired optimization level <code>optlevel</code>. Raises <code>Error msg</code> if an error occurrs. The execution engine is not garbage collected and must be destroyed with <code>dispose ee</code>.</p><p>Run <a href="#val-initialize"><code>initialize</code></a> before using this function.</p><p>See the function <code>llvm::EngineBuilder::create</code>.</p></div></div><div class="odoc-spec"><div class="spec value" id="val-dispose" class="anchored"><a href="#val-dispose" class="anchor"></a><code><span><span class="keyword">val</span> dispose : <span><a href="#type-llexecutionengine">llexecutionengine</a> <span class="arrow">&#45;&gt;</span></span> unit</span></code></div><div class="spec-doc"><p><code>dispose ee</code> releases the memory used by the execution engine and must be invoked to avoid memory leaks.</p></div></div><div class="odoc-spec"><div class="spec value" id="val-add_module" class="anchored"><a href="#val-add_module" class="anchor"></a><code><span><span class="keyword">val</span> add_module : <span><a href="../Llvm/index.html#type-llmodule">Llvm.llmodule</a> <span class="arrow">&#45;&gt;</span></span> <span><a href="#type-llexecutionengine">llexecutionengine</a> <span class="arrow">&#45;&gt;</span></span> unit</span></code></div><div class="spec-doc"><p><code>add_module m ee</code> adds the module <code>m</code> to the execution engine <code>ee</code>.</p></div></div><div class="odoc-spec"><div class="spec value" id="val-remove_module" class="anchored"><a href="#val-remove_module" class="anchor"></a><code><span><span class="keyword">val</span> remove_module : <span><a href="../Llvm/index.html#type-llmodule">Llvm.llmodule</a> <span class="arrow">&#45;&gt;</span></span> <span><a href="#type-llexecutionengine">llexecutionengine</a> <span class="arrow">&#45;&gt;</span></span> unit</span></code></div><div class="spec-doc"><p><code>remove_module m ee</code> removes the module <code>m</code> from the execution engine <code>ee</code>. Raises <code>Error msg</code> if an error occurs.</p></div></div><div class="odoc-spec"><div class="spec value" id="val-run_static_ctors" class="anchored"><a href="#val-run_static_ctors" class="anchor"></a><code><span><span class="keyword">val</span> run_static_ctors : <span><a href="#type-llexecutionengine">llexecutionengine</a> <span class="arrow">&#45;&gt;</span></span> unit</span></code></div><div class="spec-doc"><p><code>run_static_ctors ee</code> executes the static constructors of each module in the execution engine <code>ee</code>.</p></div></div><div class="odoc-spec"><div class="spec value" id="val-run_static_dtors" class="anchored"><a href="#val-run_static_dtors" class="anchor"></a><code><span><span class="keyword">val</span> run_static_dtors : <span><a href="#type-llexecutionengine">llexecutionengine</a> <span class="arrow">&#45;&gt;</span></span> unit</span></code></div><div class="spec-doc"><p><code>run_static_dtors ee</code> executes the static destructors of each module in the execution engine <code>ee</code>.</p></div></div><div class="odoc-spec"><div class="spec value" id="val-data_layout" class="anchored"><a href="#val-data_layout" class="anchor"></a><code><span><span class="keyword">val</span> data_layout : <span><a href="#type-llexecutionengine">llexecutionengine</a> <span class="arrow">&#45;&gt;</span></span> <a href="../Llvm_target/DataLayout/index.html#type-t">Llvm_target.DataLayout.t</a></span></code></div><div class="spec-doc"><p><code>data_layout ee</code> is the data layout of the execution engine <code>ee</code>.</p></div></div><div class="odoc-spec"><div class="spec value" id="val-add_global_mapping" class="anchored"><a href="#val-add_global_mapping" class="anchor"></a><code><span><span class="keyword">val</span> add_global_mapping : 
  <span><a href="../Llvm/index.html#type-llvalue">Llvm.llvalue</a> <span class="arrow">&#45;&gt;</span></span>
  <span><span><span class="type-var">'a</span> <span class="xref-unresolved">Ctypes</span>.ptr</span> <span class="arrow">&#45;&gt;</span></span>
  <span><a href="#type-llexecutionengine">llexecutionengine</a> <span class="arrow">&#45;&gt;</span></span>
  unit</span></code></div><div class="spec-doc"><p><code>add_global_mapping gv ptr ee</code> tells the execution engine <code>ee</code> that the global <code>gv</code> is at the specified location <code>ptr</code>, which must outlive <code>gv</code> and <code>ee</code>. All uses of <code>gv</code> in the compiled code will refer to <code>ptr</code>.</p></div></div><div class="odoc-spec"><div class="spec value" id="val-get_global_value_address" class="anchored"><a href="#val-get_global_value_address" class="anchor"></a><code><span><span class="keyword">val</span> get_global_value_address : 
  <span>string <span class="arrow">&#45;&gt;</span></span>
  <span><span><span class="type-var">'a</span> <span class="xref-unresolved">Ctypes</span>.typ</span> <span class="arrow">&#45;&gt;</span></span>
  <span><a href="#type-llexecutionengine">llexecutionengine</a> <span class="arrow">&#45;&gt;</span></span>
  <span class="type-var">'a</span></span></code></div><div class="spec-doc"><p><code>get_global_value_address id typ ee</code> returns a pointer to the identifier <code>id</code> as type <code>typ</code>, which will be a pointer type for a value, and which will be live as long as <code>id</code> and <code>ee</code> are. Caution: this function finalizes, i.e. forces code generation, all loaded modules. Further modifications to the modules will not have any effect.</p></div></div><div class="odoc-spec"><div class="spec value" id="val-get_function_address" class="anchored"><a href="#val-get_function_address" class="anchor"></a><code><span><span class="keyword">val</span> get_function_address : <span>string <span class="arrow">&#45;&gt;</span></span> <span><span><span class="type-var">'a</span> <span class="xref-unresolved">Ctypes</span>.typ</span> <span class="arrow">&#45;&gt;</span></span> <span><a href="#type-llexecutionengine">llexecutionengine</a> <span class="arrow">&#45;&gt;</span></span> <span class="type-var">'a</span></span></code></div><div class="spec-doc"><p><code>get_function_address fn typ ee</code> returns a pointer to the function <code>fn</code> as type <code>typ</code>, which will be a pointer type for a function (e.g. <code>(int -&gt; int) typ</code>), and which will be live as long as <code>fn</code> and <code>ee</code> are. Caution: this function finalizes, i.e. forces code generation, all loaded modules. Further modifications to the modules will not have any effect.</p></div></div></div></body></html>